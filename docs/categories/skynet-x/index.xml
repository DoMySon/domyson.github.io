<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Skynet-X on 朝花夕拾</title>
    <link>https://domyson.github.io/categories/skynet/</link>
    <description>Recent content in Skynet-X on 朝花夕拾</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 22 Jul 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://domyson.github.io/categories/skynet/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>message</title>
      <link>https://domyson.github.io/post/skynet/1/</link>
      <pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/skynet/1/</guid>
      <description>&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;skynet&lt;/code&gt;是基于&lt;code&gt;actor&lt;/code&gt; 消息的服务框架，那么我们需要定义一套标准且高效的消息结构&lt;/p&gt;&#xA;&lt;h2 id=&#34;processor&#34;&gt;Processor&lt;/h2&gt;&#xA;&lt;p&gt;一个伪线程的逻辑处理器概念，它分为独占和负载两种模式。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;独占&lt;code&gt;Processor&lt;/code&gt;是为了更好的处理实时性更高的业务，它不会被其他任务抢占&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;负载&lt;code&gt;Processor&lt;/code&gt;又可分为两种运行态，均匀的处理业务以及从其他&lt;code&gt;Processor&lt;/code&gt;上偷窃任务，尽量保证&lt;code&gt;Processor&lt;/code&gt;不会过于闲置，除此之外，负载&lt;code&gt;Processor&lt;/code&gt;可随着任务的变动而增加（不会超过最大设定值），特别的当某个任务陷入”死循环”或者是超出设定运行阈值的时候会重新创建一个&lt;code&gt;Processor&lt;/code&gt;，并让之前的挂起（在C版本中将会被强制关闭）。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;C版本和Go版本调度和设计上差异不大，但一些细节上的处理可能不同，因为C可以提供更多的底层控制&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;pid&#34;&gt;PID&lt;/h2&gt;&#xA;&lt;p&gt;一个 &lt;code&gt;message&lt;/code&gt; 最重要的是消息地址，如果一个消息没有地址的话我们称为 &lt;code&gt;dead-letter&lt;/code&gt;。 那么我们通过&lt;code&gt;Pid&lt;/code&gt; 标定一个地址类型，&lt;/p&gt;&#xA;&lt;p&gt;它表示该服务的唯一id (本质上是一个&lt;code&gt;uint64&lt;/code&gt;)的类习惯，它一定能确保在当前节点以及集群中唯一的。&lt;/p&gt;&#xA;&lt;p&gt;在服务本身未被关闭的时候，&lt;code&gt;pid&lt;/code&gt;一定不会产生变动，但重新启动节点之后，它的值可能会发生改变，因为所有服务默认都是并发启动，除非手动指定了关系(这也是它与&lt;code&gt;skynet&lt;/code&gt;的区别)，所以不要尝试保存这个&lt;code&gt;pid&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;一旦能确定了一个&lt;code&gt;pid&lt;/code&gt;的话，就可以通过 &lt;code&gt;skynet.send(pid,cmd,...) or skynet.call(ti,pid,cmd,...)&lt;/code&gt; 将其发送出去了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;服务的消息队列&#34;&gt;服务的消息队列&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;Actor&lt;/code&gt; 模型最重要的的概念是 &lt;code&gt;mailbox&lt;/code&gt;,它代表了一个实体需要处理的队列容器，&lt;/p&gt;&#xA;&lt;p&gt;得益于&lt;code&gt;go&lt;/code&gt;的简单性，可以使用 &lt;code&gt;channel&lt;/code&gt; 来实现，但这种方式的实现性能不高，因为 &lt;code&gt;channel&lt;/code&gt; 底层的结构使用的是互斥锁，&lt;/p&gt;&#xA;&lt;p&gt;所以我采用了&lt;code&gt;mpsc&lt;/code&gt; 实现了无锁队列，性能更优于 &lt;code&gt;channel&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;TODO: 吞吐量对比&lt;/p&gt;&#xA;&lt;h1 id=&#34;消息的接受和发送&#34;&gt;消息的接受和发送&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;发送&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;用户不需要构建这个结构体，仅仅需要指定 &lt;code&gt;destination&lt;/code&gt; 以及需要发送的数据，而且 &lt;code&gt;skynet&lt;/code&gt; 消息投递被设计成不允许发送 &lt;code&gt;nil&lt;/code&gt; 因为这是无任何意义的，相反它还会消耗服务投递的性能，如果确实有这种需求，可以发送 &lt;code&gt;struct{}{}&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;而且消息发送成功只能代表被 &lt;code&gt;mailbox&lt;/code&gt; 接受了，不代表会被立即处理，而不会一定处理成功，所以需要正确理解这种方式。&lt;/p&gt;&#xA;&lt;p&gt;如果发送失败，那么一定失败，并返回一个错误&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接收&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;接受回调只包含&lt;code&gt;5&lt;/code&gt;个关键参数 &lt;code&gt;context&lt;/code&gt;,&lt;code&gt;addr&lt;/code&gt;,&lt;code&gt;session&lt;/code&gt;,&lt;code&gt;mtype&lt;/code&gt;,&lt;code&gt;argument&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;context&lt;/code&gt; 其实就是创建服务用户指定的结构指针，用于数据传递和状态修改&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;session&lt;/code&gt; 主要的作用是用以区分这条消息是否是同步请求， 如若大于0，则其值就是请求序列号,只需要通过 &lt;code&gt;skynet.ret(msg)&lt;/code&gt; 返回即可&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;mtype&lt;/code&gt; 仅仅是一个消息类别的区分，类似于消息号，用户可自行定义，可作为&lt;code&gt;rpc&lt;/code&gt;消息类型&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;argument&lt;/code&gt; 才是真实的数据，它可以是任意值，特别的，在&lt;code&gt;lua&lt;/code&gt;中这个值是会被解构，在跨节点通讯这个值恒为 &lt;code&gt;[]byte&lt;/code&gt;，&lt;del&gt;当不需要时记得 skynet.free&lt;/del&gt;  1.4.0 这个由底层回收，用户不用关心&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;异步消息&#34;&gt;异步消息&lt;/h1&gt;&#xA;&lt;p&gt;异步消息通过 &lt;code&gt;skynet.send&lt;/code&gt;的方式进行投递，它只在乎这个消息有没有正确到达到对点服务，而不关心是否能被对点服务正确处理，并返回一个 &lt;code&gt;error&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>skynet 服务器框架简介</title>
      <link>https://domyson.github.io/post/skynet/0/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/skynet/0/</guid>
      <description>&lt;p&gt;工作中曾经开发了一个&lt;code&gt;cobweb&lt;/code&gt;的分布式服务器框架（基于&lt;code&gt;golang&lt;/code&gt;,&lt;code&gt;c&lt;/code&gt;）,但是在实际开发过程中代码难以维护以及更新，主要是每次都需要跨平台进行编译，特别是&lt;code&gt;cgo&lt;/code&gt; 往往需要指定平台的系统库,而且一些不规范的使用方式造成无法充分发挥多核的优势，可以参见 &lt;code&gt;关于Go协程的思考&lt;/code&gt; 虽然1.16 支持抢占式，但错误的使用方式依然造成了cpu过高的问题。，后续重新设计了&lt;code&gt;skynet&lt;/code&gt; 是一个&lt;code&gt;actor&lt;/code&gt;模型分布式服务框架，使用&lt;code&gt;go&lt;/code&gt;编写。&lt;/p&gt;&#xA;&lt;p&gt;尽管&lt;code&gt;Actor&lt;/code&gt;模型和&lt;code&gt;CSP&lt;/code&gt;模型各有所有长，为什么不采用&lt;code&gt;CSP&lt;/code&gt;主要有两方面考虑。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;CSP&lt;/code&gt;模式使用尽管很简单，但是一个致命的问题是无法控制消息的优先级，当然若只处理一个&lt;code&gt;Channel&lt;/code&gt;那可以规避，那么为啥还需要使用&lt;code&gt;CSP&lt;/code&gt;,而且像go channel 本身是基于互斥锁（1.16）实现，且无法进行优化和更加精细的控制，只能依赖于&lt;code&gt;runtime&lt;/code&gt;的调度。（网上所说什么时候触发调度，我认为channel不能包含其中，它本质也是加锁导致切换）&lt;/li&gt;&#xA;&lt;li&gt;隔离性太弱，后续一些新的&lt;code&gt;channel&lt;/code&gt;引入也会造成破坏性修改，而且 &lt;code&gt;select-case&lt;/code&gt;模式等待的&lt;code&gt;channel&lt;/code&gt;会随着数量的增加性能会慢慢减弱。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;它是一个年轻的框架，仅仅经历了两款项目的迭代 现在版本为 &lt;code&gt;v1.6.0 2023-05-28&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.taptap.cn/app/229839&#34;&gt;羽翼军团&lt;/a&gt; v1.3.0&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.taptap.cn/app/215934&#34;&gt;我在民国淘古玩&lt;/a&gt; v.1.3.5&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;与skynet的差异&#34;&gt;与skynet的差异&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;增加了独占进程的概念，对于一些性能敏感的服务可以绕过公平调度的原则。（公平调度是一个很普遍但并非最优解的调度策略，但对于需要占用资源较多的进程就显得无力）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;使用协程而非线程，一个好处是对于一些假死服务我们可以重新启动它，其它代价远小于线程（尽管协程的开销很低，但我们尽量保证不会被滥用）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一个简单的二进制文件，&lt;code&gt;skynet&lt;/code&gt;修改了lua部分虚拟机源码，而且大部分实现都是基于&lt;code&gt;lua&lt;/code&gt;实现，而我设计的是一个将脚本语言作为可选项的插件。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;所有库都是底层语言的实现方式，可控制力和性能更好，完全将业务和底层区分方便同时进行维护&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;无感的集群交互方式，调用其他服务（无论在不在本地）就像普通消息那样简单，不需要像&lt;code&gt;skynet&lt;/code&gt;需要显示调用&lt;code&gt;cluster&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;进程支持错误重启且消息不会丢失（beta)&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;支持后续的&lt;a href=&#34;https://domyson.github.io/post/typelang/0&#34;&gt;DSL&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;在2024/03我正计划重新用C实现了一版以提供更好的性能和更底层的控制&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>sktpmd</title>
      <link>https://domyson.github.io/post/skynet/3/</link>
      <pubDate>Mon, 30 May 2022 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/skynet/3/</guid>
      <description>&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;sktpmd&lt;/code&gt;模块是&lt;code&gt;skynet&lt;/code&gt;底层集群模块，它承担了&lt;code&gt;skynet&lt;/code&gt;网络节点之间的通讯职能。全名为(&lt;code&gt;skynet port managment daemon&lt;/code&gt;)&lt;/p&gt;&#xA;&lt;h1 id=&#34;架构&#34;&gt;架构&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;sktpmd&lt;/code&gt; 为了满足对等网络的性质，所以每次和其他节点建立连接是有两条连接，&#xA;当A节点于B节点建立连接，首先A节点发送握手等待B确认，B确认完成之后重复走A的流程，这样一个双向连接就被建立了起来，&lt;strong&gt;&lt;a href=&#34;#v1.6.0%E9%9B%86%E7%BE%A4%E5%BB%BA%E7%AB%8B&#34;&gt;1.6.0&lt;/a&gt;改变了个行为&lt;/strong&gt;，对于像存在类似缓存，或者数据中心的业务而言的单向节点而言，只需要一条连接即可，节省资源。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;sktpmd&lt;/code&gt;现在支持原始的&lt;code&gt;tcp,udp,unix&lt;/code&gt;协议，后续规划可能由&lt;code&gt;reliable udp&lt;/code&gt;实现，降低集群通讯延时并提供更好的性能和时延性。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;远程命名服务，通过内置命令生成唯一的Name，通过Name来与其他节点通讯是友好的。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;使用&#34;&gt;使用&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;启动也非常简单，无须任何代码，仅仅只需要在 &lt;code&gt;conf.conf&lt;/code&gt; 中配置一下即可，使用的时候跟节点内通讯无任何区别。因为我已经作平了本地和节点之间的差异。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;内部均由&lt;a href=&#34;https://domyson.github.io/post/kproto&#34;&gt;kproto&lt;/a&gt;进行编码,提供更快的序列化方式。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;example call&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;skynet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x.send&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;host:port@name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;rpc&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;-- 通过域名或者地址+端口的形式和其他节点进行通讯&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;skynet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x.send&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;alias&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;rpc&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,...)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;-- 通过别名&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;skynet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x.send&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;rpc&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,...)&lt;/span&gt;              &lt;span class=&#34;c1&#34;&gt;-- 通过pid亦可&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;tunnel&#34;&gt;&lt;del&gt;tunnel&lt;/del&gt;&lt;/h1&gt;&#xA;&lt;p&gt;既然节点之间是双向连接，所以连接数量为 &lt;code&gt;f(n) =  n²-n&lt;/code&gt;，如果节点过的时候，势必造成 &lt;code&gt;socket fd&lt;/code&gt; 消耗殆尽，&lt;/p&gt;&#xA;&lt;p&gt;基于这个问题，可以通过内置的&lt;code&gt;tun&lt;/code&gt;，来设置代理，这么一来，&lt;code&gt;tun&lt;/code&gt;的作用相当于这个集群节点的网关。因为其内部的节点相对于其他 &lt;code&gt;tun&lt;/code&gt; 代理是不可见的，&lt;/p&gt;&#xA;&lt;p&gt;通过配置&lt;code&gt;tun&lt;/code&gt;的规则开启多个，则可以实现业务拆分。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;2022-10-07 此模块被弃用，可以用多节点转接的方式或代理的方式做到，如 &lt;code&gt;send(&amp;quot;n1.n2.n3@name&amp;quot;)&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;服务发现&#34;&gt;&lt;del&gt;服务发现&lt;/del&gt;&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;sktpmd&lt;/code&gt; 提供了一套服务发现机制，但其运作原理是不同于 &lt;code&gt;etcd&lt;/code&gt; 或者 &lt;code&gt;consul&lt;/code&gt;,它本身是一个惰性发现，它不需要一个中心服维持它们的关系。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;sktpmd整个发现流程是基于 &lt;code&gt;gossip&lt;/code&gt; 算法来发现的,但一些api依然可以主动触发，&lt;code&gt;v1.6.0&lt;/code&gt; 这个模块将保留，因为集群模式的逻辑改变了&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;v160集群建立&#34;&gt;v1.6.0集群建立&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;v1.5.0&lt;/code&gt; 之前节点之间都是双向链接，但考虑到一个单向服务器，如 &lt;code&gt;dns server&lt;/code&gt;,&lt;code&gt;conf server&lt;/code&gt; 等，大部分是 &lt;code&gt;request/response&lt;/code&gt; 模式，惰性连接的收益很大，所以去除之前的一些设计。&lt;/p&gt;&#xA;&lt;h1 id=&#34;网络底层&#34;&gt;网络底层&lt;/h1&gt;&#xA;&lt;p&gt;参考 &lt;a href=&#34;https://domyson.github.io/post/language/go/goroutine&#34;&gt;Go协程的思考&lt;/a&gt;,在&lt;code&gt;linux&lt;/code&gt;下，使用了 &lt;code&gt;epoll&lt;/code&gt;。所以尽量部署到 &lt;code&gt;linux&lt;/code&gt; 下以发挥更好的性能&lt;/p&gt;</description>
    </item>
    <item>
      <title>zmalloc</title>
      <link>https://domyson.github.io/post/skynet/5/</link>
      <pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/skynet/5/</guid>
      <description>&lt;p&gt;无论是对于C版本还是Go版本的&lt;code&gt;skynet&lt;/code&gt;而言，一个高效的内存分配器可以提高内存的使用效率，这里效率无论是对于内存碎片亦或是GC而言，都是一种更高效的手段&lt;/p&gt;&#xA;&lt;h1 id=&#34;基于-slab-算法的分段内存分配器&#34;&gt;基于 &lt;code&gt;SLAB&lt;/code&gt; 算法的分段内存分配器&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;SLAB&lt;/code&gt; 最开始是阅读 &lt;code&gt;linux&lt;/code&gt; 源码学习的算法，在&lt;code&gt;skynet&lt;/code&gt;中它确实有更优秀的性能，因为它直接分配了一块大共用内存，所以不会产生任何GC和真实分配,但在业务开发过程中，一旦忘记释放 那么这段内存将不能再被使用和获取了（也就是野指针），直到程序结束。最后的保守策略依然会向&lt;code&gt;runtime&lt;/code&gt;申请内存，将会导致内存占用过高。&lt;/p&gt;&#xA;&lt;p&gt;而且内置的&lt;code&gt;Debug&lt;/code&gt;模式也无法定位到这个指针，原因在于 golang 堆栈伸缩会导致指针地址变动，所以 &lt;code&gt;Debug&lt;/code&gt; 只能定位到存在 &lt;code&gt;memory-leak&lt;/code&gt;，而无法知道具体位置。若需要具体位置则需要hook这个调用栈，性能方面得不偿失&lt;/p&gt;&#xA;&lt;h1 id=&#34;基于-syncpool-的分段内存分配器&#34;&gt;基于 &lt;code&gt;sync.Pool&lt;/code&gt; 的分段内存分配器&lt;/h1&gt;&#xA;&lt;p&gt;将不同size的buffer放入不同的池中，按需进行分配，减少race的开销，这个方法虽然简单，但是性能是低于 &lt;code&gt;slab-allocator&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;但它确实能减轻心智负担，代价就是牺牲了部分性能以及gc压力，但这也是&lt;code&gt;skynet&lt;/code&gt;默认使用的策略。如果需要使用可以在编译指令中指明&lt;code&gt;slab&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;zmalloc&#34;&gt;Zmalloc&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;zmlloc&lt;/code&gt; 本身也是 &lt;code&gt;slab&lt;/code&gt;的升级版本，增加可伸缩链表实现对于预分配内存额外部分的缓冲池。&lt;/p&gt;&#xA;&lt;p&gt;在24个线程的cpu条件测试结果如下,&lt;code&gt;zmalloc&lt;/code&gt;保持了一种稳定的时间复杂度，额外产生的内存分配也很少&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;-&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;time(ns)&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;alloc/op(B)&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;slab-128&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;23.5&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;sync.Pool-128&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;2490&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;65562&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;zmalloc-128&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;43.31&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;16&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;slab-256&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;24&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;256&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;sync.Pool-256&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;2204&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;65562&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;zmalloc-256&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;44&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;16&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;slab-1024&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;92&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;1024&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;sync.Pool-1024&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;2490&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;65562&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;zmalloc-1024&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;49&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;17&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;slab-4096&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;365&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;4096&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;sync.Pool-4096&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;2210&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;65562&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;zmalloc-4096&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;45&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;23&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h1 id=&#34;api&#34;&gt;API&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;skynet.zalloc(n)&lt;/code&gt; 用以分配指定大小的内存块，考虑到 64在go中为tiny-size，直接会从P上分配，所以zmalloc分配块从128开始&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;skynet.zrealloc(buf,n)&lt;/code&gt; realloc函数会先检查buf，确保是否需要重新分配内存&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
