<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>skynet on Treasure</title>
    <link>https://domyson.github.io/categories/skynet/</link>
    <description>Recent content in skynet on Treasure</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 21 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://domyson.github.io/categories/skynet/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>allocator</title>
      <link>https://domyson.github.io/post/sknt/allocator/</link>
      <pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/sknt/allocator/</guid>
      <description>简介 alloctor 模块主要是为了减少GC而开发。现支持两套分配规则
基于 SLAB 算法的分段内存分配器 SLAB 最开始是阅读 linux 源码学习的算法，在skynet中它确实有更优秀的性能，因为它直接分配了一块共用内存，所以不会产生任何GC和真实分配, ，但在业务开发过程中，一旦忘记释放 那么这段内存将不能再被使用和获取了（也就是野指针），直到程序结束。
哪怕内置的Debug模式也无法定位到这个指针，原因在于 golang 堆栈伸缩会导致指针地址变动，所以 Debug 只能定位到存在 memory-leak，而无法知道具体位置。若需要具体位置则需要hook这个调用栈，性能方面得不偿失
slab-allocator 对业务开发很不友好，最终只是将它保留作为可选项，是否使用取决于业务实际需要，因为它违背了 skynet 的设计初衷。
如果需要使用可以在编译指令中指明slab
2020-10-18 阅读sync.Pool源码，看看能不能够和指定的P进行绑定，减少锁
基于 sync.Pool 的分段内存分配器 将不同size的buffer放入不同的池中，按需进行分配，减少race的开销
这个方法虽然简单，但是性能是低于 slab-allocator。
但它确实能减轻心智负担，代价就是牺牲了部分性能以及gc压力，但这也是skynet默认使用的策略。
API skynet.alloc(n) 用以分配指定大小的内存块
skynet.realloc(buf,n) realloc函数会先检查buf，确保是否需要重新分配内存
skynet.append(buf,data) 简化了 realloc 和 copy 的操作。
skynet.free(buf) 释放一段内存,对于slab 而言，它会检查buf的地址是否属于当前段</description>
    </item>
    
  </channel>
</rss>
