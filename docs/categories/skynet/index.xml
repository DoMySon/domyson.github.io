<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Skynet on 朝花夕拾</title>
    <link>http://localhost:1313/categories/skynet/</link>
    <description>Recent content in Skynet on 朝花夕拾</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 30 Jan 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/skynet/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>eventbus</title>
      <link>http://localhost:1313/post/skynet/2/</link>
      <pubDate>Thu, 30 Jan 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/post/skynet/2/</guid>
      <description>&lt;h1 id=&#34;事件总线&#34;&gt;事件总线&lt;/h1&gt;&#xA;&lt;p&gt;消息订阅，发布是每个服务器都必备的机制，当然 &lt;code&gt;skynet&lt;/code&gt; 也不例外，而且更加优雅。&lt;/p&gt;&#xA;&lt;p&gt;绕不开传统的事件订阅流程，&lt;code&gt;skynet&lt;/code&gt;的事件总线是一个&lt;code&gt;process&lt;/code&gt;,意味着&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;所以事件订阅发布都是异步的，&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;所有消息的发布是可调度的（参见上节 &lt;code&gt;scheduler&lt;/code&gt;）,&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可以通过控制独占来解决事件总线的调度频率&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;emm&amp;hellip; 似乎也没什么好些的，&lt;code&gt;eventbus&lt;/code&gt;更像底层某些机制的封装，了解即可&lt;/p&gt;&#xA;&lt;script async src=&#34;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7934154300350596&#34;&#xA;     crossorigin=&#34;anonymous&#34;&gt;&lt;/script&gt;&#xA;&#xA;&lt;ins class=&#34;adsbygoogle&#34;&#xA;     style=&#34;display:block&#34;&#xA;     data-ad-client=&#34;ca-pub-7934154300350596&#34;&#xA;     data-ad-slot=&#34;3469296166&#34;&#xA;     data-ad-format=&#34;auto&#34;&#xA;     data-full-width-responsive=&#34;true&#34;&gt;&lt;/ins&gt;&#xA;&lt;script&gt;&#xA;     (adsbygoogle = window.adsbygoogle || []).push({});&#xA;&lt;/script&gt;</description>
    </item>
    <item>
      <title>scheduler</title>
      <link>http://localhost:1313/post/skynet/1/</link>
      <pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/post/skynet/1/</guid>
      <description>&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;skynet&lt;/code&gt; 实现了一套调度器机制，用以调度 &lt;code&gt;process&lt;/code&gt;, 与云风大佬不同的是，&lt;code&gt;sched&lt;/code&gt; 支持公平模式以及独占模式，独占模式主要是为了解决特性场景下业务的响应速度，从而提升体验感，&#xA;其次，不一定需要按照每个 &lt;code&gt;process&lt;/code&gt; 对应一条协程，减少&lt;code&gt;runtime&lt;/code&gt;调度以及内存的开销&lt;/p&gt;&#xA;&lt;h2 id=&#34;sched&#34;&gt;Sched&lt;/h2&gt;&#xA;&lt;p&gt;一个伪线程的逻辑处理器概念，它分为独占和负载两种模式。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;独占是为了更好的处理实时性更高的业务，它不会被其他任务抢占&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;负载&lt;code&gt;又可分为两种运行态，均匀的处理业务以及从其他&lt;/code&gt;process&lt;code&gt;上偷窃任务，尽量保证&lt;/code&gt;Processor&lt;code&gt;不会过于闲置，除此之外，负载&lt;/code&gt;Processor&lt;code&gt;可随着任务的变动而增加（不会超过最大设定值），特别的当某个任务陷入”死循环”或者是超出设定运行阈值的时候会重新创建一个&lt;/code&gt;Processor`，并让之前的挂起（在C版本中将会被强制关闭）。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;多数时候协程过多会造成系统压力。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;C版本和Go版本调度和设计上差异不大，但一些细节上的处理可能不同，因为C可以提供更多的底层控制&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;process&#34;&gt;Process&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;process&lt;/code&gt; 是一种用户态的伪概念，用于描述一个 &lt;code&gt;actor&lt;/code&gt;的具体实现方式，也是 &lt;code&gt;skynet&lt;/code&gt;最小调度单元，这种概念对于分布式而言更友好，无关乎process在哪，只需要知道 &lt;code&gt;PID&lt;/code&gt; 或者 &lt;code&gt;Alias&lt;/code&gt; 即可向其投送消息。&#xA;主要是对业务几乎无侵入&lt;/p&gt;&#xA;&lt;h2 id=&#34;message&#34;&gt;Message&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;message&lt;/code&gt; 是 &lt;code&gt;skynet&lt;/code&gt; 基础消息承载结构&lt;/p&gt;&#xA;&lt;h2 id=&#34;服务的消息队列&#34;&gt;服务的消息队列&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;Actor&lt;/code&gt; 模型最重要的的概念是 &lt;code&gt;mailbox&lt;/code&gt;,它代表了一个实体需要处理的队列容器，&lt;/p&gt;&#xA;&lt;p&gt;得益于&lt;code&gt;go&lt;/code&gt;的简单性，可以使用 &lt;code&gt;channel&lt;/code&gt; 来实现，但这种方式的实现性能不高，因为 &lt;code&gt;channel&lt;/code&gt; 底层的结构使用的是互斥锁，&lt;/p&gt;&#xA;&lt;p&gt;所以我采用了&lt;code&gt;mpsc&lt;/code&gt; 实现了无锁队列，性能更优于 &lt;code&gt;channel&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;TODO: 吞吐量对比&lt;/p&gt;&#xA;&lt;h1 id=&#34;消息的接受和发送&#34;&gt;消息的接受和发送&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;发送&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;用户不需要构建这个结构体，仅仅需要指定 &lt;code&gt;dest&lt;/code&gt; 以及需要发送的数据，而且 &lt;code&gt;skynet&lt;/code&gt; 消息投递被设计成不允许发送 &lt;code&gt;nil&lt;/code&gt; 因为这是无任何意义的，相反它还会消耗服务投递的性能，如果确实有这种需求，可以发送 &lt;code&gt;struct{}{}&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;至于这个节点是再本地，还是其他地方并不重要&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接收&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;接受回调只包含&lt;code&gt;5&lt;/code&gt;个关键参数 &lt;code&gt;context&lt;/code&gt;,&lt;code&gt;addr&lt;/code&gt;,&lt;code&gt;session&lt;/code&gt;,&lt;code&gt;mtype&lt;/code&gt;,&lt;code&gt;msg&lt;/code&gt;,&lt;code&gt;size&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;context&lt;/code&gt; 其实就是创建&lt;code&gt;process&lt;/code&gt;指定的结构指针，用于表示处理上下文&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;addr&lt;/code&gt; 即为投递者的&lt;code&gt;Pid&lt;/code&gt;,(需要注意的是，&lt;code&gt;skynet&lt;/code&gt;支持&lt;code&gt;redirect&lt;/code&gt; 以及 &lt;code&gt;fake&lt;/code&gt;模式，所以这地址需要在发送的时候明确)&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;session&lt;/code&gt; 主要的作用是用以区分这条消息是否是同步请求， 如若大于0，则其值就是请求序列号,只需要通过 &lt;code&gt;skynet.ret(msg)&lt;/code&gt; 返回即可&lt;/p&gt;</description>
    </item>
    <item>
      <title>skynet 服务器框架简介</title>
      <link>http://localhost:1313/post/skynet/0/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/post/skynet/0/</guid>
      <description>&lt;p&gt;工作中曾经开发了一个&lt;code&gt;cobweb&lt;/code&gt;的分布式服务器框架（基于&lt;code&gt;golang&lt;/code&gt;,&lt;code&gt;c&lt;/code&gt;）,但是在实际开发过程中代码难以维护以及更新，主要是每次都需要跨平台进行编译，特别是&lt;code&gt;cgo&lt;/code&gt; 往往需要指定平台的系统库,而且一些不规范的使用方式造成无法充分发挥多核的优势，可以参见 &lt;code&gt;关于Go协程的思考&lt;/code&gt; 虽然1.16 支持抢占式，但错误的使用方式依然造成了cpu过高的问题。，后续重新设计了&lt;code&gt;skynet&lt;/code&gt; 是一个&lt;code&gt;actor&lt;/code&gt;模型分布式服务框架，使用&lt;code&gt;go&lt;/code&gt;编写。&lt;/p&gt;&#xA;&lt;p&gt;尽管&lt;code&gt;Actor&lt;/code&gt;模型和&lt;code&gt;CSP&lt;/code&gt;模型各有所有长，为什么不采用&lt;code&gt;CSP&lt;/code&gt;主要有以下方面考虑。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;CSP&lt;/code&gt;模式使用尽管很简单，但是一个致命的问题是无法控制消息的优先级，当然若只处理一个&lt;code&gt;Channel&lt;/code&gt;那可以规避，那么为啥还需要使用&lt;code&gt;CSP&lt;/code&gt;,而且像go channel 本身是基于互斥锁（1.16）实现，且无法进行优化和更加精细的控制，只能依赖于&lt;code&gt;runtime&lt;/code&gt;的调度。（网上所说什么时候触发调度，我认为channel不能包含其中，它本质也是加锁导致切换）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;隔离性太弱，后续一些新的&lt;code&gt;channel&lt;/code&gt;引入也会造成破坏性修改。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;select-case&lt;/code&gt;模式会随着等待数量的增加性能会慢慢减弱。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;channel&lt;/code&gt; 多大合适？&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;它是一个年轻的框架，仅仅经历了两款项目的迭代 &lt;del&gt;现在版本为 &lt;code&gt;v1.6.0 2023-05-28&lt;/code&gt;&lt;/del&gt; 重启了 v2 版本&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.taptap.cn/app/229839&#34;&gt;羽翼军团&lt;/a&gt; v1.3.0&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.taptap.cn/app/215934&#34;&gt;我在民国淘古玩&lt;/a&gt; v.1.3.5&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>sktpmd</title>
      <link>http://localhost:1313/post/skynet/3/</link>
      <pubDate>Mon, 30 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/post/skynet/3/</guid>
      <description>&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;sktpmd&lt;/code&gt;模块是&lt;code&gt;skynet&lt;/code&gt;底层集群模块，它承担了&lt;code&gt;skynet&lt;/code&gt;网络节点之间的通讯职能。全名为(&lt;code&gt;skynet port managment daemon&lt;/code&gt;)&lt;/p&gt;&#xA;&lt;h1 id=&#34;架构&#34;&gt;架构&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;sktpmd&lt;/code&gt; 为了满足对等网络的性质，所以每次和其他节点建立连接是有两条连接，&#xA;当A节点于B节点建立连接，首先A节点发送握手等待B确认，B确认完成之后重复走A的流程，这样一个双向连接就被建立了起来，&lt;strong&gt;&lt;a href=&#34;#v1.6.0%E9%9B%86%E7%BE%A4%E5%BB%BA%E7%AB%8B&#34;&gt;1.6.0&lt;/a&gt;改变了个行为&lt;/strong&gt;，对于像存在类似缓存，或者数据中心的业务而言的单向节点而言，只需要一条连接即可，节省资源。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;sktpmd&lt;/code&gt;现在支持原始的&lt;code&gt;tcp,udp,unix&lt;/code&gt;协议，后续规划可能由&lt;code&gt;reliable udp&lt;/code&gt;实现，降低集群通讯延时并提供更好的性能和时延性。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;远程命名服务，通过内置命令生成唯一的Name，通过Name来与其他节点通讯是友好的。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;使用&#34;&gt;使用&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;启动也非常简单，无须任何代码，仅仅只需要在 &lt;code&gt;conf.conf&lt;/code&gt; 中配置一下即可，使用的时候跟节点内通讯无任何区别。因为我已经作平了本地和节点之间的差异。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;内部均由&lt;a href=&#34;http://localhost:1313/post/kproto&#34;&gt;kproto&lt;/a&gt;进行编码,提供更快的序列化方式。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;example call&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;skynet.send&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;host:port@name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;rpc&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;-- 通过域名或者地址+端口的形式和其他节点进行通讯&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;skynet.send&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;alias&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;rpc&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,...)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;-- 通过别名&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;skynet.send&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;rpc&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,...)&lt;/span&gt;              &lt;span class=&#34;c1&#34;&gt;-- 通过pid亦可&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;tunnel&#34;&gt;&lt;del&gt;tunnel&lt;/del&gt;&lt;/h1&gt;&#xA;&lt;p&gt;既然节点之间是双向连接，所以连接数量为 &lt;code&gt;f(n) =  n²-n&lt;/code&gt;，如果节点过的时候，势必造成 &lt;code&gt;socket fd&lt;/code&gt; 消耗殆尽，&lt;/p&gt;&#xA;&lt;p&gt;基于这个问题，可以通过内置的&lt;code&gt;tun&lt;/code&gt;，来设置代理，这么一来，&lt;code&gt;tun&lt;/code&gt;的作用相当于这个集群节点的网关。因为其内部的节点相对于其他 &lt;code&gt;tun&lt;/code&gt; 代理是不可见的，&lt;/p&gt;&#xA;&lt;p&gt;通过配置&lt;code&gt;tun&lt;/code&gt;的规则开启多个，则可以实现业务拆分。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;2022-10-07 此模块被弃用，可以用多节点转接的方式或代理的方式做到，如 &lt;code&gt;send(&amp;quot;n1.n2.n3@name&amp;quot;)&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;服务发现&#34;&gt;&lt;del&gt;服务发现&lt;/del&gt;&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;sktpmd&lt;/code&gt; 提供了一套服务发现机制，但其运作原理是不同于 &lt;code&gt;etcd&lt;/code&gt; 或者 &lt;code&gt;consul&lt;/code&gt;,它本身是一个惰性发现，它不需要一个中心服维持它们的关系。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;sktpmd整个发现流程是基于 &lt;code&gt;gossip&lt;/code&gt; 算法来发现的,但一些api依然可以主动触发，&lt;code&gt;v1.6.0&lt;/code&gt; 这个模块将保留，因为集群模式的逻辑改变了&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;v160集群建立&#34;&gt;v1.6.0集群建立&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;v1.5.0&lt;/code&gt; 之前节点之间都是双向链接，但考虑到一个单向服务器，如 &lt;code&gt;dns server&lt;/code&gt;,&lt;code&gt;conf server&lt;/code&gt; 等，大部分是 &lt;code&gt;request/response&lt;/code&gt; 模式，惰性连接的收益很大，所以去除之前的一些设计。&lt;/p&gt;&#xA;&lt;h1 id=&#34;网络底层&#34;&gt;网络底层&lt;/h1&gt;&#xA;&lt;p&gt;参考 &lt;a href=&#34;http://localhost:1313/post/language/go/goroutine&#34;&gt;Go协程的思考&lt;/a&gt;,在&lt;code&gt;linux&lt;/code&gt;下，使用了 &lt;code&gt;epoll&lt;/code&gt;。所以尽量部署到 &lt;code&gt;linux&lt;/code&gt; 下以发挥更好的性能&lt;/p&gt;&#xA;&lt;script async src=&#34;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7934154300350596&#34;&#xA;     crossorigin=&#34;anonymous&#34;&gt;&lt;/script&gt;&#xA;&#xA;&lt;ins class=&#34;adsbygoogle&#34;&#xA;     style=&#34;display:block&#34;&#xA;     data-ad-client=&#34;ca-pub-7934154300350596&#34;&#xA;     data-ad-slot=&#34;3469296166&#34;&#xA;     data-ad-format=&#34;auto&#34;&#xA;     data-full-width-responsive=&#34;true&#34;&gt;&lt;/ins&gt;&#xA;&lt;script&gt;&#xA;     (adsbygoogle = window.adsbygoogle || []).push({});&#xA;&lt;/script&gt;</description>
    </item>
    <item>
      <title>scheduler</title>
      <link>http://localhost:1313/post/skynet/4/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/post/skynet/4/</guid>
      <description>&lt;h1 id=&#34;等后续补充很多概念描述起来比较绕等有空再写-偷个懒&#34;&gt;等后续补充，很多概念描述起来比较绕，等有空再写 （偷个懒）&lt;/h1&gt;&#xA;&lt;script async src=&#34;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7934154300350596&#34;&#xA;     crossorigin=&#34;anonymous&#34;&gt;&lt;/script&gt;&#xA;&#xA;&lt;ins class=&#34;adsbygoogle&#34;&#xA;     style=&#34;display:block&#34;&#xA;     data-ad-client=&#34;ca-pub-7934154300350596&#34;&#xA;     data-ad-slot=&#34;3469296166&#34;&#xA;     data-ad-format=&#34;auto&#34;&#xA;     data-full-width-responsive=&#34;true&#34;&gt;&lt;/ins&gt;&#xA;&lt;script&gt;&#xA;     (adsbygoogle = window.adsbygoogle || []).push({});&#xA;&lt;/script&gt;</description>
    </item>
    <item>
      <title>zmalloc</title>
      <link>http://localhost:1313/post/skynet/5/</link>
      <pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/post/skynet/5/</guid>
      <description>&lt;p&gt;无论是对于C版本还是Go版本的&lt;code&gt;skynet&lt;/code&gt;而言，一个高效的内存分配器可以提高内存的使用效率，这里效率无论是对于内存碎片亦或是GC而言，都是一种更高效的手段&lt;/p&gt;&#xA;&lt;h1 id=&#34;基于-slab-算法的分段内存分配器&#34;&gt;基于 &lt;code&gt;SLAB&lt;/code&gt; 算法的分段内存分配器&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;SLAB&lt;/code&gt; 最开始是阅读 &lt;code&gt;linux&lt;/code&gt; 源码学习的算法，在&lt;code&gt;skynet&lt;/code&gt;中它确实有更优秀的性能，因为它直接分配了一块大共用内存，所以不会产生任何GC和真实分配,但在业务开发过程中，一旦忘记释放 那么这段内存将不能再被使用和获取了（也就是野指针），直到程序结束。最后的保守策略依然会向&lt;code&gt;runtime&lt;/code&gt;申请内存，将会导致内存占用过高。&lt;/p&gt;&#xA;&lt;p&gt;而且内置的&lt;code&gt;Debug&lt;/code&gt;模式也无法定位到这个指针，原因在于 golang 堆栈伸缩会导致指针地址变动，所以 &lt;code&gt;Debug&lt;/code&gt; 只能定位到存在 &lt;code&gt;memory-leak&lt;/code&gt;，而无法知道具体位置。若需要具体位置则需要hook这个调用栈，性能方面得不偿失&lt;/p&gt;&#xA;&lt;h1 id=&#34;基于-syncpool-的分段内存分配器&#34;&gt;基于 &lt;code&gt;sync.Pool&lt;/code&gt; 的分段内存分配器&lt;/h1&gt;&#xA;&lt;p&gt;将不同size的buffer放入不同的池中，按需进行分配，减少race的开销，这个方法虽然简单，但是性能是低于 &lt;code&gt;slab&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;但它确实能减轻心智负担，代价就是牺牲了部分性能以及gc压力，但这也是&lt;code&gt;skynet&lt;/code&gt;默认使用的策略。如果需要使用可以在编译指令中指明&lt;code&gt;slab&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;zmalloc&#34;&gt;Zmalloc&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;zmalloc&lt;/code&gt; 本身也是 &lt;code&gt;slab&lt;/code&gt;的升级版本，增加可伸缩链表实现对于预分配内存额外部分的缓冲池。&lt;/p&gt;&#xA;&lt;p&gt;在24个线程的cpu条件测试结果如下,&lt;code&gt;zmalloc&lt;/code&gt;保持了一种稳定的时间复杂度，额外产生的内存分配也很少&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;-&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;time(ns)&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;alloc/op(B)&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;slab-128&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;23.5&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;sync.Pool-128&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;2490&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;65562&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;zmalloc-128&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;43.31&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;16&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;slab-256&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;24&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;256&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;sync.Pool-256&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;2204&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;65562&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;zmalloc-256&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;44&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;16&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;slab-1024&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;92&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;1024&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;sync.Pool-1024&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;2490&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;65562&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;zmalloc-1024&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;49&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;17&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;slab-4096&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;365&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;4096&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;sync.Pool-4096&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;2210&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;65562&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;zmalloc-4096&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;45&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;23&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h1 id=&#34;api&#34;&gt;API&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;skynet.zalloc(n)&lt;/code&gt; 用以分配指定大小的内存块，考虑到 64在go中为tiny-size，直接会从P上分配，所以zmalloc分配块从128开始&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;skynet.zrealloc(buf,n)&lt;/code&gt; realloc函数会先检查buf，确保是否需要重新分配内存&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
