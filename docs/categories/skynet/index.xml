<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>skynet on 满船清梦压星河</title>
    <link>http://localhost:1313/categories/skynet/</link>
    <description>Recent content in skynet on 满船清梦压星河</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 17 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/categories/skynet/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>conf</title>
      <link>http://localhost:1313/post/skynet/conf/</link>
      <pubDate>Sat, 17 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/skynet/conf/</guid>
      <description>skynet config 在1.4.0版本之前，类似于skynet，是通过一个lua来作为配置文件启动的，但之后实现了一个高性能的ini解析器来作为配置加载器，好处是可以省略一个类似 launcher 的 LuaState。并且加载速度更快
example # 修改当前节点的 work directory root = ./example # go插件的搜索路径，特别注意的是它仅仅是将它作为一个服务启动，这本不同于lua plugin_path = ./ # 版本检查选项，若开启它则自动会检查版本是否匹配，版本是通过编译指令设置的。 #version = &amp;#34;1.3.1&amp;#34; # 以后台进程的方式启动 #daemon = &amp;#34;./skynet.pid&amp;#34; # 这个节点不是 sknt 标准选项，需要注意的是 lua模块是一个可编译选项，而不是 sknt自带的 [lua] path=./cop/?.lua; # other go written lua module plugin_path = ./lua_plugin # launch first scritp main = pool # 集群选项 # [sknmpd] # name = &amp;#34;node1&amp;#34; # can use follwing hosts value. &amp;#34;:port ip:port&amp;#34; # cookie= &amp;#34;hello world&amp;#34; # defualt the skynet version.</description>
    </item>
    
    <item>
      <title>message</title>
      <link>http://localhost:1313/post/skynet/message/</link>
      <pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/skynet/message/</guid>
      <description>简介 skynet是基于消息的服务框架，它承担了其中消息的传递。
服务的消息队列 存在两个版本，一个是基于go channel，另外一个基于无锁缓冲队列，后续有时间会单独解释。
唯一的区别是 第二种方式需要手动控制调度调度规则，对服务参数的配置有更高的要求，正确的配置,内存以及性能会比 go channel的方式略高
TODO: 吞吐量对比
消息的接受和发送 发送 用户不需要构建这个结构体，仅仅需要指定 destination 以及需要发送的数据，而且 skynet 消息投递被设计成不允许发送 nil 因为这是无任何意义的，相反它消耗服务投递的性能， 如果确实有这种需求，可以发送 struct{}{}
接收 关键性参数只有三个，session,typ,以及 argument,
session 主要的作用是用以区分这条消息是否大于0，若为真，则其值就是请求序列号，本节点保证唯一 typ 仅仅是一个消息类别的区分，类似于消息号，用户可自行定义 argument 才是真实的数据，它可以是任意值，特别的，在lua中这个值是会被解构，在跨节点通讯这个值恒为 []byte，当不需要时记得 skynet.free 1.4.0 这个由runtime回收 异步消息 异步消息通过 skynet.send的方式进行投递，它只在乎这个消息有没有正确到达到对点服务，而不关心是否能被对点服务正确处理，返回一个 error
同步消息 同步消息通过 skynet.call的方式进行投递，它会阻塞当前协程（goroutine 或者是 coroutine），它也返回一个错误，能解除此次阻塞只有两个条件，对点服务skynet.ret 或者达到了指定超时时间， 所以特别在远程通讯的时候要考虑到 i/o 的延时
dead letter 这个很好理解，同erlang 主要是确保数据的一致性，保证重要的数据不会因为某个服务的意外退出而丢失了这些消息.</description>
    </item>
    
    <item>
      <title>skynet-go 设计初衷以及特性</title>
      <link>http://localhost:1313/post/skynet/skynet/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/skynet/skynet/</guid>
      <description>&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;skynet-go&lt;/code&gt; 是一个基于消息和服务的分布式服务框架，采用&lt;code&gt;go&lt;/code&gt;编写，致力于简化开发难度和成本，
参考了云风的 &lt;a href=&#34;https://github.com/cloudwu/skynet&#34;&gt;skynet&lt;/a&gt; 以及 &lt;code&gt;erlang&lt;/code&gt;的思想。&lt;/p&gt;
&lt;p&gt;它是一个年轻的框架，仅仅经历了两款项目的迭代&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.taptap.cn/app/229839&#34;&gt;羽翼军团&lt;/a&gt; v1.3.0&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.taptap.cn/app/215934&#34;&gt;我在民国淘古玩&lt;/a&gt; v.1.3.5&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>sktpmd</title>
      <link>http://localhost:1313/post/skynet/sktpmd/</link>
      <pubDate>Mon, 30 May 2022 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/skynet/sktpmd/</guid>
      <description>简介 sktpmd模块是skynet底层集群模块，它承担了skynet网络节点之间的通讯职能。全名为(skynet port managment daemon)
架构 sktpmd 为了满足对等网络的性质，所以每次和其他节点建立连接是有两条连接， 当A节点于B节点建立连接，首先A节点发送握手等待B确认，B确认完成之后重复走A的流程，这样一个双向连接就被建立了起来
sktpmd可以支持任意网络协议，如 tcp,udp 甚至是 unix
当然一个好记的节点名称是非常有必要的，所以sktpmd也内置了一套非标准的本地 dns系统
使用 sktpmd的启动也非常简单，无须任何代码，仅仅只需要在 skynet.toml 中配置一下即可，使用的时候跟节点内通讯无任何区别，但要求参数必须是 []byte 类型，参考 bbuf 如
skynet.send(&amp;#34;host:port@name&amp;#34;,...) -- 通过域名或者地址+端口的形式和其他节点进行通讯 skynet.send(pid,...) -- 通过pid亦可 tunnel 既然节点之间是双向连接，所以连接数量为 f(n) = n²-n，如果节点过的时候，势必造成 socket fd 消耗殆尽，
基于这个问题，可以通过内置的tun，来设置代理，这么一来，tun的作用相当于这个集群节点的网关。因为其内部的节点相对于其他 tun 代理是不可见的，
通过配置tun的规则开启多个，则可以实现业务拆分。
2022-10-07 此模块被弃用，可以用多节点转接的方式或代理的方式做到，如 send(&amp;quot;n1.n2.n3@name&amp;quot;)
服务发现 sktpmd 提供了一套服务发现机制，但其运作原理是不同于 etcd 或者 consul,它本身是一个惰性发现，取决于第一次调用的地址是否正确返回。
你不需要知道它是如何运作的，你只需要知道在特定时间内它是有效的即可，那怕其中出了一些意外，无非只是浪费了两次通讯而已。
gossip sktpmd整个发现流程是基于 gossip 算法来发现的,但一些api依然可以主动触发
网络底层 参考 Go协程的思考,在linux下，使用了 epoll。所以尽量部署到 linux 下以发挥更好的性能</description>
    </item>
    
    <item>
      <title>timer</title>
      <link>http://localhost:1313/post/skynet/timer/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/skynet/timer/</guid>
      <description>简介 timer 模块是 skynet 内置的一个定时模块，使用了小根堆实现。
apis skynet.sleep(d) 这个函数将会挂起当前协程，在lua和 go中将会有不同的表现，取决于两者底层之间的区别
skynet.timeout(d,fn) 注册一个到期时间，而之后将会触发这个函数，特别注意，此函数的执行协程同当前调用的协程，简单来说就是并不会造成资源竞争，但是需要注意一下 aba 问题
QA 为什么不提供循环计时器？
可以使用闭包来实现循环
为什么不提供取消？
可以使用标记位来控制逻辑
为什么使用小根堆
为了尽可能减少精度丢失，以及内存，简单而言其实是一个topk算法的变种，不需要在一次循环中做完所有事(10ms)</description>
    </item>
    
    <item>
      <title>version change</title>
      <link>http://localhost:1313/post/skynet/version/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/skynet/version/</guid>
      <description>v1.1.1 Fixed 修复了http一个原子锁问题，但在高并发下可能会出现失败的情况 修复了 skynet.send(string,any) 会产生两次搜索的情况 Added skynet-lua 增加 skynet.trace() 用以输出当前堆栈 skynet-lua 增加 check_version() 函数，校验skynet版本 v1.1.2 Fixed 修复了kill函数重入导致越界的问题
修复http 因为判断发送失败的错误，现在如果发送失败返回404
Mod skynet.send(dst,...) 现在传入参数可以是大于2个，当等于2，与之前无区别，当大于2则会转为table skynet.send() 现在不返回 boolean，而是返回一个number,为0则认为成功 kill 函数现在会立即退出当前服务 killed 事件不会被传入了 v1.2.0 Mod 取消了事件投递到达服务，会给出一个字符串类型的消息发送这类型，用以区别数据的来源位置以及类型
与上述相关的问题，skynet.send(dest,...) 变为了 skynet.send(dest,typ,...) 现第二参数输入你自己的类型，以便于接收者区分，不要和服务同名，那是没有任何意义的 主要是为了确定一种数据的类型，而非一系列服务，本身服务和数据类型并非是一对一的关系
skynet.start -&amp;gt; skynet.uptime
v1.2.1 Mod 现在 skynet.warn,skynet.error,skynet.trace,skynet.debug 支持传入任意类型参数,优化栈分配 Fixed 修复了ucpd 缓冲未释放的问题 Add 增加 skynet.call skynet.reply 是一个组合调用。否则会造成协程被挂起 v1.2.2 Add 增加 bbuf 协议解析，通过 bbuf = require(&amp;quot;skynet.bbuf&amp;quot;) 引用 bbuf errno = bbuf.load(path) 解析文件描述 bytes(userdata),errno = bbuf.</description>
    </item>
    
    <item>
      <title>allocator</title>
      <link>http://localhost:1313/post/skynet/allocator/</link>
      <pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/skynet/allocator/</guid>
      <description>简介 alloctor 模块主要是为了减少GC而开发。现支持两套分配规则
基于 SLAB 算法的分段内存分配器 SLAB 最开始是阅读 linux 源码学习的算法，在skynet中它确实有更优秀的性能，因为它直接分配了一块共用内存，所以不会产生任何GC和真实分配, ，但在业务开发过程中，一旦忘记释放 那么这段内存将不能再被使用和获取了（也就是野指针），直到程序结束。
哪怕内置的Debug模式也无法定位到这个指针，原因在于 golang 堆栈伸缩会导致指针地址变动，所以 Debug 只能定位到存在 memory-leak，而无法知道具体位置。若需要具体位置则需要hook这个调用栈，性能方面得不偿失
slab-allocator 对业务开发很不友好，最终只是将它保留作为可选项，是否使用取决于业务实际需要，因为它违背了 skynet 的设计初衷。
如果需要使用可以在编译指令中指明slab
2020-10-18 阅读sync.Pool源码，看看能不能够和指定的P进行绑定，减少锁
基于 sync.Pool 的分段内存分配器 将不同size的buffer放入不同的池中，按需进行分配，减少race的开销
这个方法虽然简单，但是性能是低于 slab-allocator。
但它确实能减轻心智负担，代价就是牺牲了部分性能以及gc压力，但这也是skynet默认使用的策略。
API skynet.alloc(n) 用以分配指定大小的内存块
skynet.realloc(buf,n) realloc函数会先检查buf，确保是否需要重新分配内存
skynet.append(buf,data) 简化了 realloc 和 copy 的操作。
skynet.free(buf) 释放一段内存,对于slab 而言，它会检查buf的地址是否属于当前段</description>
    </item>
    
    <item>
      <title>pid</title>
      <link>http://localhost:1313/post/skynet/pid/</link>
      <pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/skynet/pid/</guid>
      <description>PID Pid 是当前服务的唯一id，它确保在当前节点以及集群中唯一。
但重新启动节点之后，它的值可能会发生改变，所以不要尝试保存它，但可以确定的是集群中它依然是唯一的
作用 表示某一节点的某一的服务的地址，它最终输出是一串 uint64 的值。
可以通过 skynet.send(dst,...) skynet.call(ti,dst,...)来使用它，将消息发送出去</description>
    </item>
    
  </channel>
</rss>
