<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sknt on Treasure</title>
    <link>https://domyson.github.io/categories/sknt/</link>
    <description>Recent content in sknt on Treasure</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 17 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://domyson.github.io/categories/sknt/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>conf</title>
      <link>https://domyson.github.io/post/sknt/conf/</link>
      <pubDate>Sat, 17 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/sknt/conf/</guid>
      <description>sknt配置相关项 在1.4.0版本之前，类似于skynet，是通过一个lua来作为配置文件启动的，但之后实现了一个高性能的ini解析器来作为配置加载器，好处是可以省略一个类似 launcher 的 LuaState。并且加载速度更快
example # 修改当前节点的 work directory root = ./example # go插件的搜索路径，特别注意的是它仅仅是将它作为一个服务启动，这本不同于lua plugin_path = ./ # 版本检查选项，若开启它则自动会检查版本是否匹配，版本是通过编译指令设置的。 #version = &amp;#34;1.3.1&amp;#34; # 以后台进程的方式启动 #daemon = &amp;#34;./skynet.pid&amp;#34; # 这个节点不是 sknt 标准选项，需要注意的是 lua模块是一个可编译选项，而不是 sknt自带的 [lua] path=./cop/?.lua; # other go written lua module plugin_path = ./lua_plugin # launch first scritp main = pool # 集群选项 # [sknmpd] # name = &amp;#34;node1&amp;#34; # can use follwing hosts value. &amp;#34;:port ip:port&amp;#34; # cookie= &amp;#34;hello world&amp;#34; # defualt the skynet version.</description>
    </item>
    
    <item>
      <title>第三方模块的封装</title>
      <link>https://domyson.github.io/post/sknt/third/</link>
      <pubDate>Mon, 26 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/sknt/third/</guid>
      <description>mysql redis monogo </description>
    </item>
    
    <item>
      <title>bbuf 编码协议</title>
      <link>https://domyson.github.io/post/sknt/bbuf/</link>
      <pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/sknt/bbuf/</guid>
      <description>前言 其实在cobweb之初就设计了一种编码协议(bbuf)，用于 RPC Server,但因为公司项目长期需要维护以及开发（两款线上，一款开发中），所以一直未对此库进行维护， 而后期在研发 sknt 的时候，发现需要与多种语言交互，显然 json,xml 不是一个很好的选择，而 protobuf 对弱类型语言支持不友好。
Benchmark cpu: Intel(R) Core(TM) i9-9900K CPU @ 3.60GHz os: windows11 arch: amd64 format compress rate encode rate decode rate json std 0% 0%( 213.8 ns/op) 0%(1204ns/op) proto v3 -40% -51%(98.36 ns/op) -84%(190.1ns/op) bbuf -40% -76% (65.21 ns/op) -95%(62.18ns/op) 词法解析器 因为需要和强类型和弱类型进行转换，词法解析器和描述文件需要一个抽象共用类型加以识别，所以对于强类型语言是通过生成描述文件识别的。
Lua5.1 是没有整数类型，需要区分浮点和整形的区别，这涉及到最终编码的尺寸，bbuf对它们进行了区分
Lua table 纯数组table和hash table 的编码方式也是不同的，这依赖于 table 在底层的结构，若非必要不要混合。
代码生成器 强类型和弱类型的识别是有很大区别，所以我对Lua 这边进行了直接解析，简单来说是直接通过 Lexer 生成此消息结构的元信息.
强类型语言为了减少反射，我们需要通过文件描述来提供其成员或字段的类型以及位置而非通过反射，这个在编译期间就可以确定了而非运行时。
此模块在当前进程中的所有服务是生效的
设计思路 减少内存分配
为了减少i/o和内存压力，最简单的办法是让一个字节能包含更多的消息， 如一个32bit的整形，它真的需要4byte的字节空间吗？,其二不同的分配大小影响执行速度，（如32byte和64kb 是存在明显区别）， 所以需要动态计算分配尺寸。</description>
    </item>
    
    <item>
      <title>sknt message</title>
      <link>https://domyson.github.io/post/sknt/message/</link>
      <pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/sknt/message/</guid>
      <description>简介 sknt是基于消息的服务框架，它承担了其中消息的传递。
服务的消息队列 存在两个版本，一个是基于go channel，另外一个基于无锁缓冲队列，后续有时间会单独解释。
唯一的区别是 第二种方式需要手动控制调度调度规则，对服务参数的配置有更高的要求，正确的配置,内存以及性能会比 go channel的方式略高
TODO: 吞吐量对比
消息的接受和发送 发送 用户不需要构建这个结构体，仅仅需要指定 destination 以及需要发送的数据，而且 sknt 消息投递被设计成不允许发送 nil 因为这是无任何意义的，相反它消耗服务投递的性能， 如果确实有这种需求，可以发送 struct{}{}
接收 关键性参数只有三个，session,typ,以及 argument,
session 主要的作用是用以区分这条消息是否大于0，若为真，则其值就是请求序列号，本节点保证唯一 typ 仅仅是一个消息类别的区分，类似于消息号，用户可自行定义 argument 才是真实的数据，它可以是任意值，特别的，在lua中这个值是会被解构，在跨节点通讯这个值恒为 []byte，当不需要时记得 sknt.free 1.4.0 这个由runtime回收 异步消息 异步消息通过 sknt.send的方式进行投递，它只在乎这个消息有没有正确到达到对点服务，而不关心是否能被对点服务正确处理，返回一个 error
同步消息 同步消息通过 sknt.call的方式进行投递，它会阻塞当前协程（goroutine 或者是 coroutine），它也返回一个错误，能解除此次阻塞只有两个条件，对点服务sknt.ret 或者达到了指定超时时间， 所以特别在远程通讯的时候要考虑到 i/o 的延时
dead letter 这个很好理解，同erlang 主要是确保数据的一致性，保证重要的数据不会因为某个服务的意外退出而丢失了这些消息.</description>
    </item>
    
    <item>
      <title>sknt设计初衷以及特性</title>
      <link>https://domyson.github.io/post/sknt/sknt/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/sknt/sknt/</guid>
      <description>简介 sknt 是一个基于消息和服务的分布式服务框架，采用go编写，致力于简化开发难度和成本， 它是一个年轻的框架，仅仅经历了两款项目
羽翼军团 我在民国淘古玩 设计概述 工作中开发一个分布式多人在线游戏的时候构建了一个cobweb的分布式通讯框架（基于golang,c）。
但是在实际开发过程中代码难以维护以及更新，主要是每次都需要跨平台进行编译，特别是cgo 往往需要指定平台的系统库。
而且一些不规范的使用方式造成无法充分发挥多核的优势，可以参见 关于Go协程的思考 虽然1.16 支持抢占式，但错误的使用方式依然造成了cpu过高的问题。
再者，服务器过多的 goroutine 被创建，极大浪费了内存以及cpu。
基于以上目的，重写了cobweb 的底层，底层对用户不再透明。 所以 被设计了出来。
sknt参考了云风大神的 skynet 以及 erlang的思想。
尽管如此，一些高性能模块还是由 cobweb 承载的，因为lua本身语言的设计还是会有些先天性缺陷。
特性 支持 cgo 沿用自 cobweb 支持 plugins，为了方便从外部直接加载以满足热更新需求 unix only 支持纯go,当然这是一句废话 支持 lua 原因在于 lua 是一门简单并且性能很高的脚本语言，能显著降低开发成本 mysql支持，dns支持 提供tcp udp,unix支持 不特别区分远程或者本地调用 sknt.send,sknt.call 抹平了本地和集群的区别 参见 sknmpd 实现的http框架，区别于 net/http,仅仅实现部分 RFC 标准,兼容此框架 消息发送默认都是指针，如有需要，可通过一些api来序列化，并使用 sknt.free 方法来释放它。 sknmpd 在sknt中每个节点都是平等的，不存在谁依赖于谁，这也是cobweb的设计初衷。所以sknt 不支持 master/slave 模式，但可以通过业务代码来实现，而非框架本身。
架构 sknt 是函数式以及低抽象的架构
纯函数式主要是受 c language 的影响。也更贴合职责单一的原则</description>
    </item>
    
    <item>
      <title>sknmpd</title>
      <link>https://domyson.github.io/post/sknt/sknmpd/</link>
      <pubDate>Mon, 30 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/sknt/sknmpd/</guid>
      <description>简介 sknmpd模块是sknt底层集群模块，它承担了sknt网络节点之间的通讯职能。全名为(simple keenly net managment port daemon)
架构 sknmpd 为了满足对等网络的性质，所以每次和其他节点建立连接是有两条连接， 当A节点于B节点建立连接，首先A节点发送握手等待B确认，B确认完成之后重复走A的流程，这样一个双向连接就被建立了起来
sknmpd可以支持任意网络协议，如 tcp,udp 甚至是 unix
当然一个好记的节点名称是非常有必要的，所以sknmpd也内置了一套非标准的本地 dns系统
使用 sknmpd的启动也非常简单，无须任何代码，仅仅只需要在 sknt.toml 中配置一下即可，使用的时候跟节点内通讯无任何区别，但要求参数必须是 []byte 类型，参考 bbuf 如
sknt.send(&amp;#34;host:port@name&amp;#34;,...) -- 通过域名或者地址+端口的形式和其他节点进行通讯 sknt.send(pid,...) -- 通过pid亦可 tunnel 既然节点之间是双向连接，所以连接数量为 f(n) = n²-n，如果节点过的时候，势必造成 socket fd 消耗殆尽，
基于这个问题，可以通过内置的tun，来设置代理，这么一来，tun的作用相当于这个集群节点的网关。因为其内部的节点相对于其他 tun 代理是不可见的，
通过配置tun的规则开启多个，则可以实现业务拆分。
2022-10-07 此模块被弃用，可以用多节点转接的方式或代理的方式做到，如 send(&amp;quot;n1.n2.n3@name&amp;quot;)
服务发现 sknmpd 提供了一套服务发现机制，但其运作原理是不同于 etcd 或者 consul,它本身是一个惰性发现，取决于第一次调用的地址是否正确返回。
你不需要知道它是如何运作的，你只需要知道在特定时间内它是有效的即可，那怕其中出了一些意外，无非只是浪费了两次通讯而已。
gossip sknmpd整个发现流程是基于 gossip 算法来发现的,但一些api依然可以主动触发
网络底层 参考 Go协程的思考,在linux下，使用了 epoll。所以尽量部署到 linux 下以发挥更好的性能</description>
    </item>
    
    <item>
      <title>timer</title>
      <link>https://domyson.github.io/post/sknt/timer/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/sknt/timer/</guid>
      <description>简介 timer 模块是 sknt 内置的一个定时模块，使用了小根堆实现。
apis sknt.sleep(d) 这个函数将会挂起当前协程，在lua和 go中将会有不同的表现，取决于两者底层之间的区别
sknt.timeout(d,fn) 注册一个到期时间，而之后将会触发这个函数，特别注意，此函数的执行协程同当前调用的协程，简单来说就是并不会造成资源竞争，但是需要注意一下 aba 问题
QA 为什么不提供循环计时器？
可以使用闭包来实现循环
为什么不提供取消？
可以使用标记位来控制逻辑
为什么使用小根堆
为了尽可能减少精度丢失，以及内存，简单而言其实是一个topk算法的变种，不需要在一次循环中做完所有事(10ms)</description>
    </item>
    
    <item>
      <title>version change</title>
      <link>https://domyson.github.io/post/sknt/version/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/sknt/version/</guid>
      <description>v1.1.1 Fixed 修复了http一个原子锁问题，但在高并发下可能会出现失败的情况 修复了 sknt.send(string,any) 会产生两次搜索的情况 Added sknt-lua 增加 sknt.trace() 用以输出当前堆栈 sknt-lua 增加 check_version() 函数，校验sknt版本 v1.1.2 Fixed 修复了kill函数重入导致越界的问题
修复http 因为判断发送失败的错误，现在如果发送失败返回404
Mod sknt.send(dst,...) 现在传入参数可以是大于2个，当等于2，与之前无区别，当大于2则会转为table sknt.send() 现在不返回 boolean，而是返回一个number,为0则认为成功 kill 函数现在会立即退出当前服务 killed 事件不会被传入了 v1.2.0 Mod 取消了事件投递到达服务，会给出一个字符串类型的消息发送这类型，用以区别数据的来源位置以及类型
与上述相关的问题，sknt.send(dest,...) 变为了 sknt.send(dest,typ,...) 现第二参数输入你自己的类型，以便于接收者区分，不要和服务同名，那是没有任何意义的 主要是为了确定一种数据的类型，而非一系列服务，本身服务和数据类型并非是一对一的关系
sknt.start -&amp;gt; sknt.uptime
v1.2.1 Mod 现在 sknt.warn,sknt.error,sknt.trace,sknt.debug 支持传入任意类型参数,优化栈分配 Fixed 修复了ucpd 缓冲未释放的问题 Add 增加 sknt.call sknt.reply 是一个组合调用。否则会造成协程被挂起 v1.2.2 Add 增加 bbuf 协议解析，通过 bbuf = require(&amp;quot;sknt.bbuf&amp;quot;) 引用 bbuf errno = bbuf.load(path) 解析文件描述 bytes(userdata),errno = bbuf.</description>
    </item>
    
    <item>
      <title>allocator</title>
      <link>https://domyson.github.io/post/sknt/allocator/</link>
      <pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/sknt/allocator/</guid>
      <description>简介 alloctor 模块主要是为了减少GC而开发。现支持两套分配规则
基于 SLAB 算法的分段内存分配器 SLAB 最开始是阅读 linux 源码学习的算法，在sknt中它确实有更优秀的性能，因为它直接分配了一块共用内存，所以不会产生任何GC和真实分配, ，但在业务开发过程中，一旦忘记释放 那么这段内存将不能再被使用和获取了（也就是野指针），直到程序结束。
哪怕内置的Debug模式也无法定位到这个指针，原因在于 golang 堆栈伸缩会导致指针地址变动，所以 Debug 只能定位到存在 memory-leak，而无法知道具体位置。若需要具体位置则需要hook这个调用栈，性能方面得不偿失
slab-allocator 对业务开发很不友好，最终只是将它保留作为可选项，是否使用取决于业务实际需要，因为它违背了 sknt 的设计初衷。
如果需要使用可以在编译指令中指明slab
2020-10-18 阅读sync.Pool源码，看看能不能够和指定的P进行绑定，减少锁
基于 sync.Pool 的分段内存分配器 将不同size的buffer放入不同的池中，按需进行分配，减少race的开销
这个方法虽然简单，但是性能是低于 slab-allocator。
但它确实能减轻心智负担，代价就是牺牲了部分性能以及gc压力，但这也是sknt默认使用的策略。
API sknt.alloc(n) 用以分配指定大小的内存块
sknt.realloc(buf,n) realloc函数会先检查buf，确保是否需要重新分配内存
sknt.append(buf,data) 简化了 realloc 和 copy 的操作。
sknt.free(buf) 释放一段内存，为了兼容slab，要求释放的是 buf(0)这个位置</description>
    </item>
    
    <item>
      <title>pid</title>
      <link>https://domyson.github.io/post/sknt/pid/</link>
      <pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/sknt/pid/</guid>
      <description>PID Pid 是当前服务的唯一id，它确保在当前节点以及集群中唯一。
但重新启动节点之后，它的值可能会发生改变，所以不要尝试保存它，但可以确定的是集群中它依然是唯一的
作用 表示某一节点的某一的服务的地址，它最终输出是一串 uint64 的值。
可以通过 sknt.send(dst,...) sknt.call(ti,dst,...)来使用它，将消息发送出去</description>
    </item>
    
  </channel>
</rss>
