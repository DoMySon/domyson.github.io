<!doctype html>
<html lang="en">
  <head>
    <title>Go协程的思考 // Treasure</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.119.0">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Treasure" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.3c3c186cd62e563ad6e2f00a89dbee656ab912d1d46f856b5605dd0232521e2a.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go协程的思考"/>
<meta name="twitter:description" content="栈

一个 os 线程会有一个给固定大小的内存块（一般是 2MB），用来存储当前线程中调用或挂起函数的内部变量，固定大小的栈对于复杂和深层次递归是不够的，而 Goroutine 会以一个很小的栈（2KB）开始其生命周期，这个栈会动态伸缩，最大能到达 1GB（32位系统是 250M）

调度方式

os 线程由操作系统内核调用，每过一定时间（毫秒），硬件计时器会中断处理器，并调用一个名为 scheduler 的内建函数，这个函数会挂起当前执行的线程并保存内存中它的寄存器内存，然后检查线程列表并决定下一次执行哪个线程，并从内存中恢复该线程的寄存器信息，恢复该线程的线程并执行，这就是上下文切换，增加了 CPU 的运行周期。而 Go 的 runtime 包含了自身的调度器，和 os 线程不同是，Goroutine 属于用户级线程由语言支持，调度由语言支持，所有开销会减少很多（相比于内核上下文切换）。
"/>

    <meta property="og:title" content="Go协程的思考" />
<meta property="og:description" content="栈

一个 os 线程会有一个给固定大小的内存块（一般是 2MB），用来存储当前线程中调用或挂起函数的内部变量，固定大小的栈对于复杂和深层次递归是不够的，而 Goroutine 会以一个很小的栈（2KB）开始其生命周期，这个栈会动态伸缩，最大能到达 1GB（32位系统是 250M）

调度方式

os 线程由操作系统内核调用，每过一定时间（毫秒），硬件计时器会中断处理器，并调用一个名为 scheduler 的内建函数，这个函数会挂起当前执行的线程并保存内存中它的寄存器内存，然后检查线程列表并决定下一次执行哪个线程，并从内存中恢复该线程的寄存器信息，恢复该线程的线程并执行，这就是上下文切换，增加了 CPU 的运行周期。而 Go 的 runtime 包含了自身的调度器，和 os 线程不同是，Goroutine 属于用户级线程由语言支持，调度由语言支持，所有开销会减少很多（相比于内核上下文切换）。
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://domyson.github.io/post/language/go/goroutine/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-05-12T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-05-12T00:00:00+00:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://domyson.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="Treasure" /></a>
      <span class="app-header-title">Treasure</span>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/">Home</a>
             - 
          
          <a class="app-header-menu-item" href="/tags/">Tags</a>
             - 
          
          <a class="app-header-menu-item" href="/about/">About</a>
      </nav>
      <p>无关迟暮,不问翻覆</p>
      <div class="app-header-social">
        
          <a href="https://github.com/domyson" target="_blank" rel="noreferrer noopener me">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>Github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg>
          </a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Go协程的思考</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          May 12, 2019
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          2 min read
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://domyson.github.io/tags/goroutine/">goroutine</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h1 id="栈">栈</h1>
<blockquote>
<p>一个 os 线程会有一个给固定大小的内存块（一般是 2MB），用来存储当前线程中调用或挂起函数的内部变量，固定大小的栈对于复杂和深层次递归是不够的，而 Goroutine 会以一个很小的栈（2KB）开始其生命周期，这个栈会动态伸缩，最大能到达 1GB（32位系统是 250M）</p>
</blockquote>
<h1 id="调度方式">调度方式</h1>
<blockquote>
<p>os 线程由操作系统内核调用，每过一定时间（毫秒），硬件计时器会中断处理器，并调用一个名为 scheduler 的内建函数，这个函数会挂起当前执行的线程并保存内存中它的寄存器内存，然后检查线程列表并决定下一次执行哪个线程，并从内存中恢复该线程的寄存器信息，恢复该线程的线程并执行，这就是上下文切换，增加了 CPU 的运行周期。而 Go 的 runtime 包含了自身的调度器，和 os 线程不同是，<code>Goroutine</code> 属于用户级线程由语言支持，调度由语言支持，所有开销会减少很多（相比于内核上下文切换）。</p>
</blockquote>
<h1 id="go的调度器scheduler">Go的调度器（Scheduler）</h1>
<ul>
<li>
<p>g 代表一个 goroutine，它包含：表示 goroutine 栈的一些字段，指示当前 goroutine 的状态，指示当前运行到的指令地址，也就是 PC 值。</p>
</li>
<li>
<p>m 表示内核线程，包含正在运行的 goroutine 等字段。</p>
</li>
<li>
<p>p 代表一个虚拟的 Processor，它维护一个处于 Runnable 状态的 g 队列，m 需要获得 p 才能运行 g。</p>
</li>
<li>
<p>还有一个核心的结构体：sched，它总览全局。</p>
</li>
</ul>
<blockquote>
<p>Runtime 起始时会启动一些 G：垃圾回收的 G，执行调度的 G，运行用户代码的 G；并且会创建一个 M 用来开始 G 的运行。随着时间的推移，更多的 G 会被创建出来，更多的 M 也会被创建出来。</p>
</blockquote>
<ol>
<li>
<p>它是运行在用户态的，</p>
</li>
<li>
<p>它维护有存储M和G的队列以及调度器的一些状态信息等，并让每个 <code>Goroutine</code> 有机会运行</p>
</li>
<li>
<p><code>M</code> 每次取 <code>P</code> 中的队列是没有上下文切换开销的</p>
</li>
</ol>
<ul>
<li>
<p>M ：代表 os（内核）线程</p>
<p>OS线程抽象，代表着真正执行计算的资源，在绑定有效的P后，进入schedule循环；而schedule循环的机制大致是从Global队列、P的Local队列以及wait队列中获取G，切换到G的执行栈上并执行G的函数，调用goexit做清理工作并回到M，如此反复。M并不保留G状态，这是G可以跨M调度的基础，M的数量是不定的，由Go Runtime调整，为了防止创建过多OS线程导致系统调度不过来，目前默认最大限制为10000个。</p>
</li>
<li>
<p>P ：代表逻辑处理器</p>
<p><code>Processor</code>，表示逻辑处理器， 对G来说，P相当于CPU核（伪核，真正的执行体还是M所关联的内核线程），G只有绑定到P(在P的local runq中)才能被调度。对M来说，P提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等，P的数量决定了系统内最大可并行的G的数量（前提：物理CPU核数 &gt;= P的数量），P的数量由用户设置的GOMAXPROCS决定，但是不论GOMAXPROCS设置为多大，P的数量最大为256。</p>
<ol>
<li><code>P</code> 维护了一个 <code>local goroutines</code> 队列</li>
</ol>
</li>
</ul>
<h1 id="何时触发调度">何时触发调度</h1>
<blockquote>
<p>由于 Go 语言是协作式的调度，不会像线程那样，在时间片用完后，由 CPU 中断任务强行将其调度走。对于 Go 语言中运行时间过长的 goroutine，Go scheduler 有一个后台线程在持续监控，一旦发现 goroutine 运行超过 10 ms，会设置 goroutine 的 “抢占标志位”，之后调度器会处理。</p>
</blockquote>
<ol>
<li>syscall</li>
<li>select-channel</li>
<li>I/O（包括网络和文件）</li>
<li>Gosched()函数调用</li>
<li>go func(){&hellip;}()</li>
<li>GC时</li>
<li>同步互斥操作时</li>
</ol>
<h1 id="goroutine">Goroutine</h1>
<blockquote>
<p>Goroutine 可以看作对 thread 加的一层抽象，它更轻量级，可以单独执行。因为有了这层抽象，Gopher 不会直接面对 thread</p>
</blockquote>
<ol>
<li>
<p>创建一个 goroutine 的栈内存消耗为 2 KB，在运行过程中，如果栈空间不够用，会自动进行扩容</p>
</li>
<li>
<p><code>G</code> 分为三种状态</p>
<ol>
<li>
<p><code>Waiting</code>：表示被暂停了，需要等待一些事件发生才能继续，可能是因为 <code>syscall</code>,<code>channel</code> 或者互斥调用。</p>
</li>
<li>
<p><code>Runnable</code>：就绪状态，只要给 <code>M</code> 就可以运行</p>
</li>
<li>
<p><code>Running</code>：运行状态。goroutine 在 M 上执行指令</p>
</li>
</ol>
</li>
<li>
<p>每个Goroutine对应一个G结构体，G存储Goroutine的运行堆栈、状态以及任务函数，可重用。G并非执行体，每个G需要绑定到P才能被调度执行。</p>
</li>
<li>
<p>在同一时刻，一个线程上只能跑一个 goroutine。当 goroutine 发生阻塞（例如上篇文章提到的向一个 channel 发送数据，被阻塞）时，runtime 会把当前 goroutine 调度走，让其他 goroutine 有执行的机会</p>
</li>
</ol>
<h2 id="异常捕获">异常捕获</h2>
<blockquote>
<p>当启动多个 <code>goroutine</code> 时，如果其中一个 <code>goroutine</code> 异常了，并且我们并没有对进行异常处理，那么整个程序都会终止，所以最好每个 <code>goroutine</code> 所运行的函数都做异常处理，异常处理采用 <code>recover</code></p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> recover();<span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//TODO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Code...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    panic(<span style="color:#e6db74">&#34;exit&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="注意">注意</h3>
<ol>
<li>
<p>recover 只能在 defer 的匿名函数中调用</p>
</li>
<li>
<p>recover 能捕获panic传入的错误，来保证 goroutine 是否继续执行还是正常退出</p>
</li>
</ol>
<h2 id="如何同步">如何同步</h2>
<blockquote>
<p>某些情况是主线程退出，但一部分 <code>goroutine</code> 还未执行完毕</p>
</blockquote>
<ul>
<li>
<p>通过 <code>sync.WaitGroup</code> 来保证所有 <code>goroutine</code> 执行完成</p>
</li>
<li>
<p>通过 <code>channnel</code> 来保证所有 <code>goroutine</code> 执行完成</p>
</li>
</ul>
<h1 id="gc">GC</h1>
<p>因为 GC 操作是使用自己的一组 <code>Goroutine</code> 来执行的，这些 <code>Goroutine</code> 需要一个 <code>M</code> 来运行。所以 GC 会导致调度混乱。</p>
<p>但是，因为调度器是知道 <code>Goroutine</code> 要做什么的，所以它可以做出明智的决策。其中一个明智的决策是，在 GC 过程中，暂停那些需要访问堆空间的 <code>Goroutine</code>（<code>Stop The World</code>），运行那些不需要访问堆空间的。</p>
<h1 id="思考">思考</h1>
<p>大部分<code>goroutine</code>使用都是在网络层，这部分<code>goroutine</code> 我称为 <code>i/o 协程</code>,但对于高并发而言，<code>gorotuine</code> 也会导致内存过高，</p>
<p>而关于<code>goroutine</code>的调度问题，除了上述所说，网络底层是通过 <code>i/o multiplex </code>事件来触发调度的,虽然 1.16 之后支持了抢占式调度，但错误的使用并不会提高性能，反而会降低.</p>
<p>我们通过一组数据来证明它</p>
<h2 id="1-thread-epoll">1 thread epoll</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>    Test Duration 10.1192694s:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    1000 connections,fail: 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Delay:    Avg        Max        Stdev
</span></span><span style="display:flex;"><span>        23.074671ms 226.0378ms  23.074671ms
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Request/Sec: 17.60K/s
</span></span><span style="display:flex;"><span>    Written/Sec: 17.18M/s
</span></span><span style="display:flex;"><span>    Receive/Sec: 17.18M/s
</span></span><span style="display:flex;"><span>    TotalWritten: 173.89M
</span></span><span style="display:flex;"><span>    TotalReceive: 173.89M
</span></span></code></pre></div><h2 id="4-thread-epoll">4 thread epoll</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>    Test Duration 10.1532731s:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    1000 connections,fail: 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Delay:    Avg        Max        Stdev
</span></span><span style="display:flex;"><span>        14.70811ms 295.5518ms 14.30601ms
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Request/Sec: 17.16K/s
</span></span><span style="display:flex;"><span>    Written/Sec: 16.76M/s
</span></span><span style="display:flex;"><span>    Receive/Sec: 16.76M/s
</span></span><span style="display:flex;"><span>    TotalWritten: 170.12M
</span></span><span style="display:flex;"><span>    TotalReceive: 170.12M
</span></span></code></pre></div><h2 id="standard-go">standard go</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>    Test Duration 10.1377697s:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    1000 connections,fail: 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Delay:    Avg        Max        Stdev
</span></span><span style="display:flex;"><span>        14.855782ms 276.5472ms14.855782ms
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Request/Sec: 17.22K/s
</span></span><span style="display:flex;"><span>    Written/Sec: 16.82M/s
</span></span><span style="display:flex;"><span>    Receive/Sec: 16.82M/s
</span></span><span style="display:flex;"><span>    TotalWritten: 170.48M
</span></span><span style="display:flex;"><span>    TotalReceive: 170.48M
</span></span></code></pre></div><p>从吞吐量可以看出，单 <code>epoll</code> 略高于其他方式，但综合数据同步以及内存使用来看，显然单线程 <code>epoll</code> 更适合</p>
<h1 id="总结">总结</h1>
<p><code>goroutine</code> 虽然减少了心智负担，但它牺牲了一些性能，所以我个人认为，<code>goroutine</code>更适合成为一个库，而非语言标准。</p>
    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
