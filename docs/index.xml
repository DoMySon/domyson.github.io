<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>满船清梦压星河</title>
    <link>https://domyson.github.io/</link>
    <description>Recent content on 满船清梦压星河</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 17 Oct 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://domyson.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>makefile</title>
      <link>https://domyson.github.io/post/makefile/</link>
      <pubDate>Tue, 17 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/makefile/</guid>
      <description> makefile 很早就想写了，高阶概念总是忘了又忘，一千个人一千个哈姆雷特，理解抽象概念的方式各有不同
What&amp;rsquo;s makefile? </description>
    </item>
    
    <item>
      <title>lex</title>
      <link>https://domyson.github.io/post/scriptc/2/</link>
      <pubDate>Wed, 04 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/scriptc/2/</guid>
      <description>词法分析器 </description>
    </item>
    
    <item>
      <title>scriptc</title>
      <link>https://domyson.github.io/post/scriptc/1/</link>
      <pubDate>Wed, 04 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/scriptc/1/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;早在2019之前就想开发一门脚本语言，一是加深编译原理的理解，二是觉得程序员不应该消耗在语言特性上，也一直想为自己的服务端框架 skt 写一门dsl，之前是用lua作为服务端的脚本端&lt;/p&gt;
&lt;p&gt;看过很多源码，&lt;code&gt;python,lua&lt;/code&gt; 等,一直纠结于 stack based or register based。&lt;/p&gt;
&lt;p&gt;名字没想好那就叫 &lt;code&gt;scriptc&lt;/code&gt;, 语法是简化版的 &lt;code&gt;c&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这篇文章将会是一个系列，更新会比源码慢，文档写的也不会完全&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>datatable</title>
      <link>https://domyson.github.io/post/datatable/</link>
      <pubDate>Sun, 17 Sep 2023 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/datatable/</guid>
      <description>前言 datatable 使一个转换并加载excel数据表的库，它基于 kproto</description>
    </item>
    
    <item>
      <title>anywhere 客户端框架概述</title>
      <link>https://domyson.github.io/post/anywhere/1/</link>
      <pubDate>Sat, 01 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/anywhere/1/</guid>
      <description>概述 Anywhere 是一个基于 Unity 引擎的框架，它设计理论源自于 ECS 当然还没有 Natvie Code 也没有 Brust 编译器。</description>
    </item>
    
    <item>
      <title>conf</title>
      <link>https://domyson.github.io/post/skynet/conf/</link>
      <pubDate>Sat, 17 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/skynet/conf/</guid>
      <description>skynet config 在1.4.0版本之前，类似于skynet，是通过一个lua来作为配置文件启动的，但之后实现了一个高性能的ini解析器来作为配置加载器，好处是可以省略一个类似 launcher 的 LuaState。并且加载速度更快
example # 修改当前节点的 work directory root = ./example # go插件的搜索路径，特别注意的是它仅仅是将它作为一个服务启动，这本不同于lua plugin_path = ./ # 版本检查选项，若开启它则自动会检查版本是否匹配，版本是通过编译指令设置的。 #version = &amp;#34;1.3.1&amp;#34; # 以后台进程的方式启动 #daemon = &amp;#34;./skynet.pid&amp;#34; # 这个节点不是 sknt 标准选项，需要注意的是 lua模块是一个可编译选项，而不是 sknt自带的 [lua] path=./cop/?.lua; # other go written lua module plugin_path = ./lua_plugin # launch first scritp main = pool # 集群选项 # [sknmpd] # name = &amp;#34;node1&amp;#34; # can use follwing hosts value. &amp;#34;:port ip:port&amp;#34; # cookie= &amp;#34;hello world&amp;#34; # defualt the skynet version.</description>
    </item>
    
    <item>
      <title>redis</title>
      <link>https://domyson.github.io/post/db/redis/redis/</link>
      <pubDate>Thu, 24 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/db/redis/redis/</guid>
      <description>Redis Remote Dictionary Server,采用 ANSI C 编写的 K-V数据库
Redis命令
Redis下载
类型 string 最大存储值为256mb，底层由SDS(simple dynamic string)实现，优势是访问长度仅需O(1)
hash
list 存储有序字符串，最大2^32-1个元素
set
同list，但不允许重复
sorted set 已排序的都字符串集合，但不允许重复 &amp;ndash; 其它
GEO 地理位置 HyperLogLog 基数统计 Bitsmap bit数组，类似boolean filter redis设计架构 单线程业务，多线程存储，redis6.0引入多线程也仅仅是为了提高解析命令的速度
虚拟内存
虚拟内存机制就是暂时把不经常访问的数据(冷数据)从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据(热数据)。通过VM功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘。这样就可以避免因为内存不足而造成访问速度下降的问题。
击穿，穿透，雪崩 击穿 某个key在过期点的时候，突然出现大量请求查找这个key
穿透 访问一个不存在的key的时候
雪崩 指缓存中数据大批量到过期时间，访问落到db上，造成db压力过大
持久化机制 RDB RDB持久化，是指在指定的时间间隔内，执行指定次数的写操作，将内存中的数据集快照写入磁盘中，它是Redis默认的持久化方式。执行完操作后，在指定目录下会生成一个dump.rdb文件，Redis 重启的时候，通过加载dump.rdb文件来恢复数据
分为手动触发和自动触发
优点 适合大规模的数据恢复场景，如备份，全量复制等
缺点 没办法做到实时持久化/秒级持久化。
AOF 采用日志的形式来记录每个写操作，追加到文件中，重启时再重新执行AOF文件中的命令来恢复数据。它主要解决数据持久化的实时性问题
优点 数据一致性和完整性更高 缺点 内容越多，文件越大，恢复变慢，它需要将所有命令执行一遍
高可用 主从 类似mysql主从，master负责写，slave负责读
哨兵 监视其他节点的状态
集群 Gossip，HashSlot 16384
View
分布式锁 setnx setnx nx [expired]</description>
    </item>
    
    <item>
      <title>mvcc</title>
      <link>https://domyson.github.io/post/db/mysql/mvcc/</link>
      <pubDate>Sun, 20 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/db/mysql/mvcc/</guid>
      <description>MVCC multi-version concurent control 多版本控制系统，一般用于数据库的并发访问
MVCC在MySQL InnoDB中的实现主要是为了提高数据库的并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。
mysql 的 RR级别是通过MVCC多版本并发控制的实现的，它通过管理数据行的多个版本来实现数据库并发控制，通过比较版本号来决定数据是否显示
mvcc在很多情况下避免加锁，大多数都实现了非阻塞读操作，写操作也是锁定必要行，innodb在每行记录后面保存两个隐藏列，分别是创建版本号和删除版本号,每开始一个新的事务系统版本号都会递增，事务开始的时刻的系统版本号 会作为事务的版本号，用以和查询到的每行记录的版本号进行比较，在RR级别下的工作方式：
select 需要同时满足查版本号早于当前版本的数据行，行的删除版本要么未定义，要么大于当前数据版本号
insert 为插入的每一行记录保存当前系统版本作为创建版本号
delete
update
当前读 像 select lock in share mode,select for update ,update,insert,delete 都算当前读，即读取的记录都是数据库中最新的版本，读取是还要保证其他并发事务不能修改当前记录，所以会对读数据加锁
快照读 不加锁的select就是快照读，但前提是隔离基本不是串行级别，否则会退化成当前读
原理 通过隐藏列</description>
    </item>
    
    <item>
      <title>iptables and ipvs</title>
      <link>https://domyson.github.io/post/linux/iptables/</link>
      <pubDate>Sat, 19 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/linux/iptables/</guid>
      <description>iptables iptables 基于 netfilter 采用一条条规则链表，时间复杂度为O(n)，最主要的是 iptables 专为防火墙设计
ipvs ipvs 同样基于 netfilter，但底层采用的是hash表，索引复杂度为O(1)</description>
    </item>
    
    <item>
      <title>Go Memory</title>
      <link>https://domyson.github.io/post/language/go/memory/</link>
      <pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/language/go/memory/</guid>
      <description>虚拟内存 虚拟内存屏蔽了RAM和Disk,向进程提供远大于物理内存的内存空间，简单来说就是使用了 memory map 分别映射了RAM和Disk的某个区域
堆栈 栈的方向向低地址增长，而堆恰好相反
Vritual memory address | kernel | |-------------------| 0xC00000000 | ---argv,evniron---| | -------stack -----| | ---------↓--------| | ----stack top-----| | | | unallocated | | | heap | | | uninitialized data| | initialized data | | program Code | | | 0x08048000 | | 0x00000000 Tcmalloc 也许同时google出品吧
Page
操作系统对内存管理以页为单位，Tcmalloc 也是如此，但其不一定相等，而是倍数关系(x64 Page 为8kb)
Span
一组连续的Page称为Span,是Tcmalloc的基本单位
ThreadCache
每个线程自身的Cache,包含多个空闲内存块链表，每个单独的链表大小是一致的，方便申请时不需要遍历全局，而且是无锁访问
CentarlCache
所有线程共享的空闲内存块，链表数量同 ThreadCache,当ThreadCache不够时会从其申请，但它是需要加锁
PageHeap
对堆内存的抽象，也是由若干链表组成，链表保存的是 Span，当 CentarlCache不足时，获取空闲Span然后拆分成若干内存块，并添加到对应大小的链表中以供分配，否则将会放回</description>
    </item>
    
    <item>
      <title>kproto 编码协议</title>
      <link>https://domyson.github.io/post/kproto/</link>
      <pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/kproto/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;其实在&lt;code&gt;cobweb&lt;/code&gt;之初就设计了一种编码协议(kproto)，用于内部消息的编码,但因为公司项目长期需要维护以及开发（两款线上，一款开发中），所以一直未对此库进行维护，
而后期在研发的时候，发现需要与多种语言交互，显然 &lt;code&gt;json&lt;/code&gt;,&lt;code&gt;xml&lt;/code&gt; 不是一个很好的选择，而 &lt;code&gt;protobuf&lt;/code&gt; 对弱类型语言支持不友好。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>message</title>
      <link>https://domyson.github.io/post/skynet/message/</link>
      <pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/skynet/message/</guid>
      <description>简介 skynet是基于消息的服务框架，它承担了其中消息的传递。
服务的消息队列 存在两个版本，一个是基于go channel，另外一个基于无锁缓冲队列，后续有时间会单独解释。
唯一的区别是 第二种方式需要手动控制调度调度规则，对服务参数的配置有更高的要求，正确的配置,内存以及性能会比 go channel的方式略高
TODO: 吞吐量对比
消息的接受和发送 发送 用户不需要构建这个结构体，仅仅需要指定 destination 以及需要发送的数据，而且 skynet 消息投递被设计成不允许发送 nil 因为这是无任何意义的，相反它消耗服务投递的性能， 如果确实有这种需求，可以发送 struct{}{}
接收 关键性参数只有三个，session,typ,以及 argument,
session 主要的作用是用以区分这条消息是否大于0，若为真，则其值就是请求序列号，本节点保证唯一 typ 仅仅是一个消息类别的区分，类似于消息号，用户可自行定义 argument 才是真实的数据，它可以是任意值，特别的，在lua中这个值是会被解构，在跨节点通讯这个值恒为 []byte，当不需要时记得 skynet.free 1.4.0 这个由runtime回收 异步消息 异步消息通过 skynet.send的方式进行投递，它只在乎这个消息有没有正确到达到对点服务，而不关心是否能被对点服务正确处理，返回一个 error
同步消息 同步消息通过 skynet.call的方式进行投递，它会阻塞当前协程（goroutine 或者是 coroutine），它也返回一个错误，能解除此次阻塞只有两个条件，对点服务skynet.ret 或者达到了指定超时时间， 所以特别在远程通讯的时候要考虑到 i/o 的延时
dead letter 这个很好理解，同erlang 主要是确保数据的一致性，保证重要的数据不会因为某个服务的意外退出而丢失了这些消息.</description>
    </item>
    
    <item>
      <title>skynet-go 设计初衷以及特性</title>
      <link>https://domyson.github.io/post/skynet/skynet/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/skynet/skynet/</guid>
      <description>&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;skynet-go&lt;/code&gt; 是一个基于消息和服务的&lt;code&gt;Actor&lt;/code&gt;分布式服务框架，
采用&lt;code&gt;go&lt;/code&gt;编写，致力于简化开发难度和成本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它是一个年轻的框架，仅仅经历了两款项目的迭代 现在版本为 &lt;code&gt;v1.6.0 2023-05-28&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.taptap.cn/app/229839&#34;&gt;羽翼军团&lt;/a&gt; v1.3.0&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.taptap.cn/app/215934&#34;&gt;我在民国淘古玩&lt;/a&gt; v.1.3.5&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至于什么是&lt;code&gt;Actor&lt;/code&gt;是必要了解的概念，&lt;a href=&#34;https://github.com/cloudwu/skynet&#34;&gt;skynet&lt;/a&gt; 以及 &lt;code&gt;erlang&lt;/code&gt; 都是基于这种模式。&lt;/p&gt;
&lt;p&gt;与&lt;code&gt;skynet-c&lt;/code&gt;的区别可见 &lt;a href=&#34;https://domyson.github.io/post/diff&#34;&gt;diff-skynet&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>sktpmd</title>
      <link>https://domyson.github.io/post/skynet/sktpmd/</link>
      <pubDate>Mon, 30 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/skynet/sktpmd/</guid>
      <description>简介 sktpmd模块是skynet底层集群模块，它承担了skynet网络节点之间的通讯职能。全名为(skynet port managment daemon)
架构 sktpmd 为了满足对等网络的性质，所以每次和其他节点建立连接是有两条连接， 当A节点于B节点建立连接，首先A节点发送握手等待B确认，B确认完成之后重复走A的流程，这样一个双向连接就被建立了起来
sktpmd可以支持任意网络协议，如 tcp,udp 甚至是 unix
当然一个好记的节点名称是非常有必要的，所以sktpmd也内置了一套非标准的本地 dns系统
使用 sktpmd的启动也非常简单，无须任何代码，仅仅只需要在 skynet.toml 中配置一下即可，使用的时候跟节点内通讯无任何区别，但要求参数必须是 []byte 类型，参考 bbuf 如
skynet.send(&amp;#34;host:port@name&amp;#34;,...) -- 通过域名或者地址+端口的形式和其他节点进行通讯 skynet.send(pid,...) -- 通过pid亦可 tunnel 既然节点之间是双向连接，所以连接数量为 f(n) = n²-n，如果节点过的时候，势必造成 socket fd 消耗殆尽，
基于这个问题，可以通过内置的tun，来设置代理，这么一来，tun的作用相当于这个集群节点的网关。因为其内部的节点相对于其他 tun 代理是不可见的，
通过配置tun的规则开启多个，则可以实现业务拆分。
2022-10-07 此模块被弃用，可以用多节点转接的方式或代理的方式做到，如 send(&amp;quot;n1.n2.n3@name&amp;quot;)
服务发现 sktpmd 提供了一套服务发现机制，但其运作原理是不同于 etcd 或者 consul,它本身是一个惰性发现，取决于第一次调用的地址是否正确返回。
你不需要知道它是如何运作的，你只需要知道在特定时间内它是有效的即可，那怕其中出了一些意外，无非只是浪费了两次通讯而已。
gossip sktpmd整个发现流程是基于 gossip 算法来发现的,但一些api依然可以主动触发
网络底层 参考 Go协程的思考,在linux下，使用了 epoll。所以尽量部署到 linux 下以发挥更好的性能</description>
    </item>
    
    <item>
      <title>timer</title>
      <link>https://domyson.github.io/post/skynet/timer/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/skynet/timer/</guid>
      <description>简介 timer 模块是 skynet 内置的一个定时模块，使用了小根堆实现。
apis skynet.sleep(d) 这个函数将会挂起当前协程，在lua和 go中将会有不同的表现，取决于两者底层之间的区别
skynet.timeout(d,fn) 注册一个到期时间，而之后将会触发这个函数，特别注意，此函数的执行协程同当前调用的协程，简单来说就是并不会造成资源竞争，但是需要注意一下 aba 问题
QA 为什么不提供循环计时器？
可以使用闭包来实现循环
为什么不提供取消？
可以使用标记位来控制逻辑
为什么使用小根堆
为了尽可能减少精度丢失，以及内存，简单而言其实是一个topk算法的变种，不需要在一次循环中做完所有事(10ms)</description>
    </item>
    
    <item>
      <title>version change</title>
      <link>https://domyson.github.io/post/skynet/version/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/skynet/version/</guid>
      <description>v1.1.1 Fixed 修复了http一个原子锁问题，但在高并发下可能会出现失败的情况 修复了 skynet.send(string,any) 会产生两次搜索的情况 Added skynet-lua 增加 skynet.trace() 用以输出当前堆栈 skynet-lua 增加 check_version() 函数，校验skynet版本 v1.1.2 Fixed 修复了kill函数重入导致越界的问题
修复http 因为判断发送失败的错误，现在如果发送失败返回404
Mod skynet.send(dst,...) 现在传入参数可以是大于2个，当等于2，与之前无区别，当大于2则会转为table skynet.send() 现在不返回 boolean，而是返回一个number,为0则认为成功 kill 函数现在会立即退出当前服务 killed 事件不会被传入了 v1.2.0 Mod 取消了事件投递到达服务，会给出一个字符串类型的消息发送这类型，用以区别数据的来源位置以及类型
与上述相关的问题，skynet.send(dest,...) 变为了 skynet.send(dest,typ,...) 现第二参数输入你自己的类型，以便于接收者区分，不要和服务同名，那是没有任何意义的 主要是为了确定一种数据的类型，而非一系列服务，本身服务和数据类型并非是一对一的关系
skynet.start -&amp;gt; skynet.uptime
v1.2.1 Mod 现在 skynet.warn,skynet.error,skynet.trace,skynet.debug 支持传入任意类型参数,优化栈分配 Fixed 修复了ucpd 缓冲未释放的问题 Add 增加 skynet.call skynet.reply 是一个组合调用。否则会造成协程被挂起 v1.2.2 Add 增加 bbuf 协议解析，通过 bbuf = require(&amp;quot;skynet.bbuf&amp;quot;) 引用 bbuf errno = bbuf.load(path) 解析文件描述 bytes(userdata),errno = bbuf.</description>
    </item>
    
    <item>
      <title>allocator</title>
      <link>https://domyson.github.io/post/skynet/allocator/</link>
      <pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/skynet/allocator/</guid>
      <description>简介 alloctor 模块主要是为了减少GC而开发。现支持两套分配规则
基于 SLAB 算法的分段内存分配器 SLAB 最开始是阅读 linux 源码学习的算法，在skynet中它确实有更优秀的性能，因为它直接分配了一块共用内存，所以不会产生任何GC和真实分配, ，但在业务开发过程中，一旦忘记释放 那么这段内存将不能再被使用和获取了（也就是野指针），直到程序结束。
哪怕内置的Debug模式也无法定位到这个指针，原因在于 golang 堆栈伸缩会导致指针地址变动，所以 Debug 只能定位到存在 memory-leak，而无法知道具体位置。若需要具体位置则需要hook这个调用栈，性能方面得不偿失
slab-allocator 对业务开发很不友好，最终只是将它保留作为可选项，是否使用取决于业务实际需要，因为它违背了 skynet 的设计初衷。
如果需要使用可以在编译指令中指明slab
2020-10-18 阅读sync.Pool源码，看看能不能够和指定的P进行绑定，减少锁
基于 sync.Pool 的分段内存分配器 将不同size的buffer放入不同的池中，按需进行分配，减少race的开销
这个方法虽然简单，但是性能是低于 slab-allocator。
但它确实能减轻心智负担，代价就是牺牲了部分性能以及gc压力，但这也是skynet默认使用的策略。
API skynet.alloc(n) 用以分配指定大小的内存块
skynet.realloc(buf,n) realloc函数会先检查buf，确保是否需要重新分配内存
skynet.append(buf,data) 简化了 realloc 和 copy 的操作。
skynet.free(buf) 释放一段内存,对于slab 而言，它会检查buf的地址是否属于当前段</description>
    </item>
    
    <item>
      <title>pid</title>
      <link>https://domyson.github.io/post/skynet/pid/</link>
      <pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/skynet/pid/</guid>
      <description>PID Pid 是当前服务的唯一id，它确保在当前节点以及集群中唯一。
但重新启动节点之后，它的值可能会发生改变，所以不要尝试保存它，但可以确定的是集群中它依然是唯一的
作用 表示某一节点的某一的服务的地址，它最终输出是一串 uint64 的值。
可以通过 skynet.send(dst,...) skynet.call(ti,dst,...)来使用它，将消息发送出去</description>
    </item>
    
    <item>
      <title>sync.pool</title>
      <link>https://domyson.github.io/post/language/go/sync.pool/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/language/go/sync.pool/</guid>
      <description>结构分析 type Pool struct { noCopy noCopy local unsafe.Pointer // P 本地池，固定尺寸，实际结构 [P]poolLocal，类似 void* 并附加长度构成了一个数组 localSize uintptr // size of the local array victim unsafe.Pointer // local from previous cycle victimSize uintptr // size of victims array New func() any } type poolChain struct{ head *poolChainElt tail *poolChainElt } type poolChainElt struct{ // 一个双向链表 poolDequeue next,prev *poolChainElt } type poolDequeue struct{ headtail uint64 vals []eface } type eface struct{ // 数据的真实内存分配，包括一个类型描述和实际数据 typ,val unsafe.</description>
    </item>
    
    <item>
      <title>sync.Map</title>
      <link>https://domyson.github.io/post/language/go/sync.map/</link>
      <pubDate>Thu, 14 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/language/go/sync.map/</guid>
      <description>&lt;h1 id=&#34;syncmap-自带的安全-map&#34;&gt;&lt;code&gt;sync.Map&lt;/code&gt; 自带的安全 &lt;code&gt;map&lt;/code&gt;&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;源码位于 &lt;code&gt;${GOPATH}/src/sync/map.go&lt;/code&gt;，值得注意的是&lt;code&gt;sync.Map&lt;/code&gt;是&lt;code&gt;lazy load&lt;/code&gt;,不需要初始化&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>mysql batch update</title>
      <link>https://domyson.github.io/post/db/mysql/%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0/</link>
      <pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/db/mysql/%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近开发公会功能，需要定时保存一些，如果每次都是以公会为单位的话，相当于n个公会执行了n次&lt;code&gt;UPDATE&lt;/code&gt;操作&lt;/p&gt;
&lt;h1 id=&#34;实现&#34;&gt;实现&lt;/h1&gt;
&lt;h2 id=&#34;简单粗暴update&#34;&gt;简单粗暴&lt;code&gt;UPDATE&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;UPDATE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mytable&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;SET&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;field1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;val1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;field2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;val2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;WHRER&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CONDITION&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Cgo</title>
      <link>https://domyson.github.io/post/language/go/cgo/</link>
      <pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/language/go/cgo/</guid>
      <description>cgo 一种go与c交互的技术 开启cgo 要求系统安装C/C++工具链，macos和linux(gcc 自带)，windows(mingw),并确保环境变量CGO_ENAVBLE=on,最后单个源码需要导入 import &amp;quot;C&amp;quot;
cgo类型映射 C type Cgo type Go type char C.char byte signed char C.schar int8 unsigned char C.uchar uint8 short C.short int16 unsigned short C.ushort uint16 int C.int int32 unsigned int C.uint uint32 long C.long int32 unsigned long C.ulong uint32 long long int C.longlong int64 unsigned long long int C.ulonglong uint64 float C.float float32 double C.double double size_t C.size_t uint 函数指针 go引用c的函数指针比较特别
官方给出的Example
我这里给出另外一种,通过c wrap 这个函数指针成一个普通函数，然后go调用它</description>
    </item>
    
    <item>
      <title>mysql100问</title>
      <link>https://domyson.github.io/post/db/mysql/mysql100%E9%97%AE/</link>
      <pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/db/mysql/mysql100%E9%97%AE/</guid>
      <description>聚集、非聚集、联合索引 A1: 聚集索引（主键索引）所有ROW都会按照主键索引进行排序
A2: 非聚集索引即普通索引加上字段
A3: 几个字段组成的索引
A4: 聚集索引在物理上连续，非聚集索引在物理上不连续，但在逻辑上连续
A5: 聚集索引影响物理存储顺序，而非聚集索引不影响
A6: 聚集索引插入慢，查询快，非聚集索引反之
A7: 索引是通过二叉树来描述的，聚集索引的子叶节点也是数据节点，而非聚集索引子叶节点仍是索引节点
自增主键有哪些问题 A1: 分表分库的时候可能会出现重复情况（可使用uuid替代） A2: 产生表锁 A3: id耗尽 索引无效的情况 A1: 以%开头的LIKE语句，模糊匹配 A2: OR 前后字段未同时使用索引 A3: 数据类型隐式转换（varchar-&amp;gt;int) 查询优化 A1: 在WHERE和ORDER BY所涉及的列上加上索引 A2: SELECT避免使用*,SQL语句全部大写 A3: 避免WHERE对索引列上进行IS NULL判断，替换成IS NOT NULL A4: IN和NOT IN会导致全表扫描,替换为EXISTS或NOT EXISTS A5: 避免在索引上进行计算 A6: WHRER使用OR会放弃索引进而全表扫描 CHAR和VARCHAR的区别 A1: 存储和检索方式不同 A2: CHAR长度在创建时候指定(1~255),在存储时尾部全部填充空格 主键索引和唯一索引的区别 A1: 主键是一种约束 A2: 主键一定包含一个唯一索引，反之不成立 A3: 主键索引不允许包含空值，而唯一索引可以 A4: 一张表只能有一个主键索引，而唯一索引可以有多个 CPU飙升问题排查 A1: top命令观察mysqld A2: 若是，则show processlist查看是否是 SQL 的问题， A3: 若是，则检查执行计划是否准确，是否索引确实，数据是否太大 A4: kill上述线程，加索引，改内存，改SQL并重跑 A5: 若不是，可能是短时间有大量连接，可以限制最大连接数 如何创建索引 A1:</description>
    </item>
    
    <item>
      <title>Go GC分析</title>
      <link>https://domyson.github.io/post/language/go/gc/</link>
      <pubDate>Sat, 26 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/language/go/gc/</guid>
      <description>如何启用GC跟踪 GODEBUG=gctrace=1 go run *.go
其中 gctrace=1 表示只针对这个进程进行GC追踪
标记流程 go采用三色标记法，主要是为了提高并发度，这样扫描过程可以拆分为多个阶段，而不用一次扫描全部
黑 根节点扫描完毕，子节点也扫描完毕
灰 根节点扫描完毕，子节点未扫描
白 未扫描
扫描是从 .bss .data goroutine栈开始扫描，最终遍历整个堆上的对象树
标记 mark 标记过程是一个广度优先的遍历过程，扫描节点，将节点的子节点推送到任务队列中，然后递归扫描子叶节点，直到所有工作队列被排空
mark阶段会将白色对象标记，并推入队列中变为灰色
memory barrier 保障了代码描述中对内存的操作顺序，即不会在编译期被编译器进行调整，也不会在运行时被CPU的乱序执行所打乱
write barrier 在应用进入 GC 标记阶段前的 stw 阶段，会将全局变量 runtime.writeBarrier.enabled 修改为 true，这时所有的堆上指针修改操作在修改之前便会额外调用 runtime.gcWriteBarrier
由于GC和Go主程序并发执行，所以必须要在扫描时监控内存可能出现的状态改变，所以需要写屏障，所以需要暂停GO主程序（STW）
hybrid wirte barrier (after go1.8) 改方式的基本思想是：对正在被覆盖的对象进行着色，且如果当时栈未扫描完成，则同样对指针进行着色
GC流程 程序启动会为每个P分配一个 mark worker 来标记内存，负责为进入STW做前期工作
起初认为所有 object 都被认定为白色 但栈，堆和全局变量的object被标记为灰色 GC会将灰色object标记为黑色，将灰色object所包含的所有指针所指向的地址都标记为灰色，递归这两个步骤，最终对象非黑即白，其中白色object即未被引用且可以被回收，如果object标记为no scan，则递归结束，标记为黑色
todo https://blog.csdn.net/asd1126163471/article/details/124113816</description>
    </item>
    
    <item>
      <title>tcp协议</title>
      <link>https://domyson.github.io/post/linux/tcp/</link>
      <pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/linux/tcp/</guid>
      <description>什么是 Tcp 三次握手 tcp client发送连接请求报文，报文首部同步标记位 SYN=1 同时随机序列号 seq=x，此时 tcp client 进入 SYNC-SENT 状态的
tcp server 若同意连接则确认报文为 ACK=1,SYN=1,ASK=x+1,seq=y 返回给客户端，并进入 SYNC_RCVD 状态
tcp client 收到回复并确认 ACK 是否为1，seq 是否为 x+1,并返回报文 ACK=1,ASK=y+1,此时双方进入 ESTABLISHED 状态
四次挥手 主动方发送报文FIN=1,seq=last+1并进入FIN_WAIT_1,此时报文不能携带任何数据
被动方收到连接释放报文，并发送确认报文 ACK=1,ack=u+1,seq=v ，并进入 CLOSE_WAIT状态，但此时如果缓冲区存在未发送数据，那么需要继续发送（这也是 CLOSE_WAIT 持续的时长），主动方收到此条报文后进入 FIN_WAIT_2,因为还需要处理未发送数据
上一步执行完毕，被动方发送 FIN=1,ack=w+1,seq=u+1 并进入 LAST-ACK 状态，而主动方收到此条报文后进入 TIME_WAIT （2msl maximum segment life），之后才会进入 CLOSED
在主动方进入 CLOSED 之前，需要发送报文确认退出
2MSL 1MSL保证主动方最后的 ACK 能到达对端，1MSL 确保 ACK 重传
如何确保可靠性 三次握手，四次挥手确保连接和断开的可靠
记录了哪些数据被接受，哪些未接收，序列号保证了消息的顺序性
ACK应答，超时重传，失序重传，丢弃重复数据，流量控制，拥塞控制
重传机制 RTT，RTO Round-Trip Time 消息往返时间 Retransmission Timeout 超时重传</description>
    </item>
    
    <item>
      <title>unsafe包</title>
      <link>https://domyson.github.io/post/language/go/unsafe/</link>
      <pubDate>Wed, 25 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/language/go/unsafe/</guid>
      <description>Golang 默认指针是类型安全的，但它有很多限制。Golang 还有非类型安全的指针，这就是 unsafe 包提供的 unsafe.Pointer。在某些情况下，它会使代码更高效，当然，也更危险。unsafe 包用于 Go 编译器，在编译阶段使用。从名字就可以看出来，它是不安全的，官方并不建议使用。Go 语言类型系统是为了安全和效率设计的，有时，安全会导致效率低下。unsafe 包绕过了 Go 的类型系统，达到直接操作内存的目的，使用它有一定的风险性。但是在某些场景下，使用 unsafe 包提供的函数会提升代码的效率，Go 源码中也是大量使用 unsafe 包。
unsafe 包 //定义 type ArbitraryType int type Pointer *ArbitraryType //函数 func Sizeof(x AribitraryType) uintptr{} func Offsetof(x AribitraryType) uintptr{} func Alignof(x AribitraryType) uintptr{} 分析 Pointer : 指向任意类型，类似于 C 中的 void*。
Sizeof : 返回所传类型的大小，指针只返回指针的本身（x64 8byte x86 4byte），而不会返回所指向的内存大小。
Offsetof : 返回 struct 成员在内存中的位置，相对于此结构体的头位置，所传参数必须是结构体成员。传入指针，或者结构体本身，会 error
Alignof : 返回 M，M 是内存对齐时的倍数。
任意指针都可以和 unsafe.Pointer 相互转换。
uintptr 可以和 unsafe.</description>
    </item>
    
    <item>
      <title>性能优化</title>
      <link>https://domyson.github.io/post/unity/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/unity/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <description>音频 短音频使用Wav，长音频使用mp3 纹理 Mipmap mipmap用于减少渲染的带宽压力，但会有额外的内存开销，一般而言UI是建议关闭的，3D模型看情况开启
Read/Write 纹理尺寸 不同大小的纹理尺寸对内存的占用也是不同，依照项目的实际情况来决定Size
格式 由于ETC、PVRTC等格式均为有损压缩，因此，当纹理色差范围跨度较大时，均不可避免地造成不同程度的“阶梯”状的色阶问题。因此，很多研发团队使用RGBA32/ARGB32格式来实现更好的效果。但是，这种做法将造成很大的内存占用
ETC1 不支持透明通道问题 可以通过 RGB24 + Alpha8 + Shader 的方式达到比较好的效果
ECT2，ASTC 但需要设备支持 OpenGL ES3.0
LOD unity内置的一项技术，主要是根据目标离相机的距离来断定使用何种精度的模型，减少顶点数的绘制，但代价就是要牺牲部分内存
Occlusion culling 遮挡剔除 遮挡剔除是用来消除躲在其他物件后面看不到的物件，这代表资源不会浪费在计算那些看不到的顶点上，进而提升性能
batching dynamic batching 将一些足够小的网格，在CPU上转换它们的顶点，将许多相似的顶点组合在一起，并一次性绘制它们。 无论静态还是动态合批都要求使用相同的材质，动态合批有以下限制：
+ 如果GameObjects在Transform上包含镜像，则不会对其进行动态合批处理 + 使用多个pass的shader不会被动态合批处理 + 使用不同的Material实例会导致GameObjects不能一起批处理，即使它们基本相同。 + [官方25个不能动批的情况](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FUnity-Technologies%2FBatchBreakingCause) static batching 静态合批是将静态（不移动）GameObjects组合成大网格，然后进行绘制。静态合批使用比较简单，PlayerSettings中开启static batching，然后对需要静态合批物体的Static打钩即可，unity会自动合并被标记为static的对象，前提它们共享相同的材质，并且不移动，被标记为static的物体不能在游戏中移动，旋转或缩放。但是静态批处理需要额外的内存来存储合并的几何体。注意如果多个GameObject在静态批处理之前共享相同的几何体，则会在编辑器或运行时为每个GameObject创建几何体的副本，这会增大内存的开销
GPU Instancing 使用GPU Instancing可以一次渲染(render)相同网格的多个副本，仅使用少量DrawCalls。在渲染诸如建筑、树木、草等在场景中重复出现的事物时，GPU Instancing很有用。
每次draw call，GPU Instancing只渲染相同(identical )的网格，但是每个实例(instance)可以有不同的参数(例如，color或scale)，以增加变化(variation)，减少重复的出现。
GPU Instancing可以减少每个场景draw calls次数。这显著提升了渲染性能。
Physics Auto Simulation 根据项目实际需要是否开启物理模拟，默认是是开启的
Fixed Timestep 过小的值会操成计算量过大，过大的值可能造成部分机制异常(如卡墙，穿透等)，根据项目实际来确定
Maximum Allowed Timestep 这里我们需要先知道物理系统本身的特性，即当游戏上一帧卡顿时，Unity会在当前帧非常靠前的阶段连续调用N次FixedUpdate.PhysicsFixedUpdate，Maximum Allowed Timestep的意义就在于单帧限制物理更新的次数，</description>
    </item>
    
    <item>
      <title>assetbundle</title>
      <link>https://domyson.github.io/post/unity/assetbundle/</link>
      <pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/unity/assetbundle/</guid>
      <description>Assetbundle 一种包外资源的存储方案，方便更新以及加载
Manifest 每一个文件夹下都会有一个 Manifest文件，其作用是包含了其下资源的引用关系
AB管理 资源分类 一般而言我们会根据语言版本进行分类，（如一些有图片文字的资源），然后根据资源的通用性区分是否是共享资源，以减少AB资源冗余，二是根据模块业务来细分。
资源加载 首先应当加载Manifest文件读取相关依赖，常用的做法是加载到内存由用户自己控制，因为原始的结构是树状结构，当层次比较深的时候会造成搜索时间过长，转为字典的方式确保索引时间为O(1)
依赖相关的问题，如A依赖于C，A被第一次被加载时，是需要先检查是否C是否被加载。
资源卸载 资源卸载一般都为引用计数的方式，但某些情况下可能会出现刚卸载完就需要被再次使用的场景，这个时候做一个对象池维护一定量的内存资源是合理的方式
其次是资源依赖，如A引用了C，B引用了C，若此时A，B被卸载的时候，C的引用数为0，那么这个时候是否应该卸载C呢？，答案是否定的，也许会存在 D，E,F 同样依赖于C，这个时候最好的做法是将这个资源放入池中，开启循环技术，当到达某个阈值时再释放.
public class ABAsset{ public int Ref; public int tick; } public class ABManagment{ // per frame or interval call. public void GC(){ for (){ ... if (ab.Ref == 0){ ab.tick --; if(ab.tick &amp;lt;= 0){ // release. } } } } } 存在的问题
上述方案从程序的角度上看来是没有逻辑问题的，但如果程序员忘记释放了如何解决这个问题，笔者这里分为两种，
一种非Monobehaviour的类，可以通过析构函数。
构建一个公共抽象，由父类实现。
资源分包 常常见到的问题是一般资源分多大合适，官方给出的建议是3~5MB,但现实情况是分不了这么细怎么办，比如登陆场景的立绘。为了达到效果肯定是不会过大的压缩。这就引申出另外一个问题，过大的资源如何保证不卡顿。一般而言像这种大资源分两种情况
长期使用 笔者项目一般会做资源预热，像这类资源我们会在首次登陆切换场景的时候就直接加载，保证不会被回收。
仅使用一次 也会先预热，但之后就会立即卸载，以保证不会占用过多的内存资源
引用 运行时，AssetBundle驻留控制在40MB以内、数量在1000个以内； 使用LZ4压缩+LoadFromFile加载； 结合项目情况根据依赖树制定打包策略，如公共资源单独打AssetBundle、按使用场景和功能类型分包、独立资源打到一起、Shader/字体等（较为细碎、内存不高、高频使用、最好常驻的）资源打包到一起，启动游戏的时候常驻内存； 结合热更新需求打包； 依赖打包，追求0冗余； 粒度具体没有定值，近期经验上来看会需要尤其警惕AssetBundle包体超过10MB的。 </description>
    </item>
    
    <item>
      <title>预处理器</title>
      <link>https://domyson.github.io/post/language/c/preprocessor/</link>
      <pubDate>Sat, 04 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/language/c/preprocessor/</guid>
      <description>预处理器 #pragma 用于指示编译器完成一些特定的动作
#pragma message usermessage
//example:test.c #include &amp;lt;stdio.h&amp;gt; #define IOS #if defined IOS #pragma message &amp;#34;ready complie ios...&amp;#34; #endif //complie output: note: #pragma message: ready complie ios... #pragma once 确保头文件仅被编译一次
//example:test.h #pragma once int value = 10; //example:test.c #include &amp;#34;test.h&amp;#34; #include &amp;#34;test.h&amp;#34; #pragma pack(size_t) 指定内存对齐
//example:test.c // 2byte 对齐 #pragma pack(2) struct foo{ char c1; char c2: short 2; int i; }; // 4byte 对齐 #pragma pack(4) struct bar{ char c1; shirt s; char c2; int i; }; void main(){ printf(&amp;#34;%d\n&amp;#34;,sizeof(struct foo)); //8 printf(&amp;#34;%d\n&amp;#34;,sizeof(struct bar)); //12 } 在不同编译器之间不可移植，在不同编译器可能以不同的方式解释，预处理器将忽略不被识别的此指令</description>
    </item>
    
    <item>
      <title>pointer</title>
      <link>https://domyson.github.io/post/language/c/pointer/</link>
      <pubDate>Sat, 02 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/language/c/pointer/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Go 编译指示</title>
      <link>https://domyson.github.io/post/language/go/pragma/</link>
      <pubDate>Sat, 18 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/language/go/pragma/</guid>
      <description>编译指示 在计算机编程中，编译指示(pragma) 是一种语言结构，它指示编译器应该如何处理其输入。指示不是编程语言语法的一部分，因编译器而异。
Go中的编译指示 //go:pragma func Echo(){} 指示详解 //go:noinline 使函数不内联，内联是在编译期间发生的，将函数调用处替换为被调用函数主体的一种编译器优化手段。
减少函数调用的开销，提高执行速度。
复制后的更大函数体为其他编译优化带来可能性，如 过程间优化
消除分支，并改善空间局部性和指令顺序性，同样可以提高性能。
代码复制带来的空间增长。
如果有大量重复代码，反而会降低缓存命中率，尤其对 CPU 缓存是致命的。
内联 func Max(a, b int) int { if a &amp;gt; b { return a } return b } func F() { const a, b = 100, 20 if Max(a, b) == b { panic(b) } } // `Max` 函数被内联，死码消除之后，`F()` 函数被变成了 `F(){ return }` 内联级别：默认常规内联，-gcflags=-l 禁用内联，-gcflags=&#39;-l -l&#39; 二级内联，-gcflags=&#39;-l -l -l&#39; 三级内联，-gcflags=&#39;-l -l -l -l&#39; 四级内联，级数越大，也许更快，但bug更多</description>
    </item>
    
    <item>
      <title>TLS</title>
      <link>https://domyson.github.io/post/linux/tls/</link>
      <pubDate>Sun, 09 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/linux/tls/</guid>
      <description>简介 传输层安全性协议（Transport Layer Security），及其前身 SSL3.0 之后安全套接层（Secure Sockets Layer，缩写作SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。SSL包含记录层（Record Layer）和传输层，记录层协议确定传输层数据的封装格式。传输层安全协议使用X.509认证，之后利用RSA 加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）。这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。
作用 安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性。
协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。
TLS协议的优势是与高层的应用层协议（如HTTP、FTP、Telnet等）无耦合。应用层协议能透明地运行在TLS协议之上，由TLS协议进行创建加密通道需要的协商和认证。应用层协议传送的数据在通过TLS协议时都会被加密，从而保证通信的私密性。
连接过程 当客户端连接到支持TLS协议的服务器要求创建安全连接并列出了受支持的密码组合（加密密码算法和加密哈希函数），握手开始。
服务器从该列表中决定加密和散列函数，并通知客户端。
服务器发回其数字证书，此证书通常包含服务器的名称、受信任的证书颁发机构（CA）和服务器的公钥。 客户端确认其颁发的证书的有效性。
为了生成会话密钥用于安全连接，客户端使用服务器的公钥加密随机生成的密钥，并将其发送到服务器，只有服务器才能使用自己的私钥解密。
利用随机数，双方生成用于加密和解密的对称密钥。这就是TLS协议的握手，握手完毕后的连接是安全的，直到连接（被）关闭。如果上述任何一个步骤失败，TLS握手过程就会失败，并且断开所有的连接。
TLS协议 https 本身基于 http 传输，但是信息通过了 tls 协议加密。
tls 协议位于传输层之上，应用层之下。首次进行 tls 1.3 协议传输需要一个 RTT
tls 可以使用对称加密和非对称加密。
握手过程 客户端发送一个随机值以及需要的协议和加密方式。
服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，并且发送自己的证书（如果需要验证客户端证书需要说明）。
客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书。
服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密。
之后通过此非对称加密传输的对称加密的密钥来进行正式通讯。</description>
    </item>
    
    <item>
      <title>Go标准命令</title>
      <link>https://domyson.github.io/post/language/go/cmd/</link>
      <pubDate>Tue, 28 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/language/go/cmd/</guid>
      <description>&lt;p&gt;Go源码文件包括：命令源码文件、库源码文件和测试源码文件。其中，命令源码文件总应该属于main代码包，且在其中有无参数声明、无结果声明的main函数。单个命令源码文件可以被单独编译，也可以被单独安装&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>channel</title>
      <link>https://domyson.github.io/post/language/go/channel/</link>
      <pubDate>Mon, 20 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/language/go/channel/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;CSP(communicating sequential processes)&lt;/code&gt; 模型由并发执行实体(进程，线程或协程)，和消息通道组成，实体之间通过消息通道发送消息进行通信。和 &lt;code&gt;Actor&lt;/code&gt; 模型不同，&lt;code&gt;CSP&lt;/code&gt; 模型关注的是消息发送的载体，即通道，而不是发送消息的执行实体。Go 语言的并发模型参考了 CSP 理论，其中执行实体对应的是 &lt;code&gt;goroutine，&lt;/code&gt; 消息通道对应的就是 &lt;code&gt;channel&lt;/code&gt;。&lt;code&gt;CSP&lt;/code&gt; 模型的核心是：不通过共享内存来达到通讯，而是通过通讯来共享内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;channel&lt;/code&gt; 提供了一种通信机制，通过它，一个 &lt;code&gt;goroutine&lt;/code&gt; 可以与另一 &lt;code&gt;goroutine&lt;/code&gt; 发送消息。&lt;code&gt;channel&lt;/code&gt; 本身还需关联了一个类型，也就是可以发送数据的类型。可以通过 &lt;code&gt;len()&lt;/code&gt; 获取通道当前缓冲数量。 &lt;code&gt;cap()&lt;/code&gt; 获取通道最大缓冲。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Go Module</title>
      <link>https://domyson.github.io/post/language/go/mod/</link>
      <pubDate>Sun, 29 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/language/go/mod/</guid>
      <description>Module Golang 从1.11版本开始支持官方自带的依赖管理模块。根据项目路径中的 go.mod 文件来建立依赖管理。
依赖添加 通过 import 自动添加到 go.mod 文件中
import &amp;#34;github.com/xxx/yyy&amp;#34; 编辑 go.mod 文件
module xxx go 1.13.4 require( xxxx v0.0.0 yyyy v1.1.1 ) 依赖升级 通过 go 命令
#查看gin的所有版本 go list -m -versions github.com/gin-gonic/gin #输出所有gin的版本 github.com/gin-gonic/gin v1.1.1 v1.1.2 v1.1.3 v1.1.4 v1.3.0 v1.4.0 v1.5.0 #下载所需依赖 go mod tidy 直接编辑 go.mod 文件
删除未使用依赖项 go mod tidy
使用本地包 /* go.mod文件 replace boost-go v0.0.1 =&amp;gt; ../boost-go */ </description>
    </item>
    
    <item>
      <title>process</title>
      <link>https://domyson.github.io/post/linux/process/</link>
      <pubDate>Wed, 25 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/linux/process/</guid>
      <description>进程状态 TASK_RUNNING TASK_INTERRUPTIBLE TASK_UNINTERRUPTIBLE TASK_TRACED TASK_STOPPED </description>
    </item>
    
    <item>
      <title>Locker</title>
      <link>https://domyson.github.io/post/language/go/lock/</link>
      <pubDate>Wed, 11 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/language/go/lock/</guid>
      <description>sync.Mutex mutex相关的所有事情都是通过sync.Mutex类型的两个方法sync.Lock()和sync.Unlock()函数来完成的，前者用于获取sync.Mutex锁，后者用于释放sync.Mutex锁。sync.Mutex一旦被锁住，其它的Lock()操作就无法再获取它的锁，只有通过Unlock()释放锁之后才能通过Lock()继续获取锁。
不区分读写锁，只有Lock()与Lock()之间才会导致阻塞的情况
不与 Goroutine 关联
在Lock()和Unlock()之间的代码段称为资源的临界区(critical section)，在这一区间内的代码是严格被Lock()保护的，是线程安全的，任何一个时间点都只能有一个goroutine执行这段区间的代码。由于内核调度的不确定性，所以谁获取锁也是不确定的
sync.RWMutex RWMutex 基于 Mutex,并增加了读、写信号量，增加了获取读锁的计数
读锁和读锁兼容，写锁和读锁互斥，写锁和写锁互斥
可以同时申请多个读锁
读锁存在，则写锁阻塞，反之亦然
写锁存在，写锁和读锁都阻塞，同一时间仅一个能写
不与 Goroutine 关联
源码 //RwMutex source code type RWMutex struct{ w Mutex writerSem uint32 readerSem uint32 readerCount int32 readerWait int32 } //example var rw sync.RWMutex func Something(){ // Lock() UnLock() 获取和释放写锁 // RLock() RUnlock() 获取和释放读锁 } sync.Cond 条件锁 sync.Cond 实现了一个条件变量，在 Locker 的基础上增加了一个消息通知的功能，其内部维护了一个等待队列，队列中存放的是所有等待在这个 sync.Cond 的 goroutine，即保存了一个通知列表。可以用来唤醒一个或所有因等待条件变量而阻塞的 goroutine，以此来实现多个 Go 程间的同步。
源码 type Cond struct { noCopy noCopy L Locker // 基于原生的锁 notify notifyList //通知列表 checker copyChecker } // 基于一个锁来创建，可以是 RWMutex 或 Mutexs func NewCond(l Locker) *Cond { return &amp;amp;Cond{L: l} } // 挂起 goroutine 直到调用 Broadcast和Signal func (c *Cond) Wait() { c.</description>
    </item>
    
    <item>
      <title>组合AI</title>
      <link>https://domyson.github.io/post/unity/ai/</link>
      <pubDate>Tue, 10 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/unity/ai/</guid>
      <description>什么是AI 一串由外部因素影响行为的实体？
内部条件分支构建的行为？
学习并采取对应策略的结果？（Alpa go）
AI设计思想 特别注意这是笔者自己的一套思维，而非网上流传的。其中会混入一些ECS的思想
何谓AI 我们人为给它制定约束行为条件，让其结果收敛于某个区间，比如我没给它赋予行走的行为（单元），那么它就不应该存在这种方面的意向倾斜，（它可能会提示需要这种行为，而不是自主产生这种行为），这也是和带学习能力AI的区别，它的计算结果不应该是发散的。
AI Unit AI单元是对某些行为具体抽象，它是数据（你也可以认为它是ECS中的C），比如行走（AI_WALK），它有一些数据
public class AI_Walk{ public float Speed; public Vector3 Direction; } 这个时候AI实体具备了一个行走的逻辑，朝哪走，走多快由这个单元确定，再比如说跑这个行为，它和走没任何区别，我们仅仅需在必要的时刻改变AI_Walk这个单元的属性值即可。因为它们有共同的数据结构。
AI Selector AI选择器用于对每个条件节点
AI Executor todo</description>
    </item>
    
    <item>
      <title>Go性能分析</title>
      <link>https://domyson.github.io/post/language/go/pprof/</link>
      <pubDate>Fri, 23 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/language/go/pprof/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般要根据实际情况去判定其具体含义，如 C语言中单元指一个函数,单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Protobuf3</title>
      <link>https://domyson.github.io/post/others/protobuf/</link>
      <pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/others/protobuf/</guid>
      <description>&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Protocol Buffers&lt;/code&gt;，是Google公司开发的一种数据描述语言，类似于XML能够将结构化数据序列化，可用于数据存储、通信协议等方面。本文只介绍 &lt;code&gt;syntax = proto3&lt;/code&gt; 的协议语法。&lt;/p&gt;
&lt;h1 id=&#34;标准类型对照&#34;&gt;标准类型对照&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;.proto&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;注释&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;C++&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Python&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Go&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;C#&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;double&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;定长编码&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;double&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;float&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;float64&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;double&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;float&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;定长编码&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;float&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;float&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;float32&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;float&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int32&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;变长编码,负数编码效率低，可使用&lt;code&gt;sint32&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int32&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int32&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int64&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;变长编码,负数编码效率低，可使用&lt;code&gt;sint64&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int64&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int/long&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int64&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;uint32&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;变长编码&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;uint32&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int/long&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;uint32&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;uint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;变长编码&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int/long&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;unit64&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ulong&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;sint32&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;变长编码，对负数编码比&lt;code&gt;int32&lt;/code&gt;更有效率&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int32&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int32&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;sint64&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;变长编码，对负数编码比&lt;code&gt;int64&lt;/code&gt;更有效率&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int64&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int/long&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int64&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;fixed32&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;总是&lt;code&gt;4&lt;/code&gt;字节，如果值大于&lt;code&gt;2^28&lt;/code&gt;比&lt;code&gt;uint32&lt;/code&gt;更有效率&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;uint32&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int/long&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ulong&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;fixed64&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;总是&lt;code&gt;8&lt;/code&gt;字节，如果值大于&lt;code&gt;2^56&lt;/code&gt;比&lt;code&gt;uint64&lt;/code&gt;更有效率&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int/long&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ulong&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;bool&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1或0的变长编码&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;bool&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;boolean&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;bool&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;bool&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;string&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必须是&lt;code&gt;UTF-8&lt;/code&gt;编码&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;string&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;str/unicode&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;string&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;string&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;bytes&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可包含任意的字节顺序&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;string&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;str&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;[]byte&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ByteString&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>
    </item>
    
    <item>
      <title>Go协程的思考</title>
      <link>https://domyson.github.io/post/language/go/goroutine/</link>
      <pubDate>Sun, 12 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/language/go/goroutine/</guid>
      <description>&lt;h1 id=&#34;栈&#34;&gt;栈&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;一个 os 线程会有一个给固定大小的内存块（一般是 2MB），用来存储当前线程中调用或挂起函数的内部变量，固定大小的栈对于复杂和深层次递归是不够的，而 Goroutine 会以一个很小的栈（2KB）开始其生命周期，这个栈会动态伸缩，最大能到达 1GB（32位系统是 250M）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;调度方式&#34;&gt;调度方式&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;os 线程由操作系统内核调用，每过一定时间（毫秒），硬件计时器会中断处理器，并调用一个名为 scheduler 的内建函数，这个函数会挂起当前执行的线程并保存内存中它的寄存器内存，然后检查线程列表并决定下一次执行哪个线程，并从内存中恢复该线程的寄存器信息，恢复该线程的线程并执行，这就是上下文切换，增加了 CPU 的运行周期。而 Go 的 runtime 包含了自身的调度器，和 os 线程不同是，&lt;code&gt;Goroutine&lt;/code&gt; 属于用户级线程由语言支持，调度由语言支持，所有开销会减少很多（相比于内核上下文切换）。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Docker</title>
      <link>https://domyson.github.io/post/docker/</link>
      <pubDate>Tue, 12 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/docker/</guid>
      <description>&lt;h1 id=&#34;什么是docker&#34;&gt;什么是docker&lt;/h1&gt;
&lt;p&gt;Docker 是一个开源的容器引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者和系统管理员在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括 VMs（虚拟机）、bare metal、OpenStack 集群、云端、数据中心和其他的基础应用平台。容器是完全使用沙箱机制，相互之间不会有任何接口。&lt;/p&gt;
&lt;h1 id=&#34;有什么优势&#34;&gt;有什么优势&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;轻量，在一台机器上运行的多个Docker容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标准，Docker 容器基于开放式标准，能够在所有主流Linux版本、Microsoft Windows以及包括VM、裸机服务器和云在内的任何基础设施上运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全，Docker 赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一次发布，到处使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;docker和虚拟机&#34;&gt;Docker和虚拟机&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;特性&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;容器&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;虚拟机&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;启动&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;秒级&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;分钟级&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;硬盘&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;MB&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;GB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;性能&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;接近原生&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;弱于原生&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持量&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单机上千&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单机几十左右&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;容器是一个应用层抽象，用于将代码和依赖资源打包在一起。 多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行 。与虚拟机相比， 容器占用的空间较少（容器镜像大小通常只有几十兆），瞬间就能完成启动。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚拟机（VM）是一个物理硬件层抽象，用于将一台服务器变成多台服务器。 管理程序允许多个VM在一台机器上运行。每个VM都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此占用大量空间。而且VM启动也十分缓慢 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;虚拟机更擅长于彻底隔离整个运行环境。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而 Docker 通常用于隔离不同的应用 ，例如前端，后端以及数据库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;docker基本组成&#34;&gt;Docker基本组成&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;镜像 （Image）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容器（Container）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;仓库（Repository）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;镜像image-一个特殊的文件系统&#34;&gt;镜像（Image）—— 一个特殊的文件系统&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像（Image），就相当于是一个root文件系统。Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 镜像不包含任何动态数据，其内容在构建之后也不会被改变。Docker设计时，就充分利用Union FS的技术，将其设计为分层存储的架构。 镜像实际是由多层文件系统联合组成。镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;容器container-镜像运行时的实体&#34;&gt;容器（Container）—— 镜像运行时的实体&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。前面讲过镜像使用的是分层存储，容器也是如此。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。按照Docker最佳实践的要求，容器不应该向其存储层内写入任何数据 ，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， 使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;仓库repository-集中存放镜像文件的地方&#34;&gt;仓库（Repository）—— 集中存放镜像文件的地方&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。一个Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。所以说：镜像仓库是Docker用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过&amp;lt;仓库名&amp;gt;:&amp;lt;标签&amp;gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以latest作为默认标签。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;docker-registry公开服务和私有docker-registry&#34;&gt;Docker Registry公开服务和私有Docker Registry&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Docker Registry公开服务是开放给用户使用、允许用户管理镜像的Registry服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。最常使用的Registry公开服务是官方的Docker Hub ，这也是默认的Registry，并拥有大量的高质量的官方镜像，网址为：hub.docker.com/ 。在国内访问Docker Hub可能会比较慢国内也有一些云服务商提供类似于Docker Hub的公开服务。除了使用公开服务外，用户还可以在本地搭建私有Docker Registry 。Docker官方提供了Docker Registry镜像，可以直接使用做为私有Registry服务。开源的Docker Registry镜像只提供了Docker Registry API的服务端实现，足以支持Docker命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;image&#34;&gt;Image&lt;/h1&gt;
&lt;h2 id=&#34;查看拉取删除&#34;&gt;查看、拉取、删除&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;搜索镜像&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker search name[:tag]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拉取镜像,若不指定tag则默认拉取&lt;code&gt;latest&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker pull name[:tag]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看本地所有镜像&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker images&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除镜像，可以多个删除&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker rmi [option] image ... &lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-f&lt;/code&gt; 强制删除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;制作推送&#34;&gt;制作、推送&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在指定路径中找到 &lt;a href=&#34;https://domyson.github.io/post/Dockerfile&#34;&gt;Dockerfile&lt;/a&gt; 并构建Image, 后面是路径，但路径中必须存在 &lt;code&gt;Dockerfile&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker build -t [:namespace]/name:tag Path&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;给镜像赋予新的标签, &lt;code&gt;namespace&lt;/code&gt; 必须为 &lt;code&gt;dockerid&lt;/code&gt;，除非另外购买。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker tag oldname:oldtag  namespace/newname:newtag&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将镜像上传至 docker 仓库 DockerHub 上,&lt;code&gt;namespace&lt;/code&gt; 必须是用户名,也可以上传至 &lt;code&gt;Gitlab&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker push namespace/name:tag&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提交修改的镜像&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker commit [-a] [-m] CONTAINER [REPOSITORY[:TAG]]&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-a&lt;/code&gt; 指明提交者&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-m&lt;/code&gt; 提交信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。
此方式更新的镜像有依赖通过 &lt;code&gt;docker save -o dst [REPOSITORY[:TAG]]&lt;/code&gt;存盘,删除所有镜像,再通过 &lt;code&gt;docker load -i path&lt;/code&gt; 加载新镜像。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;container&#34;&gt;Container&lt;/h1&gt;
&lt;h2 id=&#34;查看容器&#34;&gt;查看容器&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker ps [-a|-s]&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-a&lt;/code&gt; 查看所有容器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-s&lt;/code&gt; 查看已启动的容器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;产看容器进程&#34;&gt;产看容器进程&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker top containerID&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;移除容器&#34;&gt;移除容器&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;可以多个同时删除&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;docker rm container ...  [option]&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-f&lt;/code&gt; : 强制删除容器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-v&lt;/code&gt; : 若删除容器则数据卷也删除。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;停止容器&#34;&gt;停止容器&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;可以同时停止多个&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;docker stop container ...&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;启动容器&#34;&gt;启动容器&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker run [:--name] [:-e] [:-v] [:-h] [:--net] [:-p prot0:prot1] [:-d|-i] [:-t] [:--rm] [:--restart] [:--privileged=false] [:--ip] [:--network=] name:tag [:shell]&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;run&lt;/code&gt; 命令将会启动 &lt;code&gt;dockerfile&lt;/code&gt; 中定义的 &lt;code&gt;CMD&lt;/code&gt; 或 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 指令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--name=xxx&lt;/code&gt; 指定容器运行时的名称，可不选，默认为随机字符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-p Host0:Host1&lt;/code&gt; 表示本地 Host0 映射容器 Host1 端口,若为 &lt;code&gt;-P&lt;/code&gt; 则随机映射49000 ~ 49900 端口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-d&lt;/code&gt;：分离模式: 在后台运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-h&lt;/code&gt;：指定主机域名。如 &lt;code&gt;-h domyson.cn&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-e&lt;/code&gt;：为 &lt;code&gt;dockerfile&lt;/code&gt; 中的 &lt;code&gt;ENV&lt;/code&gt; 的参数变量,设置环境变量，或者覆盖已存在的环境变量 &lt;code&gt;-e TZ=&amp;quot;Asia/Shanghai&amp;quot;&lt;/code&gt; 设置时区为上海。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-u&lt;/code&gt;：&lt;del&gt;指定执行用户，一般为 &lt;code&gt;root&lt;/code&gt;。&lt;/del&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--rm&lt;/code&gt;：停止容器就移除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-it&lt;/code&gt;: 以交互模式运行容器 (不同于 &lt;code&gt;-d&lt;/code&gt; : 以分离模式运行容器),这意味着交互回话 session 结束时,容器就会停止运行，与 &lt;code&gt;-d&lt;/code&gt; 互斥。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-v&lt;/code&gt; : 容器内创建一个数据卷。多次重复使用 -v 标记可以创建多个数据卷，也可以挂载一个主机目录作为数据卷 path0:path1(其中path0是主机目录，path1是容器目录)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--link container&lt;/code&gt; : &lt;del&gt;连接到其他容器。&lt;/del&gt; 这个方法以后将被弃用，推荐使用 &lt;code&gt;--network&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--network NETWORK&lt;/code&gt;：指定连接到的网络。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--ip&lt;/code&gt;：指定容器的ip。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--restart&lt;/code&gt;：&lt;code&gt;no、on-failure:n、always&lt;/code&gt; 设置容器自动重启模式，若容器已经启动，可以通过 &lt;code&gt;docker update --restart args&lt;/code&gt; 来设置参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--privileged&lt;/code&gt;：真正给予 &lt;code&gt;Container 中 root 用户&lt;/code&gt; root权限，否则 &lt;code&gt;root&lt;/code&gt; 只是一个普通用户。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;shell&lt;/code&gt;：指定交互的方式，一般为bash &lt;code&gt;bash -c &amp;quot;cmd string&amp;quot;&lt;/code&gt;，这条命令将由启动容器执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;查看容器日志&#34;&gt;查看容器日志&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker logs [opt] CONTAINER&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-f&lt;/code&gt; : 跟踪日志输出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--since&lt;/code&gt; :显示某个开始时间的所有日志&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-t&lt;/code&gt; : 显示时间戳&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--tail N&lt;/code&gt; :仅列出最新N条容器日志&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进入指定容器&#34;&gt;进入指定容器&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker exec [opt] CONTAINER shell [:args]&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-d&lt;/code&gt; ：分离模式: 在后台运行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-it&lt;/code&gt;：以交互模式运行容器 (不同于 -d : 以分离模式运行容器),这意味着交互回话 session 结束时,容器就会停止运行。与 &lt;code&gt;-d&lt;/code&gt; 互斥&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-u&lt;/code&gt;：指定运行用户,一般设置为 root&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入容器内部之后，通过 &lt;code&gt;exit&lt;/code&gt; 退出&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;容器通讯方式&#34;&gt;容器通讯方式&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://domyson.github.io/2020/01/Docker-Network/&#34;&gt;See DockerNetwork&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;镜像体积优化&#34;&gt;镜像体积优化&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt; 由多个 &lt;code&gt;Layers&lt;/code&gt; 组成（上限是127层）。而 &lt;a href=&#34;https://domyson.github.io/2019/03/Dockerfile&#34;&gt;Dockerfile&lt;/a&gt; 每一条指令都会创建一层 &lt;code&gt;Layers&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;优化基础镜像&#34;&gt;优化基础镜像&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;Alpine&lt;/code&gt; 基础镜像&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Alpine是一个高度精简又包含了基本工具的轻量级Linux发行版，基础镜像仅 &lt;code&gt;4.41MB&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;scratch&lt;/code&gt; 基础镜像&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;scratch是一个空镜像，只能用于构建其他镜像&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;busybox&lt;/code&gt; 基础镜像&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果希望镜像里可以包含一些常用的Linux工具，busybox镜像是个不错选择，镜像本身只有1.16M，非常便于构建小镜像。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;串联-dockerfile-指令&#34;&gt;串联 &lt;code&gt;Dockerfile&lt;/code&gt; 指令&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;通过  &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;\&lt;/code&gt; 将多个 &lt;code&gt;Run&lt;/code&gt; 命令合并成一个&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;多段构建&#34;&gt;多段构建&lt;/h2&gt;
&lt;p&gt;待完善&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;&lt;/h2&gt;
&lt;h1 id=&#34;docker数据卷&#34;&gt;Docker数据卷&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;数据卷可以在容器之间共享和重用&lt;/li&gt;
&lt;li&gt;对数据卷的修改会立马生效&lt;/li&gt;
&lt;li&gt;对数据卷的更新，不会影响镜像&lt;/li&gt;
&lt;li&gt;数据卷默认会一直存在，即使容器被删除&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;创建数据卷&#34;&gt;创建数据卷&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;在 run 命令中 -v /data 标记来创建一个数据卷并挂载到容器里。在一次 run 中多次使用可以挂载多个数据卷。(创建一个容器，并加载一个数据卷到容器的 /data 目录)

也可以在 Dockerfile 中使用  VOLUME  来添加一个或者多个新的卷到由该镜像创建的任意容器。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;删除数据卷&#34;&gt;删除数据卷&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用  docker rm -v  这个命令。无主的数据卷可能会占据很多空间，要清理会很麻烦。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;挂载一个主机目录作为数据卷&#34;&gt;挂载一个主机目录作为数据卷&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker run -d -P --name web -v /src/webapp:/opt/webapp[:权限]

上面的命令加载主机的  /src/webapp  目录到容器的  /opt/webapp  目录，默认权限是读写，也可以指定为只读(ro)

--volumes-from 在run的时候指定数据卷容器
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;查看数据卷的信息&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker inspect contianerID&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看所有数据卷&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker volume ls&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;清除所有无主数据卷&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker volume prune&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;docker权限验证&#34;&gt;Docker权限验证&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;版本&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker version&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登陆&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker login&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登出&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker logout&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;docker远程访问&#34;&gt;Docker远程访问&lt;/h1&gt;
&lt;h1 id=&#34;docker-compose&#34;&gt;Docker-Compose&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Docker-Compose&lt;/code&gt; （docker编排）是 docker 提供的一个命令行工具，用来定义和运行由多个容器组成的应用。可以通过 docker-compose.yml 文件声明式的定义应用程序的各个服务，并由单个命令完成应用的创建和启动。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/compose/&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Docker-Compose&lt;/code&gt;将所管理的容器分为三层，分别是工程（project），服务（service）以及容器（container）。Docker-Compose运行目录下的所有文件（docker-compose.yml，extends文件或环境变量文件等）组成一个工程，若无特殊指定工程名即为当前目录名。一个工程当中可包含多个服务，每个服务中定义了容器运行的镜像，参数，依赖。一个服务当中可包括多个容器实例，Docker-Compose并没有解决负载均衡的问题，因此需要借助其它工具实现服务发现及负载均衡。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Nginx</title>
      <link>https://domyson.github.io/post/others/nginx/</link>
      <pubDate>Sat, 09 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/others/nginx/</guid>
      <description>&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Nginx功能丰富，可作为HTTP服务器，也可作为反向代理服务器，邮件服务器。支持FastCGI、SSL、Virtual Host、URL Rewrite、Gzip等功能。并且支持很多第三方的模块扩展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://nginx.org/en/download.html&#34;&gt;Nginx下载&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;常用功能&#34;&gt;常用功能&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;负载均衡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反向代理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;正向代理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件服务器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Markdown</title>
      <link>https://domyson.github.io/post/others/markdown/</link>
      <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/others/markdown/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://xianbai.me/learn-md/article/syntax/emphasis.html&#34;&gt;Link&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;目录&#34;&gt;目录&lt;/h1&gt;
&lt;p&gt;只能跳转标题，如果有同名标题与标题等级无关，匹配最优先的标题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E3%80%81%E6%A0%87%E9%A2%98&#34;&gt;标题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E3%80%81%E5%AD%97%E4%BD%93&#34;&gt;字体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E3%80%81%E5%BC%95%E7%94%A8&#34;&gt;引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B%E3%80%81%E5%88%86%E5%89%B2%E7%BA%BF&#34;&gt;分割线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%AD%E3%80%81%E8%B6%85%E9%93%BE%E6%8E%A5&#34;&gt;超链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%AB%E3%80%81%E8%A1%A8%E6%A0%BC&#34;&gt;表格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B9%9D%E3%80%81%E4%BB%A3%E7%A0%81&#34;&gt;代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E3%80%81%E6%B5%81%E7%A8%8B%E5%9B%BE&#34;&gt;流程图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E4%B8%80%E3%80%81%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE&#34;&gt;语法高亮&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E4%BA%8C%E3%80%81%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6&#34;&gt;转义字符&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>xLua</title>
      <link>https://domyson.github.io/post/unity/xlua/</link>
      <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/unity/xlua/</guid>
      <description>XLua XLua下载
配置文档
FAQ
标签 [Hotfix] 开启 HOTFIX_ENABLE 宏
通过热补丁的方式修复代码 xlua.hotfix函数
[LuaCallCsharp] 一个C#类型加了这个配置，xLua会生成这个类型的适配代码（包括构造该类型实例，访问其成员属性、方法，静态属性、方法），否则将会尝试用性能较低的反射方式来访问。
一个类型的扩展方法（Extension Methods）加了这配置，也会生成适配代码并追加到被扩展类型的成员方法上。
xLua只会生成加了该配置的类型，不会自动生成其父类的适配代码 ，当访问子类对象的父类方法，如果该父类加了LuaCallCSharp配置，则执行父类的适配代码，否则会尝试用反射来访问。
反射访问除了性能不佳之外，在 il2cpp 下还有可能因为代码剪裁而导致无法访问，
xLua 属性标签 [LuaCallCsharp] 来指明哪些类需要生成代码。
[LuaCallCsharp] public class A{ } 也可以在一个静态列表中通过标签一起生成
[LuaCallCSharp] public static List&amp;lt;Type&amp;gt; generate = new List&amp;lt;Type&amp;gt;() { typeof(GameObject), typeof(Dictionary&amp;lt;string, int&amp;gt;), }; 动态列表
public static List&amp;lt;Type&amp;gt; dynamic { get{ return ( from type in Assembly.Load(&amp;#34;Assmebly-CSharp&amp;#34;).GetTypes() where type.NameSpace == &amp;#34;XYZ&amp;#34; select type).ToList(); } } [ReflectionUse] 一个C#类型类型加了这个配置，xLua会生成link.xml阻止il2cpp的代码剪裁。
对于扩展方法，必须加上LuaCallCSharp或者ReflectionUse才可以被访问到。
建议所有要在Lua访问的类型，要么加LuaCallCSharp，要么加上ReflectionUse，这才能够保证在各平台都能正常运行。
[CSharpCallLua] 如果希望把一个lua函数适配到一个C# delegate（一类是C#侧各种回调：UI事件，delegate参数，比如List:ForEach；另外一类场景是通过 LuaTable的Get函数 指明一个lua函数绑定到一个delegate）。或者把一个lua table适配到一个C# interface，该delegate或者interface需要加上该配置。</description>
    </item>
    
    <item>
      <title>I/O</title>
      <link>https://domyson.github.io/post/linux/io/</link>
      <pubDate>Mon, 25 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/linux/io/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据的读取分为:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;等待数据准备&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待内核拷贝至用户空间&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本模型矩阵&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;阻塞&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;非阻塞&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;同步&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;Read/Write&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;Read\Write(O_NONBLOCK)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;异步&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;I/O multiplexing(select/poll)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;AIO&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://domyson.github.io/post/linux/file/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/linux/file/</guid>
      <description>Liunx 文件系统 对于 drwxr-xr-x 4 root root 4096 Nov 28 00:00 hook
文件类型 符号 描述 d 目录 l 符号链接 s 套接字文件 b 块设备文件 c 字符设备文件 p 命名管道文件 - 普通文件，不属于上述任意一种 权限更换 chmod [who] operator [permission] filename
who
符号 描述 u 文件属主权限 g 同组用户权限 o 其他用户权限 a 所有用户 operator
符号 描述 + 增加权限 - 取消权限 = 设定权限 permission
符号 描述 r 读权限 w 写权限 x 执行权限 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://domyson.github.io/post/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://domyson.github.io/post/readme/</guid>
      <description>About me 👋 I love games, I love coding, and I&amp;rsquo;m interested in games, computer principles, and operating systems.
I often use go,c, csharp,lua to develop some frameworks and tools, and now I am working on arm and rust.
I developed the service framework skynet-go(based on cgo) and the game framework Anywhere(based on Unity3d).
I also developed an register base scripting language (scriptc).
Also wrote a new coding protocol (kproto) which is faster than protobuf-v3.</description>
    </item>
    
  </channel>
</rss>
