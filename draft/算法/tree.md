---
title: Tree
date: 2019-09-02
tags: ["Tree"]
categories: ["算法"]
img: https://www.runoob.com/wp-content/uploads/2015/06/go128.png
toc: true
description: 二叉树
draft: false
---

# 树 `Tree`

## 定义

> 树（Tree）是n（n>=0)个结点的有限集。`n=0` 时称为空树。在任意一颗非空树中：

```
      A
     / \
    B   C
   /   / \
  D   E   F
 /|\   \
G H I   J
```

+ 有且仅有一个特定的称为根（Root）的结点；

+ 当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1、T2、......、Tn，其中每一个集合本身又是一棵树，并且称为根的子树。

+ n>0时根结点是唯一的，不可能存在多个根结点，数据结构中的树只能有一个根结点。

+ m>0时，子树的个数没有限制，但它们一定是互不相交的。
    

## 节点的度

> 节点又有子树数目成为节点的 `度`，如上图

```
             A -度2
            / \
           B   C -度2
          /   / \
   度3 - D   E   F - 度0
        /|\   \
       G H I   J
```

## 节点的深度

> 该节点的深度为 4

```
------------------------------
          A         第一层       
-------- /-\------------------
        B   C       第二层 
-------/---/-\----------------        
      D   E   F     第三层
-----/|\---\------------------            
    G H I   J       第四层
------------------------------
```
<!--more-->

# 二叉树 `BinaryTree`

## 定义

> 二叉树是n(n>=0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成。

```
          A
         / \
        B   C
       /   / \
      D   E   F
     / \   \
    G   H   J
       /
      I
```

## 特点

+ 每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。

+ 左子树和右子树是有顺序的，次序不能任意颠倒。

+ 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。

## 性质

+ 在二叉树的第i层上最多有2i-1 个节点 。（i>=1）

+ 二叉树中如果深度为k,那么最多有2^k-1个节点。(k>=1）

+ n0=n2+1 n0表示度数为0的节点数，n2表示度数为2的节点数。

+ 在完全二叉树中，具有n个节点的完全二叉树的深度为[log2n]+1，其中[log2n]是向下取整。

+ 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性：
    
    + 若 i=1，则该结点是二叉树的根，无双亲, 否则，编号为 [i/2] 的结点为其双亲结点;
    
    + 若 2i>n，则该结点无左孩子， 否则，编号为 2i 的结点为其左孩子结点；

    + 若 2i+1>n，则该结点无右孩子结点， 否则，编号为2i+1 的结点为其右孩子结点。

## 斜树

> 所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。

```
        A        A
       /          \
      B            C
     /              \
    D                F
   /
  G 
```

## 满二叉

> 在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。

```
        A
      /   \
     B     C
    / \   / \
   D   E F   G
```

### 特点

+ 叶子只能出现在最下一层。出现在其它层就不可能达成平衡。

+ 非叶子结点的度一定是2。

+ 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。


## 完全二叉树

> 对一颗具有n个结点的二叉树按层编号，如果编号为i(1<=i<=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向左对齐。则这棵二叉树称为完全二叉树。满二叉树一定是完全二叉树，但反过来不一定成立。

```
        A
      /   \
     B     C
    / \   /
   D   E F
```

### 特点

+ 叶子结点只能出现在最下层和次下层。

+ 最下层的叶子结点集中在树的左部。

+ 倒数第二层若存在叶子结点，一定在右部连续位置。

+ 如果结点度为1，则该结点只有左孩子，即没有右子树。

+ 同样结点数目的二叉树，完全二叉树深度最小。


## 二叉树的存储结构

### 顺序存储

> 当二叉树为完全二叉树时数组刚好填满，当二叉树不为完全二叉树时将会浪费空间，当出现极限情况时,如斜树，将浪费大量空间

```
              A1
            /     \
          B2      C3
        /   \    /  \
      D4   E5  F6   G7
     / \   /
    H8 I9 J10  

数组表示：
[A,B,C,D,E,F,G,H,I,J]

若 D、H、I 结点不存在时
[A,B,C,-,E,F,G,-,-,J]
```

#### 二叉链表

> 当二叉树不为完全二叉树时，可以考虑链式存储

```go
//树结构
type BinaryTree struct{
    val interface{}

    left,right *BinaryTree
}
```

## 二叉树遍历

### 前序遍历

> 从二叉树的根结点出发，当第一次到达结点时就输出结点数据，按照先向左在向右的方向访问。上图的遍历顺序为 `A、B、D、H、I、E、J、C、F、G`

```go
//前序遍历
func PreOrderTraverse(tree *BinaryTree){
    if tree == nil{
        return
    }
    fmt.Printf("%+v ",tree.val)
    PreOrderTraverse(tree.left)
    PreOrderTraverse(tree.right)
}
```

### 中序遍历

> 从二叉树的根结点出发，当第二次到达结点时就输出结点数据，按照先向左在向右的方向访问。上图的遍历顺序为 `H、D、I、B、J、E、A、F、C、G`

```go
//中序遍历
func InOrderTraverse(tree *BinaryTree){
    if tree == nil{
        return
    }
    InOrderTraverse(tree.left)
    fmt.Printf("%+v ",tree.val)
    InOrderTraverse(tree.right)
}
```

### 后序遍历

> 从二叉树的根结点出发，当第三次到达结点时就输出结点数据，按照先向左在向右的方向访问。上图的遍历顺序为 `H、I、D、J、E、B、F、G、C、A`

```go
//中序遍历
func PostOrderTraverse(tree *BinaryTree){
    if tree == nil{
        return
    }
    PostOrderTraverse(tree.left)
    PostOrderTraverse(tree.right)
    fmt.Printf("%+v ",tree.val)
}
```

### 层序遍历

> 层次遍历就是按照树的层次自上而下的遍历二叉树。上图的遍历顺序为 `A、B、D、E、C、F、G、H、I、J`

```go
func LayerOrderTraverse(tree,left,right *BinaryTree){
  
}
```

## 如何确定一个二叉树

+ 前序+中序 可确定唯一

+ 后序+中序 可确定唯一

+ 前序+后序 不可确定唯一


# B树

# B+树

# 红黑树