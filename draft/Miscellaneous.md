# a+=b,a=a+b

```go
var a int = 10

var b float32 = 11f

//如果是 a+=b 编译器不会报错,因为编译器自动将a（向上转换）转为float计算结果，然后再转为int

//如果是 a=a+b 编译器会报错，需要手动转换
```


# 逃逸分析

## 栈

    在程序中，每个函数块都会有自己的内存区域用来存自己的局部变量（内存占用少）、返回地址、返回值之类的数据，这一块内存区域有特定的结构和寻址方式，大小在编译时已经确定，寻址起来也十分迅速，开销很少。这一块内存地址称为栈。栈是线程级别的，大小在创建的时候已经确定，所以当数据太大的时候，就会发生"stack overflow"。

## 堆

    在程序中，全局变量、内存占用大的局部变量、发生了逃逸的局部变量存在的地方就是堆，这一块内存没有特定的结构，也没有固定的大小，可以根据需要进行调整。简单来说，有大量数据要存的时候，就存在堆里面。堆是进程级别的。当一个变量需要分配在堆上的时候，开销会比较大，对于go这种带GC的语言来说，也会增加gc压力，同时也容易造成内存碎片。


## 为何分为堆栈

```c
int* f1(){
    int i = 5;
    return &i;
}

int main(){
    int *i = f1();
    *i = 6;
    return 0;
}
/*
这时候程序结果是无法预期的，因为在函数f1中，i是一个局部变量，会分配在栈上，而栈在函数返回之后就失效了(Plan9 汇编中SP指针被修改)，于是i的地址所存的值是不可预期的，后续在main中对返回的i的地址中的值的修改可能会修改掉程序运行的数据，造成结果无法预期。

所以对于需要返回一个地址回去的情况，在C++中需要用new来分配一块堆上的内存才行，因为堆是进程级别的，也就是全局的，除非程序猿手动释放，否则不会被回收（释放不好会段错误，忘了释放会内存泄漏），于是就可以使得这个地址不会再被使用到，可以安全地返回。

不要返回局部变量的指针或引用。 不要返回类成员变量的句柄，以保证对象不会被意外修改。
*/
```


## 如何进行逃逸分析

>golang逃逸分析最基本的原则是：如果一个函数返回的是一个（局部）变量的地址，那么这个变量就发生逃逸。但是变量的分配在何处与new无关。

```go
// src/main.go
package main

func main(){
	a := f1()
	*a++
}

//go:noinline 禁止编译器将此函数内联
func f1() *int{
	i:=1
	return &i
}

/*
$ go build -gcflags '-m' src/main.go
# command-line-arguments
src\main.go:3:6: can inline main
src\main.go:11:9: &i escapes to heap  代表了局部变量i被分配到了堆上
src\main.go:10:2: moved to heap: i
*/
```