<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Zen on 朝花夕拾</title>
    <link>https://domyson.github.io/categories/zen/</link>
    <description>Recent content in Zen on 朝花夕拾</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 01 Apr 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://domyson.github.io/categories/zen/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Beam</title>
      <link>https://domyson.github.io/post/zen/2/</link>
      <pubDate>Sat, 01 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/zen/2/</guid>
      <description>&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;Beam&lt;/code&gt; 是一个全自动化，且简单易用的资源管理系统, 它只提供资源的加载和管理方式，不提供资源的解析方式，意味这它是可以跨引擎使用，这里只指出它在&lt;code&gt;Unity&lt;/code&gt;中的部分，他本身只会管理文件的依赖 （manifest）以及&#xA;文件句柄资源 （在 C++ 中叫 fd，在C#中成为 FileStream）&lt;/p&gt;&#xA;&lt;h1 id=&#34;feature&#34;&gt;Feature&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;自动化检测文件变动&#xA;通过&lt;code&gt;Radix&lt;/code&gt;算法，监控资源变动，来自动构建&lt;code&gt;manifest&lt;/code&gt;。上层只需要关注资源本身，无需关注&lt;code&gt;AssetBundle&lt;/code&gt;包的构建。可做到对上层完全无感。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;自动化引用计数&#xA;通过 &lt;code&gt;RC&lt;/code&gt;+ finalizer，监控资源的引用，来自动释放资源。且无需轮询检查资源的引用计数，提供更好的性能，做到对上层完全无感。也没有手动释放接口，提高安全性和易用性&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;自动化冗余剔除&#xA;在构建的时候自动收集冗余资源，如像A-&amp;gt;(C,D) B-&amp;gt;(C) 此时(A,D)将会作为一个的bundle，而C则会单独作为一个bundle&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Profile资源使用分析，用以在运行时统计各个资源的引用和加载数&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;自定义流处理，支持加密等自定义操作&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;多种模式支持&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Builtin: 内建资源，默认将资源插入母包中。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Remote: 远程资源模式，仅需要配置远程资源地址即可，所有资源不会在本地存盘，只会在内存中使用，使用完后立即释放，防止被反编译资源&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;无感知资源更新&#xA;一般出现资源更新的时候，都是先下载到本地，然后再通过加载本地资源的方式实现， 现由&lt;code&gt;FS&lt;/code&gt;映射的远程目录，通过分流的方式，可以实现一边从远程直接读取，并copy另外一部分流到本地磁盘，减少重新读盘的情况。&#xA;对于下载过程对于玩家而言完全无感，其本身下载速度是可以被控制，当前并没有暴露此接口（因为带宽值是动态变化的，无法根据不同的条件找到一个合理值），只是需要设定一个百分率阈值，内部自动计算下载速度尽可能保证达到预期值。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;淘汰策略&#xA;当某个Assetbundle的引用计数为0时候，底层不会立即释放它，基于引用计数+ LRU 淘汰机制，当然也提供了强制卸载函数。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;后续计划&#34;&gt;后续计划&lt;/h1&gt;&#xA;&lt;p&gt;&lt;del&gt;现阶段&lt;code&gt;Resource&lt;/code&gt;是依赖于&lt;code&gt;Assetbundle&lt;/code&gt; 后续会抽象出一层 &lt;code&gt;FS&lt;/code&gt; 以提供自定义流提供更多可操作性和安全性。&lt;/del&gt; 已实现&lt;/p&gt;&#xA;&lt;p&gt;&lt;del&gt;&lt;code&gt;Resource&lt;/code&gt;现在可以说是完全不能脱离&lt;code&gt;Unity&lt;/code&gt;独立运行，这不是一个好的方式，我期望提供更高的抽象满足多个引擎的需求。当完成这一步时只需要在&lt;code&gt;Unity&lt;/code&gt;中需要手动实现一个&lt;code&gt;Adaptor&lt;/code&gt;即可。&lt;/del&gt;&lt;/p&gt;&#xA;&lt;script async src=&#34;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7934154300350596&#34;&#xA;     crossorigin=&#34;anonymous&#34;&gt;&lt;/script&gt;&#xA;&#xA;&lt;ins class=&#34;adsbygoogle&#34;&#xA;     style=&#34;display:block&#34;&#xA;     data-ad-client=&#34;ca-pub-7934154300350596&#34;&#xA;     data-ad-slot=&#34;3469296166&#34;&#xA;     data-ad-format=&#34;auto&#34;&#xA;     data-full-width-responsive=&#34;true&#34;&gt;&lt;/ins&gt;&#xA;&lt;script&gt;&#xA;     (adsbygoogle = window.adsbygoogle || []).push({});&#xA;&lt;/script&gt;</description>
    </item>
    <item>
      <title>datatable</title>
      <link>https://domyson.github.io/post/zen/3/</link>
      <pubDate>Sat, 01 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/zen/3/</guid>
      <description>&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;DatatableModule&lt;/code&gt; 是一个基于 &lt;a href=&#34;https://domyson.github.io/post/kproto&#34;&gt;kpb&lt;/a&gt; 编码的配置文件管理系统,它定义了一个配置文件的数据结构，并提供了相应的API来操作和访问配置文件。在&lt;code&gt;Zen&lt;/code&gt;中它是一个&lt;code&gt;GameComponent&lt;/code&gt;。它包含了一个代码生成器，和数据解析器和编码器。&lt;/p&gt;&#xA;&lt;p&gt;数据表的加载只有4(2)个接口  &lt;code&gt;LoadDatatable&amp;lt;T&amp;gt;(bool lazy)&lt;/code&gt; &lt;code&gt;GetRow&amp;lt;T&amp;gt;(int row)&lt;/code&gt; 以及一套同作用的异步接口，前者获取一整张表，后者获取某表的某一行数据，即对应的数据结构体。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Datatable&lt;/code&gt; 静默行为是 &lt;code&gt;Lazy load&lt;/code&gt; 对于同一张数据表，它只会根据需要读取指定行然后才缓存，而不是一次性读取所有表格。&lt;/p&gt;&#xA;&lt;h1 id=&#34;feature&#34;&gt;Feature&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;lazy load&lt;/code&gt;,它不会加载表格的所有数据，而是按照需要动态一部分一部分的加载，直到全部加载完毕。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;DatatableModule&lt;/code&gt; 加载接口提供同步和异步两种模式，也可以加载远程资源，依赖于 &lt;a href=&#34;https://domyson.github.io/post/Zen/2&#34;&gt;Resource&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;DatatableModule&lt;/code&gt; 提供代码和数据生成的编辑器，无需关注实现逻辑。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;多种类型数据支持 &lt;code&gt;bool,int,float,string,binary,int*,float*,string*&lt;/code&gt;,满足绝大部分场景&#xA;（2024/05/23）增加了定长数据的支持，减少内存消耗。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;基于&lt;code&gt;kproto&lt;/code&gt;编码协议，极小的二进制文件，以及极快的编解码速度。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;栈内存映射，大部分情况下不需要开辟堆空间，节省一部分堆内存的分配，减少&lt;code&gt;Mono Reserved&lt;/code&gt;的分配。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;script async src=&#34;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7934154300350596&#34;&#xA;     crossorigin=&#34;anonymous&#34;&gt;&lt;/script&gt;&#xA;&#xA;&lt;ins class=&#34;adsbygoogle&#34;&#xA;     style=&#34;display:block&#34;&#xA;     data-ad-client=&#34;ca-pub-7934154300350596&#34;&#xA;     data-ad-slot=&#34;3469296166&#34;&#xA;     data-ad-format=&#34;auto&#34;&#xA;     data-full-width-responsive=&#34;true&#34;&gt;&lt;/ins&gt;&#xA;&lt;script&gt;&#xA;     (adsbygoogle = window.adsbygoogle || []).push({});&#xA;&lt;/script&gt;</description>
    </item>
    <item>
      <title>EntityManager</title>
      <link>https://domyson.github.io/post/zen/5/</link>
      <pubDate>Sat, 01 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/zen/5/</guid>
      <description>&lt;p&gt;&lt;code&gt;EntityManager&lt;/code&gt;是一个很重要的模块，像游戏开发本身是基于视觉感知，而&lt;code&gt;EntityManager&lt;/code&gt;是对所有场景物体的统一抽象封装, 并提供一系列通用操作，&lt;code&gt;EntityManager&lt;/code&gt; 本身是一个抽象类，提供了一定程度的通用性操作，但针对一些特殊情况我们还是需要针对特定问题特定实现（千万不想要想着做平，来自某家公司的教训:)）&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;EntityManager&lt;/code&gt; 附带一个默认的 &lt;code&gt;EntityController&lt;/code&gt;,提供一些常规的实体控制，像 &lt;code&gt;Zen&lt;/code&gt;的UI框架就是基于 &lt;code&gt;EntityManager&lt;/code&gt;的一个具体实现。&lt;/p&gt;&#xA;&lt;h1 id=&#34;entity&#34;&gt;Entity&lt;/h1&gt;&#xA;&lt;p&gt;抽象描述一个物体的实体，它的生命周期函数定义类似于&lt;code&gt;GameComponent&lt;/code&gt;,但是它的调度不由&lt;code&gt;GameEntry&lt;/code&gt;而是 &lt;code&gt;GameComponent&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;简单来说，要创建一个物体首先我们需要定义它的逻辑模板（骨架）以及它的数据（描述）&lt;/p&gt;&#xA;&lt;p&gt;举个例子&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;EnemyData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IEntityData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 对于实体数据接口，资源名必不可少&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Assets&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;OnCtor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 有些时候，实体的数据更关卡等级或这地图这类外部数据挂钩，可能需要在这里动态设置一次&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 定义Entity的逻辑模板&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Enemy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Entity&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;EnemyData&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;userdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;OnCtor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// init setup...&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;     &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;OnUpdate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;unscaleDelta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// loop logic.&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dosomething&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 直接在默认的EntityManager中创建一个实体&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;GameEntry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GetComponent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EntityManager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;().&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Enemy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;EnemyData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于实体的销毁，像敌人死亡，特效消失之类的，仅仅只需要设置一个 &lt;code&gt;Alive&lt;/code&gt; 属性，即可完成，生命周期由&lt;code&gt;EntityManger&lt;/code&gt;自行决断。&lt;/p&gt;&#xA;&lt;p&gt;需要注意的是 继承&lt;code&gt;IEntityData&lt;/code&gt;的数据模板是会一直复用的，它与 &lt;code&gt;Entity&lt;/code&gt;的复用规则不同，后者复用的是&lt;code&gt;Entity&lt;/code&gt;所持有的实体，因为它本身只是一系列函数集合且很少会带有数据并不会占用太多的内存，而前者大部分情况下是都是通过读表获取，复杂的实体数据可能会导致内存异常大，所以保留实体数据是&lt;code&gt;EntityManager&lt;/code&gt;的默认行为。&lt;/p&gt;&#xA;&lt;h1 id=&#34;entitysettings&#34;&gt;EntitySettings&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;EntityManager&lt;/code&gt;可能需要在某些大量对象时使用对象池（&lt;code&gt;Entity&lt;/code&gt;），或者内存池(&lt;code&gt;EntityData&lt;/code&gt;),但在大多数情况下，框架并不清楚是否需要对象池，或者是需要一个定长周期的物体（子弹或者特效）。&lt;/p&gt;&#xA;&lt;p&gt;这个时候需要设置就非常有必要了，可以决断出是否需要且生命周期（keepalive）或者是需要多大的对象池，以及自动孵化的频率了。&lt;/p&gt;&#xA;&lt;script async src=&#34;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7934154300350596&#34;&#xA;     crossorigin=&#34;anonymous&#34;&gt;&lt;/script&gt;&#xA;&#xA;&lt;ins class=&#34;adsbygoogle&#34;&#xA;     style=&#34;display:block&#34;&#xA;     data-ad-client=&#34;ca-pub-7934154300350596&#34;&#xA;     data-ad-slot=&#34;3469296166&#34;&#xA;     data-ad-format=&#34;auto&#34;&#xA;     data-full-width-responsive=&#34;true&#34;&gt;&lt;/ins&gt;&#xA;&lt;script&gt;&#xA;     (adsbygoogle = window.adsbygoogle || []).push({});&#xA;&lt;/script&gt;</description>
    </item>
    <item>
      <title>Zen Gameplay Framework</title>
      <link>https://domyson.github.io/post/zen/0/</link>
      <pubDate>Sat, 01 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/zen/0/</guid>
      <description>&lt;h1 id=&#34;序&#34;&gt;序&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;Zen&lt;/code&gt; 是一个基于 Unity 引擎的&lt;code&gt;GamePlay&lt;/code&gt;框架，脱离 &lt;code&gt;Monobehaviour&lt;/code&gt; 开发，致力简化开发流程。内部提供了一个类&lt;code&gt;ECS&lt;/code&gt;的架构满足开发，你也可以使用自定义的上层，比如自己实现像&lt;code&gt;MVCC&lt;/code&gt;，或者是&lt;code&gt;MVC&lt;/code&gt;的上层封装。让开发聚焦在游戏玩法而非一些底层架构上。同时也&#xA;提供一些自定义性，不至于给予开发者太强约束性&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Zen的一些设计思想不算是纯粹的&lt;code&gt;OOP&lt;/code&gt;，它有ECS的概念，也有&lt;code&gt;type embedding&lt;/code&gt;的概念，而且设计概念大部分是参考面过过程和内嵌的设计思想，所以理解曲线会比较困难，但是用起来还是挺 easy。&lt;/p&gt;&lt;/blockquote&gt;</description>
    </item>
  </channel>
</rss>
