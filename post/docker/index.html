<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script type="application/javascript" src='https://domyson.github.io/js/theme-mode.js'></script>
    <link rel="stylesheet" href='https://domyson.github.io/css/frameworks.min.css' />
    <link rel="stylesheet" href='https://domyson.github.io/css/github.min.css' />
    <link rel="stylesheet" href='https://domyson.github.io/css/github-style.css' />
    <link rel="stylesheet" href='https://domyson.github.io/css/light.css' />
    <link rel="stylesheet" href='https://domyson.github.io/css/dark.css' />
    <link rel="stylesheet" href='https://domyson.github.io/css/syntax.css' />
    <title>Docker - 朝花夕拾</title>
    
    <link rel="icon" type="image/x-icon" href='/images/avatar.png'>
    
    <meta name="theme-color" content="#1e2327">

    
    <meta name="description"
  content="什么是docker Docker 是一个开源的容器引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者和系统管理员在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括 VMs（虚拟机）、bare metal、OpenStack 集群、云端、数据中心和其他的基础应用平台。容器是完全使用沙箱机制，相互之间不会有任何接口。
有什么优势 轻量，在一台机器上运行的多个Docker容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。
标准，Docker 容器基于开放式标准，能够在所有主流Linux版本、Microsoft Windows以及包括VM、裸机服务器和云在内的任何基础设施上运行。
安全，Docker 赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。
一次发布，到处使用
Docker和虚拟机 容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。
传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。
特性 容器 虚拟机 启动 秒级 分钟级 硬盘 MB GB 性能 接近原生 弱于原生 支持量 单机上千 单机几十左右 容器是一个应用层抽象，用于将代码和依赖资源打包在一起。 多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行 。与虚拟机相比， 容器占用的空间较少（容器镜像大小通常只有几十兆），瞬间就能完成启动。
虚拟机（VM）是一个物理硬件层抽象，用于将一台服务器变成多台服务器。 管理程序允许多个VM在一台机器上运行。每个VM都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此占用大量空间。而且VM启动也十分缓慢 。
虚拟机更擅长于彻底隔离整个运行环境。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而 Docker 通常用于隔离不同的应用 ，例如前端，后端以及数据库。
Docker基本组成 镜像 （Image）
容器（Container）
仓库（Repository）
镜像（Image）—— 一个特殊的文件系统 操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像（Image），就相当于是一个root文件系统。Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 镜像不包含任何动态数据，其内容在构建之后也不会被改变。Docker设计时，就充分利用Union FS的技术，将其设计为分层存储的架构。 镜像实际是由多层文件系统联合组成。镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。
容器（Container）—— 镜像运行时的实体 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。前面讲过镜像使用的是分层存储，容器也是如此。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。按照Docker最佳实践的要求，容器不应该向其存储层内写入任何数据 ，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， 使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。
仓库（Repository）—— 集中存放镜像文件的地方 镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。一个Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。所以说：镜像仓库是Docker用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过&amp;lt;仓库名&amp;gt;:&amp;lt;标签&amp;gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以latest作为默认标签。
Docker Registry公开服务和私有Docker Registry Docker Registry公开服务是开放给用户使用、允许用户管理镜像的Registry服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。最常使用的Registry公开服务是官方的Docker Hub ，这也是默认的Registry，并拥有大量的高质量的官方镜像，网址为：hub.docker.com/ 。在国内访问Docker Hub可能会比较慢国内也有一些云服务商提供类似于Docker Hub的公开服务。除了使用公开服务外，用户还可以在本地搭建私有Docker Registry 。Docker官方提供了Docker Registry镜像，可以直接使用做为私有Registry服务。开源的Docker Registry镜像只提供了Docker Registry API的服务端实现，足以支持Docker命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。
Image 查看、拉取、删除 搜索镜像
docker search name[:tag]
拉取镜像,若不指定tag则默认拉取latest
docker pull name[:tag]
查看本地所有镜像
docker images
删除镜像，可以多个删除
docker rmi [option] image ... -f 强制删除 制作、推送 在指定路径中找到 Dockerfile 并构建Image, 后面是路径，但路径中必须存在 Dockerfile
docker build -t [:namespace]/name:tag Path
给镜像赋予新的标签, namespace 必须为 dockerid，除非另外购买。
docker tag oldname:oldtag namespace/newname:newtag
将镜像上传至 docker 仓库 DockerHub 上,namespace 必须是用户名,也可以上传至 Gitlab
docker push namespace/name:tag
docker
提交修改的镜像
docker commit [-a] [-m] CONTAINER [REPOSITORY[:TAG]]
-a 指明提交者
-m 提交信息
在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。 此方式更新的镜像有依赖通过 docker save -o dst [REPOSITORY[:TAG]]存盘,删除所有镜像,再通过 docker load -i path 加载新镜像。
Container 查看容器 docker ps [-a|-s]
-a 查看所有容器。
-s 查看已启动的容器。
产看容器进程 docker top containerID
移除容器 可以多个同时删除
docker rm container ... [option]
-f : 强制删除容器。
-v : 若删除容器则数据卷也删除。
停止容器 可以同时停止多个
docker stop container ...
启动容器 docker run [:--name] [:-e] [:-v] [:-h] [:--net] [:-p prot0:prot1] [:-d|-i] [:-t] [:--rm] [:--restart] [:--privileged=false] [:--ip] [:--network=] name:tag [:shell]
run 命令将会启动 dockerfile 中定义的 CMD 或 ENTRYPOINT 指令。
--name=xxx 指定容器运行时的名称，可不选，默认为随机字符。
-p Host0:Host1 表示本地 Host0 映射容器 Host1 端口,若为 -P 则随机映射49000 ~ 49900 端口。
-d：分离模式: 在后台运行。
-h：指定主机域名。如 -h domyson.cn。
-e：为 dockerfile 中的 ENV 的参数变量,设置环境变量，或者覆盖已存在的环境变量 -e TZ=&amp;quot;Asia/Shanghai&amp;quot; 设置时区为上海。
-u：指定执行用户，一般为 root。
--rm：停止容器就移除。
-it: 以交互模式运行容器 (不同于 -d : 以分离模式运行容器),这意味着交互回话 session 结束时,容器就会停止运行，与 -d 互斥。
-v : 容器内创建一个数据卷。多次重复使用 -v 标记可以创建多个数据卷，也可以挂载一个主机目录作为数据卷 path0:path1(其中path0是主机目录，path1是容器目录)。
--link container : 连接到其他容器。 这个方法以后将被弃用，推荐使用 --network
--network NETWORK：指定连接到的网络。
--ip：指定容器的ip。
--restart：no、on-failure:n、always 设置容器自动重启模式，若容器已经启动，可以通过 docker update --restart args 来设置参数。
--privileged：真正给予 Container 中 root 用户 root权限，否则 root 只是一个普通用户。
shell：指定交互的方式，一般为bash bash -c &amp;quot;cmd string&amp;quot;，这条命令将由启动容器执行。
查看容器日志 docker logs [opt] CONTAINER
-f : 跟踪日志输出
--since :显示某个开始时间的所有日志
-t : 显示时间戳
--tail N :仅列出最新N条容器日志
进入指定容器 docker exec [opt] CONTAINER shell [:args]
-d ：分离模式: 在后台运行
-it：以交互模式运行容器 (不同于 -d : 以分离模式运行容器),这意味着交互回话 session 结束时,容器就会停止运行。与 -d 互斥
-u：指定运行用户,一般设置为 root
进入容器内部之后，通过 exit 退出
容器通讯方式 See DockerNetwork
镜像体积优化 Docker 由多个 Layers 组成（上限是127层）。而 Dockerfile 每一条指令都会创建一层 Layers。
优化基础镜像 使用 Alpine 基础镜像
Alpine是一个高度精简又包含了基本工具的轻量级Linux发行版，基础镜像仅 4.41MB
使用 scratch 基础镜像
scratch是一个空镜像，只能用于构建其他镜像
使用 busybox 基础镜像
如果希望镜像里可以包含一些常用的Linux工具，busybox镜像是个不错选择，镜像本身只有1.16M，非常便于构建小镜像。
串联 Dockerfile 指令 通过 &amp;amp;&amp;amp; 和 \ 将多个 Run 命令合并成一个
多段构建 待完善
Docker数据卷 数据卷可以在容器之间共享和重用 对数据卷的修改会立马生效 对数据卷的更新，不会影响镜像 数据卷默认会一直存在，即使容器被删除 创建数据卷 在 run 命令中 -v /data 标记来创建一个数据卷并挂载到容器里。在一次 run 中多次使用可以挂载多个数据卷。(创建一个容器，并加载一个数据卷到容器的 /data 目录) 也可以在 Dockerfile 中使用 VOLUME 来添加一个或者多个新的卷到由该镜像创建的任意容器。 删除数据卷 数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。无主的数据卷可能会占据很多空间，要清理会很麻烦。 挂载一个主机目录作为数据卷 docker run -d -P --name web -v /src/webapp:/opt/webapp[:权限] 上面的命令加载主机的 /src/webapp 目录到容器的 /opt/webapp 目录，默认权限是读写，也可以指定为只读(ro) --volumes-from 在run的时候指定数据卷容器 查看数据卷的信息
docker inspect contianerID
查看所有数据卷
docker volume ls
清除所有无主数据卷
docker volume prune
Docker权限验证 版本
docker version
登陆
docker login
登出
docker logout
Docker远程访问 Docker-Compose Docker-Compose （docker编排）是 docker 提供的一个命令行工具，用来定义和运行由多个容器组成的应用。可以通过 docker-compose.yml 文件声明式的定义应用程序的各个服务，并由单个命令完成应用的创建和启动。
官方文档
Docker-Compose将所管理的容器分为三层，分别是工程（project），服务（service）以及容器（container）。Docker-Compose运行目录下的所有文件（docker-compose.yml，extends文件或环境变量文件等）组成一个工程，若无特殊指定工程名即为当前目录名。一个工程当中可包含多个服务，每个服务中定义了容器运行的镜像，参数，依赖。一个服务当中可包括多个容器实例，Docker-Compose并没有解决负载均衡的问题，因此需要借助其它工具实现服务发现及负载均衡。
" />
<meta name="keywords"
  content='computer tech' />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://domyson.github.io/post/docker/" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Docker - 朝花夕拾" />
<meta name="twitter:description"
  content="什么是docker Docker 是一个开源的容器引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者和系统管理员在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括 VMs（虚拟机）、bare metal、OpenStack 集群、云端、数据中心和其他的基础应用平台。容器是完全使用沙箱机制，相互之间不会有任何接口。
有什么优势 轻量，在一台机器上运行的多个Docker容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。
标准，Docker 容器基于开放式标准，能够在所有主流Linux版本、Microsoft Windows以及包括VM、裸机服务器和云在内的任何基础设施上运行。
安全，Docker 赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。
一次发布，到处使用
Docker和虚拟机 容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。
传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。
特性 容器 虚拟机 启动 秒级 分钟级 硬盘 MB GB 性能 接近原生 弱于原生 支持量 单机上千 单机几十左右 容器是一个应用层抽象，用于将代码和依赖资源打包在一起。 多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行 。与虚拟机相比， 容器占用的空间较少（容器镜像大小通常只有几十兆），瞬间就能完成启动。
虚拟机（VM）是一个物理硬件层抽象，用于将一台服务器变成多台服务器。 管理程序允许多个VM在一台机器上运行。每个VM都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此占用大量空间。而且VM启动也十分缓慢 。
虚拟机更擅长于彻底隔离整个运行环境。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而 Docker 通常用于隔离不同的应用 ，例如前端，后端以及数据库。
Docker基本组成 镜像 （Image）
容器（Container）
仓库（Repository）
镜像（Image）—— 一个特殊的文件系统 操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像（Image），就相当于是一个root文件系统。Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 镜像不包含任何动态数据，其内容在构建之后也不会被改变。Docker设计时，就充分利用Union FS的技术，将其设计为分层存储的架构。 镜像实际是由多层文件系统联合组成。镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。
容器（Container）—— 镜像运行时的实体 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。前面讲过镜像使用的是分层存储，容器也是如此。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。按照Docker最佳实践的要求，容器不应该向其存储层内写入任何数据 ，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， 使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。
仓库（Repository）—— 集中存放镜像文件的地方 镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。一个Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。所以说：镜像仓库是Docker用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过&amp;lt;仓库名&amp;gt;:&amp;lt;标签&amp;gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以latest作为默认标签。
Docker Registry公开服务和私有Docker Registry Docker Registry公开服务是开放给用户使用、允许用户管理镜像的Registry服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。最常使用的Registry公开服务是官方的Docker Hub ，这也是默认的Registry，并拥有大量的高质量的官方镜像，网址为：hub.docker.com/ 。在国内访问Docker Hub可能会比较慢国内也有一些云服务商提供类似于Docker Hub的公开服务。除了使用公开服务外，用户还可以在本地搭建私有Docker Registry 。Docker官方提供了Docker Registry镜像，可以直接使用做为私有Registry服务。开源的Docker Registry镜像只提供了Docker Registry API的服务端实现，足以支持Docker命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。
Image 查看、拉取、删除 搜索镜像
docker search name[:tag]
拉取镜像,若不指定tag则默认拉取latest
docker pull name[:tag]
查看本地所有镜像
docker images
删除镜像，可以多个删除
docker rmi [option] image ... -f 强制删除 制作、推送 在指定路径中找到 Dockerfile 并构建Image, 后面是路径，但路径中必须存在 Dockerfile
docker build -t [:namespace]/name:tag Path
给镜像赋予新的标签, namespace 必须为 dockerid，除非另外购买。
docker tag oldname:oldtag namespace/newname:newtag
将镜像上传至 docker 仓库 DockerHub 上,namespace 必须是用户名,也可以上传至 Gitlab
docker push namespace/name:tag
docker
提交修改的镜像
docker commit [-a] [-m] CONTAINER [REPOSITORY[:TAG]]
-a 指明提交者
-m 提交信息
在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。 此方式更新的镜像有依赖通过 docker save -o dst [REPOSITORY[:TAG]]存盘,删除所有镜像,再通过 docker load -i path 加载新镜像。
Container 查看容器 docker ps [-a|-s]
-a 查看所有容器。
-s 查看已启动的容器。
产看容器进程 docker top containerID
移除容器 可以多个同时删除
docker rm container ... [option]
-f : 强制删除容器。
-v : 若删除容器则数据卷也删除。
停止容器 可以同时停止多个
docker stop container ...
启动容器 docker run [:--name] [:-e] [:-v] [:-h] [:--net] [:-p prot0:prot1] [:-d|-i] [:-t] [:--rm] [:--restart] [:--privileged=false] [:--ip] [:--network=] name:tag [:shell]
run 命令将会启动 dockerfile 中定义的 CMD 或 ENTRYPOINT 指令。
--name=xxx 指定容器运行时的名称，可不选，默认为随机字符。
-p Host0:Host1 表示本地 Host0 映射容器 Host1 端口,若为 -P 则随机映射49000 ~ 49900 端口。
-d：分离模式: 在后台运行。
-h：指定主机域名。如 -h domyson.cn。
-e：为 dockerfile 中的 ENV 的参数变量,设置环境变量，或者覆盖已存在的环境变量 -e TZ=&amp;quot;Asia/Shanghai&amp;quot; 设置时区为上海。
-u：指定执行用户，一般为 root。
--rm：停止容器就移除。
-it: 以交互模式运行容器 (不同于 -d : 以分离模式运行容器),这意味着交互回话 session 结束时,容器就会停止运行，与 -d 互斥。
-v : 容器内创建一个数据卷。多次重复使用 -v 标记可以创建多个数据卷，也可以挂载一个主机目录作为数据卷 path0:path1(其中path0是主机目录，path1是容器目录)。
--link container : 连接到其他容器。 这个方法以后将被弃用，推荐使用 --network
--network NETWORK：指定连接到的网络。
--ip：指定容器的ip。
--restart：no、on-failure:n、always 设置容器自动重启模式，若容器已经启动，可以通过 docker update --restart args 来设置参数。
--privileged：真正给予 Container 中 root 用户 root权限，否则 root 只是一个普通用户。
shell：指定交互的方式，一般为bash bash -c &amp;quot;cmd string&amp;quot;，这条命令将由启动容器执行。
查看容器日志 docker logs [opt] CONTAINER
-f : 跟踪日志输出
--since :显示某个开始时间的所有日志
-t : 显示时间戳
--tail N :仅列出最新N条容器日志
进入指定容器 docker exec [opt] CONTAINER shell [:args]
-d ：分离模式: 在后台运行
-it：以交互模式运行容器 (不同于 -d : 以分离模式运行容器),这意味着交互回话 session 结束时,容器就会停止运行。与 -d 互斥
-u：指定运行用户,一般设置为 root
进入容器内部之后，通过 exit 退出
容器通讯方式 See DockerNetwork
镜像体积优化 Docker 由多个 Layers 组成（上限是127层）。而 Dockerfile 每一条指令都会创建一层 Layers。
优化基础镜像 使用 Alpine 基础镜像
Alpine是一个高度精简又包含了基本工具的轻量级Linux发行版，基础镜像仅 4.41MB
使用 scratch 基础镜像
scratch是一个空镜像，只能用于构建其他镜像
使用 busybox 基础镜像
如果希望镜像里可以包含一些常用的Linux工具，busybox镜像是个不错选择，镜像本身只有1.16M，非常便于构建小镜像。
串联 Dockerfile 指令 通过 &amp;amp;&amp;amp; 和 \ 将多个 Run 命令合并成一个
多段构建 待完善
Docker数据卷 数据卷可以在容器之间共享和重用 对数据卷的修改会立马生效 对数据卷的更新，不会影响镜像 数据卷默认会一直存在，即使容器被删除 创建数据卷 在 run 命令中 -v /data 标记来创建一个数据卷并挂载到容器里。在一次 run 中多次使用可以挂载多个数据卷。(创建一个容器，并加载一个数据卷到容器的 /data 目录) 也可以在 Dockerfile 中使用 VOLUME 来添加一个或者多个新的卷到由该镜像创建的任意容器。 删除数据卷 数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。无主的数据卷可能会占据很多空间，要清理会很麻烦。 挂载一个主机目录作为数据卷 docker run -d -P --name web -v /src/webapp:/opt/webapp[:权限] 上面的命令加载主机的 /src/webapp 目录到容器的 /opt/webapp 目录，默认权限是读写，也可以指定为只读(ro) --volumes-from 在run的时候指定数据卷容器 查看数据卷的信息
docker inspect contianerID
查看所有数据卷
docker volume ls
清除所有无主数据卷
docker volume prune
Docker权限验证 版本
docker version
登陆
docker login
登出
docker logout
Docker远程访问 Docker-Compose Docker-Compose （docker编排）是 docker 提供的一个命令行工具，用来定义和运行由多个容器组成的应用。可以通过 docker-compose.yml 文件声明式的定义应用程序的各个服务，并由单个命令完成应用的创建和启动。
官方文档
Docker-Compose将所管理的容器分为三层，分别是工程（project），服务（service）以及容器（container）。Docker-Compose运行目录下的所有文件（docker-compose.yml，extends文件或环境变量文件等）组成一个工程，若无特殊指定工程名即为当前目录名。一个工程当中可包含多个服务，每个服务中定义了容器运行的镜像，参数，依赖。一个服务当中可包括多个容器实例，Docker-Compose并没有解决负载均衡的问题，因此需要借助其它工具实现服务发现及负载均衡。
" />
<meta name="twitter:site" content="https://domyson.github.io/" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image"
  content="https://domyson.github.io/">


<meta property="og:type" content="article" />
<meta property="og:title" content="Docker - 朝花夕拾">
<meta property="og:description"
  content="什么是docker Docker 是一个开源的容器引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者和系统管理员在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括 VMs（虚拟机）、bare metal、OpenStack 集群、云端、数据中心和其他的基础应用平台。容器是完全使用沙箱机制，相互之间不会有任何接口。
有什么优势 轻量，在一台机器上运行的多个Docker容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。
标准，Docker 容器基于开放式标准，能够在所有主流Linux版本、Microsoft Windows以及包括VM、裸机服务器和云在内的任何基础设施上运行。
安全，Docker 赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。
一次发布，到处使用
Docker和虚拟机 容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。
传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。
特性 容器 虚拟机 启动 秒级 分钟级 硬盘 MB GB 性能 接近原生 弱于原生 支持量 单机上千 单机几十左右 容器是一个应用层抽象，用于将代码和依赖资源打包在一起。 多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行 。与虚拟机相比， 容器占用的空间较少（容器镜像大小通常只有几十兆），瞬间就能完成启动。
虚拟机（VM）是一个物理硬件层抽象，用于将一台服务器变成多台服务器。 管理程序允许多个VM在一台机器上运行。每个VM都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此占用大量空间。而且VM启动也十分缓慢 。
虚拟机更擅长于彻底隔离整个运行环境。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而 Docker 通常用于隔离不同的应用 ，例如前端，后端以及数据库。
Docker基本组成 镜像 （Image）
容器（Container）
仓库（Repository）
镜像（Image）—— 一个特殊的文件系统 操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像（Image），就相当于是一个root文件系统。Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 镜像不包含任何动态数据，其内容在构建之后也不会被改变。Docker设计时，就充分利用Union FS的技术，将其设计为分层存储的架构。 镜像实际是由多层文件系统联合组成。镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。
容器（Container）—— 镜像运行时的实体 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。前面讲过镜像使用的是分层存储，容器也是如此。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。按照Docker最佳实践的要求，容器不应该向其存储层内写入任何数据 ，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， 使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。
仓库（Repository）—— 集中存放镜像文件的地方 镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。一个Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。所以说：镜像仓库是Docker用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过&amp;lt;仓库名&amp;gt;:&amp;lt;标签&amp;gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以latest作为默认标签。
Docker Registry公开服务和私有Docker Registry Docker Registry公开服务是开放给用户使用、允许用户管理镜像的Registry服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。最常使用的Registry公开服务是官方的Docker Hub ，这也是默认的Registry，并拥有大量的高质量的官方镜像，网址为：hub.docker.com/ 。在国内访问Docker Hub可能会比较慢国内也有一些云服务商提供类似于Docker Hub的公开服务。除了使用公开服务外，用户还可以在本地搭建私有Docker Registry 。Docker官方提供了Docker Registry镜像，可以直接使用做为私有Registry服务。开源的Docker Registry镜像只提供了Docker Registry API的服务端实现，足以支持Docker命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。
Image 查看、拉取、删除 搜索镜像
docker search name[:tag]
拉取镜像,若不指定tag则默认拉取latest
docker pull name[:tag]
查看本地所有镜像
docker images
删除镜像，可以多个删除
docker rmi [option] image ... -f 强制删除 制作、推送 在指定路径中找到 Dockerfile 并构建Image, 后面是路径，但路径中必须存在 Dockerfile
docker build -t [:namespace]/name:tag Path
给镜像赋予新的标签, namespace 必须为 dockerid，除非另外购买。
docker tag oldname:oldtag namespace/newname:newtag
将镜像上传至 docker 仓库 DockerHub 上,namespace 必须是用户名,也可以上传至 Gitlab
docker push namespace/name:tag
docker
提交修改的镜像
docker commit [-a] [-m] CONTAINER [REPOSITORY[:TAG]]
-a 指明提交者
-m 提交信息
在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。 此方式更新的镜像有依赖通过 docker save -o dst [REPOSITORY[:TAG]]存盘,删除所有镜像,再通过 docker load -i path 加载新镜像。
Container 查看容器 docker ps [-a|-s]
-a 查看所有容器。
-s 查看已启动的容器。
产看容器进程 docker top containerID
移除容器 可以多个同时删除
docker rm container ... [option]
-f : 强制删除容器。
-v : 若删除容器则数据卷也删除。
停止容器 可以同时停止多个
docker stop container ...
启动容器 docker run [:--name] [:-e] [:-v] [:-h] [:--net] [:-p prot0:prot1] [:-d|-i] [:-t] [:--rm] [:--restart] [:--privileged=false] [:--ip] [:--network=] name:tag [:shell]
run 命令将会启动 dockerfile 中定义的 CMD 或 ENTRYPOINT 指令。
--name=xxx 指定容器运行时的名称，可不选，默认为随机字符。
-p Host0:Host1 表示本地 Host0 映射容器 Host1 端口,若为 -P 则随机映射49000 ~ 49900 端口。
-d：分离模式: 在后台运行。
-h：指定主机域名。如 -h domyson.cn。
-e：为 dockerfile 中的 ENV 的参数变量,设置环境变量，或者覆盖已存在的环境变量 -e TZ=&amp;quot;Asia/Shanghai&amp;quot; 设置时区为上海。
-u：指定执行用户，一般为 root。
--rm：停止容器就移除。
-it: 以交互模式运行容器 (不同于 -d : 以分离模式运行容器),这意味着交互回话 session 结束时,容器就会停止运行，与 -d 互斥。
-v : 容器内创建一个数据卷。多次重复使用 -v 标记可以创建多个数据卷，也可以挂载一个主机目录作为数据卷 path0:path1(其中path0是主机目录，path1是容器目录)。
--link container : 连接到其他容器。 这个方法以后将被弃用，推荐使用 --network
--network NETWORK：指定连接到的网络。
--ip：指定容器的ip。
--restart：no、on-failure:n、always 设置容器自动重启模式，若容器已经启动，可以通过 docker update --restart args 来设置参数。
--privileged：真正给予 Container 中 root 用户 root权限，否则 root 只是一个普通用户。
shell：指定交互的方式，一般为bash bash -c &amp;quot;cmd string&amp;quot;，这条命令将由启动容器执行。
查看容器日志 docker logs [opt] CONTAINER
-f : 跟踪日志输出
--since :显示某个开始时间的所有日志
-t : 显示时间戳
--tail N :仅列出最新N条容器日志
进入指定容器 docker exec [opt] CONTAINER shell [:args]
-d ：分离模式: 在后台运行
-it：以交互模式运行容器 (不同于 -d : 以分离模式运行容器),这意味着交互回话 session 结束时,容器就会停止运行。与 -d 互斥
-u：指定运行用户,一般设置为 root
进入容器内部之后，通过 exit 退出
容器通讯方式 See DockerNetwork
镜像体积优化 Docker 由多个 Layers 组成（上限是127层）。而 Dockerfile 每一条指令都会创建一层 Layers。
优化基础镜像 使用 Alpine 基础镜像
Alpine是一个高度精简又包含了基本工具的轻量级Linux发行版，基础镜像仅 4.41MB
使用 scratch 基础镜像
scratch是一个空镜像，只能用于构建其他镜像
使用 busybox 基础镜像
如果希望镜像里可以包含一些常用的Linux工具，busybox镜像是个不错选择，镜像本身只有1.16M，非常便于构建小镜像。
串联 Dockerfile 指令 通过 &amp;amp;&amp;amp; 和 \ 将多个 Run 命令合并成一个
多段构建 待完善
Docker数据卷 数据卷可以在容器之间共享和重用 对数据卷的修改会立马生效 对数据卷的更新，不会影响镜像 数据卷默认会一直存在，即使容器被删除 创建数据卷 在 run 命令中 -v /data 标记来创建一个数据卷并挂载到容器里。在一次 run 中多次使用可以挂载多个数据卷。(创建一个容器，并加载一个数据卷到容器的 /data 目录) 也可以在 Dockerfile 中使用 VOLUME 来添加一个或者多个新的卷到由该镜像创建的任意容器。 删除数据卷 数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。无主的数据卷可能会占据很多空间，要清理会很麻烦。 挂载一个主机目录作为数据卷 docker run -d -P --name web -v /src/webapp:/opt/webapp[:权限] 上面的命令加载主机的 /src/webapp 目录到容器的 /opt/webapp 目录，默认权限是读写，也可以指定为只读(ro) --volumes-from 在run的时候指定数据卷容器 查看数据卷的信息
docker inspect contianerID
查看所有数据卷
docker volume ls
清除所有无主数据卷
docker volume prune
Docker权限验证 版本
docker version
登陆
docker login
登出
docker logout
Docker远程访问 Docker-Compose Docker-Compose （docker编排）是 docker 提供的一个命令行工具，用来定义和运行由多个容器组成的应用。可以通过 docker-compose.yml 文件声明式的定义应用程序的各个服务，并由单个命令完成应用的创建和启动。
官方文档
Docker-Compose将所管理的容器分为三层，分别是工程（project），服务（service）以及容器（container）。Docker-Compose运行目录下的所有文件（docker-compose.yml，extends文件或环境变量文件等）组成一个工程，若无特殊指定工程名即为当前目录名。一个工程当中可包含多个服务，每个服务中定义了容器运行的镜像，参数，依赖。一个服务当中可包括多个容器实例，Docker-Compose并没有解决负载均衡的问题，因此需要借助其它工具实现服务发现及负载均衡。
" />
<meta property="og:url" content="https://domyson.github.io/post/docker/" />
<meta property="og:site_name" content="Docker" />
<meta property="og:image"
  content="https://domyson.github.io/">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2019-03-12 00:00:00 &#43;0000 UTC" />











</head>

<body>
  <div style="position: relative">
  <header class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on">
    <div class="Header-item mobile-none" style="margin-top: -4px; margin-bottom: -4px;">
      <a class="Header-link" href="https://domyson.github.io/">
        <img class="octicon" height="32" width="32" src="">
      </a>
    </div>
    <div class="Header-item d-md-none">
      <button class="Header-link btn-link js-details-target" type="button"
        onclick="document.querySelector('#header-search').style.display = document.querySelector('#header-search').style.display == 'none'? 'block': 'none'">
        <img height="24" class="octicon octicon-three-bars" width="24" src="">
      </button>
    </div>
    <div style="display: none;" id="header-search"
      class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex">
      <div
        class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to">
        <div class="position-relative">
          <form target="_blank" action="https://www.google.com/search" accept-charset="UTF-8" method="get"
            autocomplete="off">
            <label
              class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center">
              <input type="text"
                class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable"
                name="q" value="" placeholder="Search" autocomplete="off">
              <input type="hidden" name="q" value="site:https://domyson.github.io/">
            </label>
          </form>
        </div>
      </div>
    </div>

    <div class="Header-item Header-item--full flex-justify-center d-md-none position-relative">
      <a class="Header-link " href="https://domyson.github.io/">
        <img class="octicon octicon-mark-github v-align-middle" height="32" width="32" src="">
      </a>
    </div>
    <div class="Header-item" style="margin-right: 0;">
      <a href="javascript:void(0)" class="Header-link no-select" onclick="switchTheme()">
        <svg style="fill: var(--color-profile-color-modes-toggle-moon);" class="no-select" viewBox="0 0 16 16"
          version="1.1" width="16" height="16">
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z">
          </path>
        </svg>
      </a>
    </div>
  </header>
</div>

  
<div>
  <main>
    <div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4">
      <div class="px-0">
        <div class="mb-3 d-flex px-3 px-md-3 px-lg-5">
          <div class="flex-auto min-width-0 width-fit mr-3">
            <div class="d-flex">
              <div class="d-none d-md-block">
                <a class="avatar mr-2 flex-shrink-0" href="https://domyson.github.io/">
                  <img class=" avatar-user"
                    src="https://domyson.github.io/images/avatar.png"
                    width="32" height="32"></a>
              </div>
              <div class="d-flex flex-column">
                <h1 class="break-word f3 text-normal mb-md-0 mb-1">
                  <span class="author">
                    <a href="https://domyson.github.io/">Treasure</a>
                  </span>
                  <span class="path-divider">/</span>
                  <strong class="css-truncate css-truncate-target mr-1" style="max-width: 410px">
                    <a href="https://domyson.github.io/post/docker/">Docker</a>
                  </strong>
                </h1>
                <div class="note m-0">
                  Created <relative-time datetime="Tue, 12 Mar 2019 00:00:00 &#43;0000"
                    class="no-wrap">
                    Tue, 12 Mar 2019 00:00:00 &#43;0000</relative-time>

                  
                  <span class="file-info-divider"></span>
                  Modified <relative-time datetime="Fri, 05 Jul 2024 15:30:54 &#43;0000"
                    class="no-wrap">
                    Fri, 05 Jul 2024 15:30:54 &#43;0000</relative-time>
                  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-lg px-3 new-discussion-timeline">
      <div class="repository-content gist-content">
        <div>
          <div class="js-gist-file-update-container js-task-list-container file-box">
            <div id="file-pytest" class="file my-2">
              <div id="post-header" class="file-header d-flex flex-md-items-center flex-items-start sticky-header" style="z-index: 2">
                <div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto">
                  <div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">
                    
                    <summary id="toc-toggle" onclick="clickToc()" class="btn btn-octicon m-0 mr-2 p-2">
                      <svg aria-hidden="true" viewBox="0 0 16 16" height="16" width="16" class="octicon octicon-list-unordered">
                        <path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"></path>
                      </svg>
                    </summary>
                    <details-menu class="SelectMenu" id="toc-details" style="display: none;">
                      <div class="SelectMenu-modal rounded-3 mt-1" style="max-height: 340px;">
                        <div class="SelectMenu-list SelectMenu-list--borderless p-2" style="overscroll-behavior: contain;" id="toc-list">
                        </div>
                      </div>
                    </details-menu>
                      8068 Words
                    

                  </div>
                  <div class="file-actions flex-order-2 pt-0">
                    
                    
                    <a class="muted-link mr-3" href="/tags/docker">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      docker
                    </a>
                    
                    
                  </div>
                </div>
              </div>


              <div class="Box-body px-5 pb-5" style="z-index: 1">
                <article class="markdown-body entry-content container-lg"><h1 id="什么是docker">什么是docker</h1>
<p>Docker 是一个开源的容器引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者和系统管理员在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括 VMs（虚拟机）、bare metal、OpenStack 集群、云端、数据中心和其他的基础应用平台。容器是完全使用沙箱机制，相互之间不会有任何接口。</p>
<h1 id="有什么优势">有什么优势</h1>
<ul>
<li>
<p>轻量，在一台机器上运行的多个Docker容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。</p>
</li>
<li>
<p>标准，Docker 容器基于开放式标准，能够在所有主流Linux版本、Microsoft Windows以及包括VM、裸机服务器和云在内的任何基础设施上运行。</p>
</li>
<li>
<p>安全，Docker 赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。</p>
</li>
<li>
<p>一次发布，到处使用</p>
</li>
</ul>
<h1 id="docker和虚拟机">Docker和虚拟机</h1>
<blockquote>
<p>容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。</p>
</blockquote>
<p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">容器</th>
<th style="text-align:center">虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">启动</td>
<td style="text-align:center">秒级</td>
<td style="text-align:center">分钟级</td>
</tr>
<tr>
<td style="text-align:center">硬盘</td>
<td style="text-align:center">MB</td>
<td style="text-align:center">GB</td>
</tr>
<tr>
<td style="text-align:center">性能</td>
<td style="text-align:center">接近原生</td>
<td style="text-align:center">弱于原生</td>
</tr>
<tr>
<td style="text-align:center">支持量</td>
<td style="text-align:center">单机上千</td>
<td style="text-align:center">单机几十左右</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>容器是一个应用层抽象，用于将代码和依赖资源打包在一起。 多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行 。与虚拟机相比， 容器占用的空间较少（容器镜像大小通常只有几十兆），瞬间就能完成启动。</p>
</li>
<li>
<p>虚拟机（VM）是一个物理硬件层抽象，用于将一台服务器变成多台服务器。 管理程序允许多个VM在一台机器上运行。每个VM都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此占用大量空间。而且VM启动也十分缓慢 。</p>
</li>
</ul>
<blockquote>
<p>虚拟机更擅长于彻底隔离整个运行环境。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而 Docker 通常用于隔离不同的应用 ，例如前端，后端以及数据库。</p>
</blockquote>
<h1 id="docker基本组成">Docker基本组成</h1>
<ul>
<li>
<p>镜像 （Image）</p>
</li>
<li>
<p>容器（Container）</p>
</li>
<li>
<p>仓库（Repository）</p>
</li>
</ul>
<h2 id="镜像image-一个特殊的文件系统">镜像（Image）—— 一个特殊的文件系统</h2>
<blockquote>
<p>操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像（Image），就相当于是一个root文件系统。Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 镜像不包含任何动态数据，其内容在构建之后也不会被改变。Docker设计时，就充分利用Union FS的技术，将其设计为分层存储的架构。 镜像实际是由多层文件系统联合组成。镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
</blockquote>
<h2 id="容器container-镜像运行时的实体">容器（Container）—— 镜像运行时的实体</h2>
<blockquote>
<p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。前面讲过镜像使用的是分层存储，容器也是如此。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。按照Docker最佳实践的要求，容器不应该向其存储层内写入任何数据 ，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， 使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。</p>
</blockquote>
<h2 id="仓库repository-集中存放镜像文件的地方">仓库（Repository）—— 集中存放镜像文件的地方</h2>
<blockquote>
<p>镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。一个Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。所以说：镜像仓库是Docker用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以latest作为默认标签。</p>
</blockquote>
<h2 id="docker-registry公开服务和私有docker-registry">Docker Registry公开服务和私有Docker Registry</h2>
<blockquote>
<p>Docker Registry公开服务是开放给用户使用、允许用户管理镜像的Registry服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。最常使用的Registry公开服务是官方的Docker Hub ，这也是默认的Registry，并拥有大量的高质量的官方镜像，网址为：hub.docker.com/ 。在国内访问Docker Hub可能会比较慢国内也有一些云服务商提供类似于Docker Hub的公开服务。除了使用公开服务外，用户还可以在本地搭建私有Docker Registry 。Docker官方提供了Docker Registry镜像，可以直接使用做为私有Registry服务。开源的Docker Registry镜像只提供了Docker Registry API的服务端实现，足以支持Docker命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p>
</blockquote>
<h1 id="image">Image</h1>
<h2 id="查看拉取删除">查看、拉取、删除</h2>
<ul>
<li>
<p>搜索镜像</p>
<p><code>docker search name[:tag]</code></p>
</li>
<li>
<p>拉取镜像,若不指定tag则默认拉取<code>latest</code></p>
<p><code>docker pull name[:tag]</code></p>
</li>
<li>
<p>查看本地所有镜像</p>
<p><code>docker images</code></p>
</li>
<li>
<p>删除镜像，可以多个删除</p>
<p><code>docker rmi [option] image ... </code></p>
<ul>
<li><code>-f</code> 强制删除</li>
</ul>
</li>
</ul>
<h2 id="制作推送">制作、推送</h2>
<ul>
<li>
<p>在指定路径中找到 <a href="/post/Dockerfile">Dockerfile</a> 并构建Image, 后面是路径，但路径中必须存在 <code>Dockerfile</code></p>
<p><code>docker build -t [:namespace]/name:tag Path</code></p>
</li>
<li>
<p>给镜像赋予新的标签, <code>namespace</code> 必须为 <code>dockerid</code>，除非另外购买。</p>
<p><code>docker tag oldname:oldtag  namespace/newname:newtag</code></p>
</li>
<li>
<p>将镜像上传至 docker 仓库 DockerHub 上,<code>namespace</code> 必须是用户名,也可以上传至 <code>Gitlab</code></p>
<p><code>docker push namespace/name:tag</code></p>
<p><code>docker</code></p>
</li>
<li>
<p>提交修改的镜像</p>
<p><code>docker commit [-a] [-m] CONTAINER [REPOSITORY[:TAG]]</code></p>
<ul>
<li>
<p><code>-a</code> 指明提交者</p>
</li>
<li>
<p><code>-m</code> 提交信息</p>
</li>
</ul>
<p>在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。
此方式更新的镜像有依赖通过 <code>docker save -o dst [REPOSITORY[:TAG]]</code>存盘,删除所有镜像,再通过 <code>docker load -i path</code> 加载新镜像。</p>
</li>
</ul>
<h1 id="container">Container</h1>
<h2 id="查看容器">查看容器</h2>
<p><code>docker ps [-a|-s]</code></p>
<ul>
<li>
<p><code>-a</code> 查看所有容器。</p>
</li>
<li>
<p><code>-s</code> 查看已启动的容器。</p>
</li>
</ul>
<h2 id="产看容器进程">产看容器进程</h2>
<p><code>docker top containerID</code></p>
<h2 id="移除容器">移除容器</h2>
<blockquote>
<p>可以多个同时删除</p>
</blockquote>
<p><code>docker rm container ...  [option]</code></p>
<ul>
<li>
<p><code>-f</code> : 强制删除容器。</p>
</li>
<li>
<p><code>-v</code> : 若删除容器则数据卷也删除。</p>
</li>
</ul>
<h2 id="停止容器">停止容器</h2>
<blockquote>
<p>可以同时停止多个</p>
</blockquote>
<p><code>docker stop container ...</code></p>
<h2 id="启动容器">启动容器</h2>
<p><code>docker run [:--name] [:-e] [:-v] [:-h] [:--net] [:-p prot0:prot1] [:-d|-i] [:-t] [:--rm] [:--restart] [:--privileged=false] [:--ip] [:--network=] name:tag [:shell]</code></p>
<ul>
<li>
<p><code>run</code> 命令将会启动 <code>dockerfile</code> 中定义的 <code>CMD</code> 或 <code>ENTRYPOINT</code> 指令。</p>
</li>
<li>
<p><code>--name=xxx</code> 指定容器运行时的名称，可不选，默认为随机字符。</p>
</li>
<li>
<p><code>-p Host0:Host1</code> 表示本地 Host0 映射容器 Host1 端口,若为 <code>-P</code> 则随机映射49000 ~ 49900 端口。</p>
</li>
<li>
<p><code>-d</code>：分离模式: 在后台运行。</p>
</li>
<li>
<p><code>-h</code>：指定主机域名。如 <code>-h domyson.cn</code>。</p>
</li>
<li>
<p><code>-e</code>：为 <code>dockerfile</code> 中的 <code>ENV</code> 的参数变量,设置环境变量，或者覆盖已存在的环境变量 <code>-e TZ=&quot;Asia/Shanghai&quot;</code> 设置时区为上海。</p>
</li>
<li>
<p><code>-u</code>：<del>指定执行用户，一般为 <code>root</code>。</del></p>
</li>
<li>
<p><code>--rm</code>：停止容器就移除。</p>
</li>
<li>
<p><code>-it</code>: 以交互模式运行容器 (不同于 <code>-d</code> : 以分离模式运行容器),这意味着交互回话 session 结束时,容器就会停止运行，与 <code>-d</code> 互斥。</p>
</li>
<li>
<p><code>-v</code> : 容器内创建一个数据卷。多次重复使用 -v 标记可以创建多个数据卷，也可以挂载一个主机目录作为数据卷 path0:path1(其中path0是主机目录，path1是容器目录)。</p>
</li>
<li>
<p><code>--link container</code> : <del>连接到其他容器。</del> 这个方法以后将被弃用，推荐使用 <code>--network</code></p>
</li>
<li>
<p><code>--network NETWORK</code>：指定连接到的网络。</p>
</li>
<li>
<p><code>--ip</code>：指定容器的ip。</p>
</li>
<li>
<p><code>--restart</code>：<code>no、on-failure:n、always</code> 设置容器自动重启模式，若容器已经启动，可以通过 <code>docker update --restart args</code> 来设置参数。</p>
</li>
<li>
<p><code>--privileged</code>：真正给予 <code>Container 中 root 用户</code> root权限，否则 <code>root</code> 只是一个普通用户。</p>
</li>
<li>
<p><code>shell</code>：指定交互的方式，一般为bash <code>bash -c &quot;cmd string&quot;</code>，这条命令将由启动容器执行。</p>
</li>
</ul>
<h2 id="查看容器日志">查看容器日志</h2>
<p><code>docker logs [opt] CONTAINER</code></p>
<ul>
<li>
<p><code>-f</code> : 跟踪日志输出</p>
</li>
<li>
<p><code>--since</code> :显示某个开始时间的所有日志</p>
</li>
<li>
<p><code>-t</code> : 显示时间戳</p>
</li>
<li>
<p><code>--tail N</code> :仅列出最新N条容器日志</p>
</li>
</ul>
<h2 id="进入指定容器">进入指定容器</h2>
<p><code>docker exec [opt] CONTAINER shell [:args]</code></p>
<ul>
<li>
<p><code>-d</code> ：分离模式: 在后台运行</p>
</li>
<li>
<p><code>-it</code>：以交互模式运行容器 (不同于 -d : 以分离模式运行容器),这意味着交互回话 session 结束时,容器就会停止运行。与 <code>-d</code> 互斥</p>
</li>
<li>
<p><code>-u</code>：指定运行用户,一般设置为 root</p>
</li>
<li>
<p>进入容器内部之后，通过 <code>exit</code> 退出</p>
</li>
</ul>
<h2 id="容器通讯方式">容器通讯方式</h2>
<p><a href="/2020/01/Docker-Network/">See DockerNetwork</a></p>
<h1 id="镜像体积优化">镜像体积优化</h1>
<blockquote>
<p><code>Docker</code> 由多个 <code>Layers</code> 组成（上限是127层）。而 <a href="/2019/03/Dockerfile">Dockerfile</a> 每一条指令都会创建一层 <code>Layers</code>。</p>
</blockquote>
<h2 id="优化基础镜像">优化基础镜像</h2>
<ul>
<li>
<p>使用 <code>Alpine</code> 基础镜像</p>
<blockquote>
<p>Alpine是一个高度精简又包含了基本工具的轻量级Linux发行版，基础镜像仅 <code>4.41MB</code></p>
</blockquote>
</li>
<li>
<p>使用 <code>scratch</code> 基础镜像</p>
<blockquote>
<p>scratch是一个空镜像，只能用于构建其他镜像</p>
</blockquote>
</li>
<li>
<p>使用 <code>busybox</code> 基础镜像</p>
<blockquote>
<p>如果希望镜像里可以包含一些常用的Linux工具，busybox镜像是个不错选择，镜像本身只有1.16M，非常便于构建小镜像。</p>
</blockquote>
</li>
</ul>
<h2 id="串联-dockerfile-指令">串联 <code>Dockerfile</code> 指令</h2>
<blockquote>
<p>通过  <code>&amp;&amp;</code> 和 <code>\</code> 将多个 <code>Run</code> 命令合并成一个</p>
</blockquote>
<h2 id="多段构建">多段构建</h2>
<p>待完善</p>
<h2 id="heading"></h2>
<h1 id="docker数据卷">Docker数据卷</h1>
<ul>
<li>数据卷可以在容器之间共享和重用</li>
<li>对数据卷的修改会立马生效</li>
<li>对数据卷的更新，不会影响镜像</li>
<li>数据卷默认会一直存在，即使容器被删除</li>
</ul>
<h2 id="创建数据卷">创建数据卷</h2>
<pre tabindex="0"><code>在 run 命令中 -v /data 标记来创建一个数据卷并挂载到容器里。在一次 run 中多次使用可以挂载多个数据卷。(创建一个容器，并加载一个数据卷到容器的 /data 目录)

也可以在 Dockerfile 中使用  VOLUME  来添加一个或者多个新的卷到由该镜像创建的任意容器。
</code></pre><h2 id="删除数据卷">删除数据卷</h2>
<pre tabindex="0"><code>数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用  docker rm -v  这个命令。无主的数据卷可能会占据很多空间，要清理会很麻烦。
</code></pre><h2 id="挂载一个主机目录作为数据卷">挂载一个主机目录作为数据卷</h2>
<pre tabindex="0"><code>docker run -d -P --name web -v /src/webapp:/opt/webapp[:权限]

上面的命令加载主机的  /src/webapp  目录到容器的  /opt/webapp  目录，默认权限是读写，也可以指定为只读(ro)

--volumes-from 在run的时候指定数据卷容器
</code></pre><ul>
<li>
<p>查看数据卷的信息</p>
<p><code>docker inspect contianerID</code></p>
</li>
<li>
<p>查看所有数据卷</p>
<p><code>docker volume ls</code></p>
</li>
<li>
<p>清除所有无主数据卷</p>
<p><code>docker volume prune</code></p>
</li>
</ul>
<h1 id="docker权限验证">Docker权限验证</h1>
<ol>
<li>
<p>版本</p>
<p><code>docker version</code></p>
</li>
<li>
<p>登陆</p>
<p><code>docker login</code></p>
</li>
<li>
<p>登出</p>
<p><code>docker logout</code></p>
</li>
</ol>
<h1 id="docker远程访问">Docker远程访问</h1>
<h1 id="docker-compose">Docker-Compose</h1>
<blockquote>
<p><code>Docker-Compose</code> （docker编排）是 docker 提供的一个命令行工具，用来定义和运行由多个容器组成的应用。可以通过 docker-compose.yml 文件声明式的定义应用程序的各个服务，并由单个命令完成应用的创建和启动。</p>
</blockquote>
<blockquote>
<p><a href="https://docs.docker.com/compose/">官方文档</a></p>
</blockquote>
<p><code>Docker-Compose</code>将所管理的容器分为三层，分别是工程（project），服务（service）以及容器（container）。Docker-Compose运行目录下的所有文件（docker-compose.yml，extends文件或环境变量文件等）组成一个工程，若无特殊指定工程名即为当前目录名。一个工程当中可包含多个服务，每个服务中定义了容器运行的镜像，参数，依赖。一个服务当中可包括多个容器实例，Docker-Compose并没有解决负载均衡的问题，因此需要借助其它工具实现服务发现及负载均衡。</p>
<h1 id="docker-compose-命令">docker-compose 命令</h1>
<h2 id="docker-compse-up-opthions---scale-servicenum-service">docker-compse up [opthions] [&ndash;scale SERVICE=NUM] [SERVICE&hellip;]</h2>
<blockquote>
<p>容器启动命令</p>
</blockquote>
<ul>
<li>
<p><code>-d</code>：在后台运行</p>
</li>
<li>
<p><code>–no-color</code> 不使用颜色来区分不同的服务的控制输出</p>
</li>
<li>
<p><code>–no-deps</code> 不启动服务所链接的容器</p>
</li>
<li>
<p><code>–force-recreate</code> 强制重新创建容器，不能与<code>–no-recreate</code>同时使用</p>
</li>
<li>
<p><code>–no-recreate</code> 如果容器已经存在，则不重新创建，不能与<code>–force-recreate</code>同时使用</p>
</li>
<li>
<p><code>–no-build</code> 不自动构建缺失的服务镜像</p>
</li>
<li>
<p><code>–build</code>：在启动容器前构建服务镜像，或rebuild</p>
</li>
<li>
<p><code>–abort-on-container-exit</code>：停止所有容器，如果任何一个容器被停止，不能与 <code>-d</code> 同时使用</p>
</li>
<li>
<p><code>–scale SERVICE=NUM ...</code> 设置服务运行容器的个数，将覆盖在compose中通过scale指定的参数</p>
</li>
</ul>
<h2 id="docker-compose-ps-service">docker-compose ps [SERVICE&hellip;]</h2>
<blockquote>
<p>查看 <code>docker-compose</code> 中列出的容器</p>
</blockquote>
<h2 id="docker-compose-startstoprestart">docker-compose [start|stop|restart]</h2>
<blockquote>
<p>[开始|停止|重启]项目中运行的容器</p>
</blockquote>
<h1 id="docker-compose-文件结构">docker-compose 文件结构</h1>
<blockquote>
<p>Docker-Compose标准模板文件应该包含version、services、networks 三大部分，最关键的是services和networks两个部分。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;3.5&#34;</span><span class="w">                  </span><span class="c">#docker-compose 版本,不同的版本配置有所不同</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">service</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">nats</span><span class="p">:</span><span class="w">                         </span><span class="c">#标识,如果设置了网络，这个也是他在网络中的别名，也可以指定alias</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">nats:latest         </span><span class="w"> </span><span class="c">#如果本地不存在就会在dockerhub上拉取</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;nats0&#34;</span><span class="w">     </span><span class="c">#运行时的容器名</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">                      </span><span class="c">#端口与宿主机映射规则</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;4222:4222&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;6222:6222&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;8222:8222&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">expose</span><span class="p">:</span><span class="w">                     </span><span class="c">#暴露容器端口，仅仅是声明，不会起实际作用，参考 Dockerfile</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;4222&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;8222&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;6222&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">                   </span><span class="c">#链接的网络，不存在会自动创建，必须在services同级的networks中指定</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">net1                   </span><span class="w"> </span><span class="c">#指定连接的网络名</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">net2                    </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">gate</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">gateway</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;./gateway&#34;</span><span class="w">          </span><span class="c">#如果此镜像是自定义镜像，需要指定dockerfile文件的目录，将不会拉取远程镜像</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;gateway&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="l">sh run.sh         </span><span class="w"> </span><span class="c">#覆盖容器的默认执行命令</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w">                 </span><span class="c">#指定依赖的启动项，即先启动 nats 再启动此镜像</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">nats</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">login</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;5433:5433&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">expose</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;5433&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">net1</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">ipv4_address</span><span class="p">:</span><span class="w"> </span><span class="m">172.18.0.31</span><span class="w"> </span><span class="c">#指定容器的固定ipv4地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">login</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">login</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;./login&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;login&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="s2">&#34;5434:5434&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">expose</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="m">5433</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">net1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">db</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;./db&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;db&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">net1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">/var/etc/:/var/etc/    </span><span class="w"> </span><span class="c">#容器卷映射</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">net1</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">xNet                 </span><span class="w"> </span><span class="c">#虚拟网卡名 version &gt;=3.5</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">driver</span><span class="p">:</span><span class="w"> </span><span class="l">bridge             </span><span class="w"> </span><span class="c">#支持三种模式 host bridge(默认) none</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">net2</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">yNet</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">driver</span><span class="p">:</span><span class="w"> </span><span class="l">host</span><span class="w">
</span></span></span></code></pre></div><h1 id="dockerfile">dockerfile</h1>
<h1 id="dockerfile-1">Dockerfile</h1>
<blockquote>
<p><code>Dockerfile</code> 是一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker通过读取Dockerfile中的指令自动生成映像。<code>docker build</code> 命令用于从 <code>Dockerfile</code>构建映像。命令中使用 <code>-f</code> 标志指向文件系统中任何位置的 <code>Dockerfile</code> 文件。</p>
</blockquote>
<h2 id="from">FROM</h2>
<blockquote>
<p>指定基础镜像</p>
</blockquote>
<p><code>FROM &lt;image&gt;:&lt;tag&gt;</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">FROM</span><span class="s"> node:10.14.2</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># tag为可选项，如果没有指定，默认为latest</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 指定基础，FROM必须作为第一个指令，若镜像不存在则会下载，如果不以任何镜像为基础，则写法为：FROM scratch，意味着接下来的指令作为第一层镜像的开始。</span><span class="err">
</span></span></span></code></pre></div><h2 id="maintainer">MAINTAINER</h2>
<blockquote>
<p>镜像作者 已过时，用  <a href="#LABEL">Label</a> 代替</p>
</blockquote>
<p><del><code>MAINTAINER &lt;name&gt;</code></del></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="c">#MAINTAINER Treasure</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">LABEL</span> <span class="nv">maintainer</span><span class="o">=</span>Treasure
</span></span></code></pre></div><h2 id="addcopy">ADD、COPY</h2>
<blockquote>
<p>ADD、COPY目标文件夹若不存在会自动创建。ADD指令包含类似tar的解压功能，而COPY只单纯复制文件，而且路径不能是url。ADD和COPY只能复制文件，若碰到文件夹只会复制其中的文件。<code>dst</code> 只能是目标容器的绝对位置。 所有拷贝到容器中的文件和文件夹权限为 <code>0755</code>，uid和gid为0；如果是一个目录，那么会将该目录下的所 有文件拷贝到目录下，不包括目录；如果是文件且中不使用斜杠结束，则会将视为文件，则内容会写入；如果是文件且中使用斜杠结束，则会文件拷贝到目录下。</p>
</blockquote>
<p><code>ADD src ... dst</code></p>
<p><code>COPY src ... dst</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">ADD</span> ./* /data<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> ./ /data<span class="err">
</span></span></span></code></pre></div><h2 id="workdir">WORKDIR</h2>
<blockquote>
<p>将会设置 RUN、CMD、ENTRYPOINT指定的工作目录,相当于切换目录至path</p>
</blockquote>
<p><code>WORKDIR path</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">WORKDIR</span><span class="s"> /app    #工作目录为 /app</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> gateway #工作目录为 /app/gateway</span><span class="err">
</span></span></span></code></pre></div><h2 id="user">USER</h2>
<blockquote>
<p>指定运行容器的用户</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">USER</span><span class="s"> root</span><span class="err">
</span></span></span></code></pre></div><h2 id="label">LABEL</h2>
<blockquote>
<p>为镜像指定标签，LABEL会继承基础镜像中的LABEL，如遇到key相同，则会被覆盖。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">LABEL</span> &lt;key&gt;<span class="o">=</span>&lt;value&gt; &lt;key&gt;<span class="o">=</span>&lt;value&gt; ...<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">LABEL</span> &lt;key&gt;<span class="o">=</span>&lt;value&gt; <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    &lt;key&gt;<span class="o">=</span>&lt;value&gt;<span class="err">
</span></span></span></code></pre></div><h2 id="env">ENV</h2>
<blockquote>
<p>ENV指令用来定义镜像的环境变量，在Dockerfile中这些设置的环境变量也会影响到RUN指令，当运行生成的镜像时这些环境变量依然有效，如果需要在运行时更改这些环境变量可以在运行docker run时添加–e <!-- raw HTML omitted -->=<!-- raw HTML omitted -->参数来修改。可以通过 docker inspect 查看环境变量。其他命令通过 $EVNNAME 来引用,最好不要定义那些可能和系统预定义的环境变量冲突的名字，否则可能会产生意想不到的结果。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">ENV</span> <span class="nv">HOST</span><span class="o">=</span><span class="m">0</span>.0.0.0 <span class="nv">PORT</span><span class="o">=</span><span class="m">8000</span> <span class="c1">#可以设置多个,但`=`两侧不允许有空格</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">A1</span><span class="o">=</span>Treasure <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="nv">A2</span><span class="o">=</span>DoMySon
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">WORKDIR</span><span class="s"> ${foo} #引用ENV设置的变量</span><span class="err">
</span></span></span></code></pre></div><h2 id="expose">EXPOSE</h2>
<blockquote>
<p>功能为暴漏容器运行时的监听端口给外部（只允许能被连接的服务访问）,但是EXPOSE并不会使容器访问主机的端口,如果想使得容器与主机的端口有映射关系，必须在容器启动的时候加上 <code>-p</code> 参数</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">EXPOSE</span><span class="s"> 8000 3306 </span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">EXPOSE</span><span class="s"> 80</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">EXPOSE</span><span class="s"> 5433/tcp 5434/udp</span><span class="err">
</span></span></span></code></pre></div><h2 id="volume">VOLUME</h2>
<blockquote>
<p>可实现挂载功能，可以将本地文件夹或者其他容器种得文件夹挂在到这个容器中，若目标文件夹或文件不存在则创建</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">VOLUME</span> <span class="p">[</span><span class="s2">&#34;path1&#34;</span><span class="p">,</span><span class="s2">&#34;path2&#34;</span><span class="p">]</span> <span class="c1">#主机上的挂点是随即生成的 </span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">VOLUME</span><span class="s"> /var/log /var/db #挂载多个</span><span class="err">
</span></span></span></code></pre></div><h2 id="run">RUN</h2>
<blockquote>
<p>在容器中构建时执行的命令，RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定&ndash;no-cache参数：<code>docker build --no-cache</code></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">RUN</span> npm install                         <span class="c1">#使用 shell 执行</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> <span class="o">[</span><span class="s2">&#34;executable&#34;</span>,<span class="s2">&#34;param1&#34;</span>,<span class="s2">&#34;param2&#34;</span><span class="o">]</span>    <span class="c1">#使用可执行程序执行 </span><span class="err">
</span></span></span></code></pre></div><h2 id="cmd">CMD</h2>
<blockquote>
<p>功能为容器启动时要运行的命令CMD指令中指定的命令会在镜像运行时执行，在Dockerfile中只能存在一个，如果使用了多个CMD指令，则只有最后一个CMD指令有效。当出现ENTRYPOINT指令时，CMD中定义的内容会作为ENTRYPOINT指令的默认参数，也就是说可以使用CMD指令给ENTRYPOINT传递参数。<code>RUN</code>和<code>CMD</code>都是执行命令，他们的差异在于<code>RUN</code>中定义的命令会在执行<code>docker build</code>命令创建镜像时执行，而<code>CMD</code>会在<code>docker run</code>时执行。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">CMD</span> npm install                         <span class="c1">#使用 shell 执行</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">CMD</span> <span class="p">[</span><span class="s2">&#34;executable&#34;</span><span class="p">,</span><span class="s2">&#34;param1&#34;</span><span class="p">,</span><span class="s2">&#34;param2&#34;</span><span class="p">]</span>    <span class="c1">#使用可执行程序执行 </span><span class="err">
</span></span></span></code></pre></div><h2 id="entrypoint">ENTRYPOINT</h2>
<blockquote>
<p>功能是启动时的默认命令，与 <code>CMD</code> 相似，如果有多条则最后一条生效。但ENTRYPOINT不会被command覆盖，而 CMD 则会被覆盖。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">ENTRYPOINT</span> <span class="p">[</span><span class="s2">&#34;exec&#34;</span><span class="p">,</span><span class="s2">&#34;param1&#34;</span><span class="p">,</span><span class="s2">&#34;param2&#34;</span><span class="p">]</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENTRYPOINT</span> command<span class="err">
</span></span></span></code></pre></div><h2 id="user-1">USER</h2>
<blockquote>
<p>设置启动容器的用户，可以是用户名或UID,如果设置了容器以daemon用户去运行，那么 RUN, CMD 和 ENTRYPOINT 都会以这个用户去运行</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">USER</span><span class="s"> daemo</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">USER</span><span class="s"> UID</span><span class="err">
</span></span></span></code></pre></div><h2 id="arg">ARG</h2>
<blockquote>
<p>设置变量命令，ARG命令定义了一个变量，在 docker build 创建镜像的时候，使用 &ndash;build-arg <!-- raw HTML omitted -->=<!-- raw HTML omitted -->来指定参数，如果用户在build镜像时指定了一个参数没有定义在Dockerfile中，那么将有一个 Warning</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">ARG</span> &lt;name&gt;<span class="o">[=</span>&lt;default_value&gt;<span class="o">]</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ARG</span> <span class="nv">user1</span><span class="o">=</span><span class="m">10</span> <span class="c">#默认值变量</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ARG</span> build <span class="c1">#不带默认值变量</span><span class="err">
</span></span></span></code></pre></div><h2 id="onbuild">ONBUILD</h2>
<blockquote>
<p>这是一个特殊的指令，它后面跟的是其它指令，比如 RUN , COPY等，而这些指令， 在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p>
</blockquote>
<h1 id="docker-network">docker network</h1>
<h1 id="docker-network-1">Docker Network</h1>
<blockquote>
<p><code>Docker</code> 在安装时候，默认创建三个网络 <code>bridge（默认）</code>,<code>none</code>,<code>host</code>。</p>
</blockquote>
<blockquote>
<p><code>docker network create --driver [bridge|host|none|container] networkname</code></p>
</blockquote>
<ul>
<li>
<p><code>bridge</code>：默认模式，容器使用独立 network Namespace，并连接到<code>docker0</code>虚拟网卡（默认模式）。通过该网桥以及Iptables nat表配置与宿主机通信，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的容器连接到同一个网桥 <code>docker0</code> 中。</p>
</li>
<li>
<p><code>host</code>：与宿主机共享网络，此时容器没有使用网络的namespace，<code>-p</code> 将不会起任何作用。</p>
</li>
<li>
<p><code>container</code>：新创建的容器和已经存在的一个容器共享一个Network Namespace,新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo网卡设备通信。</p>
</li>
<li>
<p><code>none</code>：该模式将容器放置在它自己的网络栈中，但是并不进行任何配置。实际上，该模式关闭了容器的网络功能，在以下两种情况下是有用的：容器并不需要网络（例如只需要写磁盘卷的批处理任务）。</p>
</li>
<li>
<p><code>container</code>：与指定的容器共享网络，如果有的话。</p>
</li>
</ul>
<h1 id="容器连接">容器连接</h1>
<ol>
<li>
<p>通过 <code>docker network ls</code> 查看网络信息。</p>
</li>
<li>
<p>运行容器时通过 <code>--network=[networkname]</code> 指定连接的网络（未测试是否可以同时连接多个）。若不指定则默认连接到 <code>bridge</code> 网络。 也可以同过 <code>--net=[networkmode]</code> 指定网络的模式。同时通过 ``。</p>
<ul>
<li>
<p>&ndash;net=host</p>
</li>
<li>
<p>&ndash;net=none</p>
</li>
<li>
<p>&ndash;net=bridge</p>
</li>
<li>
<p>&ndash;net=container</p>
</li>
</ul>
</li>
</ol>
<h1 id="docket-跨主机通讯">Docket 跨主机通讯</h1>
<h2 id="自己yy">自己yy</h2>
<p>两个宿主机的容器映射到宿主机的端口，然后通讯。</p>
<h2 id="overlay">overlay</h2></article>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>
<script type="application/javascript" src='https://domyson.github.io/js/toc.js'></script>
<link rel="stylesheet" href='https://domyson.github.io/css/toc.css' />


<div id="gitalk-container" class="gitalk-container"></div>
<link rel="stylesheet" href='https://domyson.github.io/css/gitalk.css'>
<script src='https://domyson.github.io/js/gitalk.min.js'></script>
<script>
  const gitalk = new Gitalk({
    clientID: '258cd417c7c5b85f68e3',
    clientSecret: '4fd96cf3d02ea5bf11e9c29b159e2041557493e6',
    repo: 'domyson.github.io',
    owner: 'domyson',
    admin: ['domyson'],
    id: eval("location.pathname"), 
    distractionFreeMode: false 
  });
  (function() {
    gitalk.render('gitalk-container');
  })();
</script>


  <div class="footer container-xl width-full p-responsive">
  <div
    class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light ">
    <a aria-label="Homepage" title="GitHub" class="footer-octicon d-none d-lg-block mr-lg-4" href="https://domyson.github.io/">
      <svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="24">
        <path fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
        </path>
      </svg>
    </a>
    <ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0">
      
      <li class="mr-3 mr-lg-0">Theme by <a href='https://github.com/MeiK2333/github-style'>github-style</a></li>
      
    </ul>
  </div>
  <div class="d-flex flex-justify-center pb-6">
    <span class="f6 text-gray-light"></span>
  </div>


</div>
</body>

<script type="application/javascript" src="https://domyson.github.io/js/github-style.js"></script>




</html>