<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 朝花夕拾</title>
    <link>https://domyson.github.io/post/</link>
    <description>Recent content in Posts on 朝花夕拾</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 06 Jan 2025 04:52:57 +0000</lastBuildDate>
    <atom:link href="https://domyson.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>makefile</title>
      <link>https://domyson.github.io/post/makefile/</link>
      <pubDate>Tue, 17 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/makefile/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;code&gt;makefile&lt;/code&gt; 很早就想写了，高阶概念总是忘了又忘，一千个人一千个哈姆雷特，理解抽象概念的方式各有不同&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;whats-makefile&#34;&gt;What&amp;rsquo;s makefile?&lt;/h1&gt;</description>
    </item>
    <item>
      <title>AST 抽象语法树</title>
      <link>https://domyson.github.io/post/typelang/3/</link>
      <pubDate>Wed, 04 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/typelang/3/</guid>
      <description>&lt;h1 id=&#34;序&#34;&gt;序&lt;/h1&gt;&#xA;&lt;p&gt;还没写&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bytecode</title>
      <link>https://domyson.github.io/post/typelang/5/</link>
      <pubDate>Wed, 04 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/typelang/5/</guid>
      <description>&lt;h1 id=&#34;序&#34;&gt;序&lt;/h1&gt;&#xA;&lt;p&gt;还没写&lt;/p&gt;</description>
    </item>
    <item>
      <title>grammer</title>
      <link>https://domyson.github.io/post/typelang/2/</link>
      <pubDate>Wed, 04 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/typelang/2/</guid>
      <description>&lt;h1 id=&#34;序&#34;&gt;序&lt;/h1&gt;&#xA;&lt;p&gt;还没写&lt;/p&gt;</description>
    </item>
    <item>
      <title>lex</title>
      <link>https://domyson.github.io/post/typelang/1/</link>
      <pubDate>Wed, 04 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/typelang/1/</guid>
      <description>&lt;h1 id=&#34;序&#34;&gt;序&lt;/h1&gt;&#xA;&lt;p&gt;对于一个源码文件而言，里面的内容只是一个个字符，机器是无法识别的，而词法分析器的作用类似于转义器，将一个个字符拆成若干个有特定意义的词，而这一过程称为词法分析，此时它也不能被机器(或者这个虚拟机)识别&lt;/p&gt;</description>
    </item>
    <item>
      <title>Register</title>
      <link>https://domyson.github.io/post/typelang/4/</link>
      <pubDate>Wed, 04 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/typelang/4/</guid>
      <description>&lt;h1 id=&#34;序&#34;&gt;序&lt;/h1&gt;&#xA;&lt;p&gt;还没写&lt;/p&gt;</description>
    </item>
    <item>
      <title>typelang</title>
      <link>https://domyson.github.io/post/typelang/0/</link>
      <pubDate>Wed, 04 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/typelang/0/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;这篇文章将会是一个系列，更新会比源码慢，文档写的也不会写的很完全，名字暂定 &lt;code&gt;typelang&lt;/code&gt;, C syntax-like&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;设计缘由&#34;&gt;设计缘由&lt;/h1&gt;&#xA;&lt;p&gt;早在2019之前就想开发一门脚本语言，一是加深编译原理的理解，二是觉得程序员不应该消耗在语言特性上，也一直想为自己的服务端框架 &lt;a href=&#34;https://domyson.github.io/post/skynet/skynet&#34;&gt;skynet-x&lt;/a&gt; 写一门dsl，现在是用lua作为服务的脚本端。但由于的若约束性导致在开发的时候很多同时并不够优雅，总是以一种奇怪的方式来解决问题，Lua本身并没有任何问题，它被设计之初是为了修补C的不足，但它的语法设计却并不符合我的预期。&lt;/p&gt;&#xA;&lt;p&gt;尽管它的性能是脚本语言中顶尖的，但是一些隐式写法并不能保证它的预期性能，如混合&lt;code&gt;table&lt;/code&gt;,过多的函数调用栈，字符串操作以及无类型系统。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;关于类型系统有利有弊，但我个人的观点是宁愿多出30%的开发时间，从而减少70%的bug。&lt;/p&gt;&#xA;&lt;/blockquote&gt;</description>
    </item>
    <item>
      <title>datatable</title>
      <link>https://domyson.github.io/post/zen/3/</link>
      <pubDate>Sat, 01 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/zen/3/</guid>
      <description>&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;DatatableModule&lt;/code&gt; 是一个基于 &lt;a href=&#34;https://domyson.github.io/post/kproto&#34;&gt;kpb&lt;/a&gt; 编码的配置文件管理系统,它定义了一个配置文件的数据结构，并提供了相应的API来操作和访问配置文件。在&lt;code&gt;Zen&lt;/code&gt;中它是一个&lt;code&gt;GameComponent&lt;/code&gt;。它包含了一个代码生成器，和数据解析器和编码器。&lt;/p&gt;&#xA;&lt;p&gt;数据表的加载只有4(2)个接口  &lt;code&gt;LoadDatatable&amp;lt;T&amp;gt;(bool lazy)&lt;/code&gt; &lt;code&gt;GetRow&amp;lt;T&amp;gt;(int row)&lt;/code&gt; 以及一套同作用的异步接口，前者获取一整张表，后者获取某表的某一行数据，即对应的数据结构体。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Datatable&lt;/code&gt; 静默行为是 &lt;code&gt;Lazy load&lt;/code&gt; 对于同一张数据表，它只会根据需要读取指定行然后才缓存，而不是一次性读取所有表格。&lt;/p&gt;&#xA;&lt;h1 id=&#34;feature&#34;&gt;Feature&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;lazy load&lt;/code&gt;,它不会加载表格的所有数据，而是按照需要动态一部分一部分的加载，直到全部加载完毕。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;DatatableModule&lt;/code&gt; 加载接口提供同步和异步两种模式，也可以加载远程资源，依赖于 &lt;a href=&#34;https://domyson.github.io/post/Zen/2&#34;&gt;Resource&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;DatatableModule&lt;/code&gt; 提供代码和数据生成的编辑器，无需关注实现逻辑。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;多种类型数据支持 &lt;code&gt;bool,int,float,string,binary,int*,float*,string*&lt;/code&gt;,满足绝大部分场景&#xA;（2024/05/23）增加了定长数据的支持，减少内存消耗。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;基于&lt;code&gt;kproto&lt;/code&gt;编码协议，极小的二进制文件，以及极快的编解码速度。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;栈内存映射，大部分情况下不需要开辟堆空间，节省一部分堆内存的分配，减少&lt;code&gt;Mono Reserved&lt;/code&gt;的分配。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;!-- raw HTML omitted --&gt;</description>
    </item>
    <item>
      <title>EntityManager</title>
      <link>https://domyson.github.io/post/zen/5/</link>
      <pubDate>Sat, 01 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/zen/5/</guid>
      <description>&lt;p&gt;&lt;code&gt;EntityManager&lt;/code&gt;是一个很重要的模块，像游戏开发本身就是视觉感知，而&lt;code&gt;EntityManager&lt;/code&gt;是对所有场景物体的统一抽象封装, 并提供一系列通用操作，&lt;code&gt;EntityManager&lt;/code&gt; 本身是一个抽象类，提供了一定程度的通用性操作，但针对一些特殊情况我们还是需要针对特定问题特定实现（千万不想要想着做平，来自某家公司的教训:)）&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;EntityManager&lt;/code&gt; 附带一个默认的 &lt;code&gt;EntityController&lt;/code&gt;,提供一些常规的实体控制，像 &lt;code&gt;Zen&lt;/code&gt;的UI框架就是基于 &lt;code&gt;EntityManager&lt;/code&gt;的一个具体实现。&lt;/p&gt;&#xA;&lt;h1 id=&#34;entity&#34;&gt;Entity&lt;/h1&gt;&#xA;&lt;p&gt;抽象描述一个物体的实体，它的生命周期函数定义类似于&lt;code&gt;GameComponent&lt;/code&gt;,但是它的调度不由&lt;code&gt;GameEntry&lt;/code&gt;而是 &lt;code&gt;GameComponent&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;简单来说，要创建一个物体首先我们需要定义它的逻辑模板（骨架）以及它的数据（描述）&lt;/p&gt;&#xA;&lt;p&gt;举个例子&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;EnemyData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IEntityData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 对于实体数据接口，资源名必不可少&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Assets&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;OnCtor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 有些时候，实体的数据更关卡等级或这地图这类外部数据挂钩，可能需要在这里动态设置一次&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 定义Entity的逻辑模板&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Enemy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Entity&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;EnemyData&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;userdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;OnCtor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// init setup...&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;     &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;OnUpdate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;unscaleDelta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// loop logic.&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dosomething&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 直接在默认的EntityManager中创建一个实体&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;GameEntry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GetComponent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EntityManager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;().&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Enemy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;EnemyData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于实体的销毁，像敌人死亡，特效消失之类的，仅仅只需要设置一个 &lt;code&gt;Alive&lt;/code&gt; 属性，即可完成，生命周期由&lt;code&gt;EntityManger&lt;/code&gt;自行决断。&lt;/p&gt;&#xA;&lt;p&gt;需要注意的是 继承&lt;code&gt;IEntityData&lt;/code&gt;的数据模板是会一直复用的，它与 &lt;code&gt;Entity&lt;/code&gt;的复用规则不同，后者复用的是&lt;code&gt;Entity&lt;/code&gt;所持有的实体，因为它本身只是一系列函数集合且很少会带有数据并不会占用太多的内存，而前者大部分情况下是都是通过读表获取，复杂的实体数据可能会导致内存异常大，所以保留实体数据是&lt;code&gt;EntityManager&lt;/code&gt;的默认行为。&lt;/p&gt;&#xA;&lt;h1 id=&#34;entitysettings&#34;&gt;EntitySettings&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;EntityManager&lt;/code&gt;可能需要在某些大量对象时使用对象池（&lt;code&gt;Entity&lt;/code&gt;），或者内存池(&lt;code&gt;EntityData&lt;/code&gt;),但在大多数情况下，框架并不清楚是否需要对象池，或者是需要一个定长周期的物体（子弹或者特效）。&lt;/p&gt;&#xA;&lt;p&gt;这个时候需要设置就非常有必要了，可以决断出是否需要且生命周期（keepalive）或者是需要多大的对象池，以及自动孵化的频率了。&lt;/p&gt;&#xA;&lt;!-- raw HTML omitted --&gt;</description>
    </item>
    <item>
      <title>Resource</title>
      <link>https://domyson.github.io/post/zen/2/</link>
      <pubDate>Sat, 01 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/zen/2/</guid>
      <description>&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;Resource&lt;/code&gt; 是一个全自动化，且简单易用的资源管理系统,继承于&lt;code&gt;GameComponet&lt;/code&gt;实现 ，它内部使用&lt;code&gt;RC&lt;/code&gt;的方式来管理资源的引用，且不需要手动显示释放,而是通过拦截finalizer的方式，来达到释放的目的，比手动安全性更高，也更易用。&lt;/p&gt;&#xA;&lt;p&gt;它仅提供了两组接口资源加载接口&lt;code&gt;LoadAsset&lt;/code&gt;  &lt;code&gt;LoadAssetAsync&lt;/code&gt;，。并提供了虚拟化的方式加载，在编辑器模式下不会真正的构建&lt;code&gt;AssetBundle&lt;/code&gt;包，从而提供开发效率。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Resource&lt;/code&gt;也包括流场景构建，可以将整个场景都作为热更新资源。&lt;/p&gt;&#xA;&lt;h1 id=&#34;feature&#34;&gt;Feature&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;自动化检测文件变动&#xA;通过&lt;code&gt;Radix&lt;/code&gt;算法，监控资源变动，来自动构建&lt;code&gt;manifest&lt;/code&gt;。上层只需要关注资源本身，无需关注&lt;code&gt;AssetBundle&lt;/code&gt;包的构建。做到对上层完全无感。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;自动化引用计数&#xA;通过 &lt;code&gt;RC&lt;/code&gt;+ finalizer，监控资源的引用，来自动释放资源。且无需轮询检查资源的引用计数，提供更好的性能，做到对上层完全无感。也没有手动释放接口，提高安全性和易用性&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;自动化冗余剔除&#xA;在构建的时候自动收集冗余资源，如像A-&amp;gt;(C,D) B-&amp;gt;(C) 此时(A,D)将会作为一个的bundle，而C则会单独作为一个bundle&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Profile资源使用分析，用以在运行时统计各个资源的引用和加载数&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;自定义流处理，支持加密等自定义操作&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;多种模式支持&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Builtin: 内建资源，默认将资源插入母包中。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Remote: 远程资源模式，仅需要配置远程资源地址即可，所有资源不会在本地存盘，只会在内存中使用，使用完后立即释放，防止被反编译资源&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;无感知资源更新&#xA;一般出现资源更新的时候，都是先下载到本地，然后再通过加载本地资源的方式实现， 现由&lt;code&gt;FS&lt;/code&gt;映射的远程目录，通过分流的方式，可以实现一边从远程直接读取，并copy另外一部分流到本地磁盘，减少重新读盘的情况。&#xA;对于下载过程对于玩家而言完全无感，其本身下载速度是可以被控制，当前并没有暴露此接口（因为带宽值是动态变化的，无法根据不同的条件找到一个合理值），只是需要设定一个百分率阈值，内部自动计算下载速度尽可能保证达到预期值。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;淘汰策略&#xA;当某个Assetbundle的引用计数为0时候，底层不会立即释放它，而是根据它过往的加载次数判断下一次淘汰次数，越大将会越晚淘汰，当然也提供了强制卸载函数。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;后续计划&#34;&gt;后续计划&lt;/h1&gt;&#xA;&lt;p&gt;&lt;del&gt;现阶段&lt;code&gt;Resource&lt;/code&gt;是依赖于&lt;code&gt;Assetbundle&lt;/code&gt; 后续会抽象出一层 &lt;code&gt;FS&lt;/code&gt; 以提供自定义流提供更多可操作性和安全性。&lt;/del&gt; 已实现&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Resource&lt;/code&gt;现在可以说是完全不能脱离&lt;code&gt;Unity&lt;/code&gt;独立运行，这不是一个好的方式，我期望提供更高的抽象满足多个引擎的需求。当完成这一步时只需要在&lt;code&gt;Unity&lt;/code&gt;中需要手动实现一个&lt;code&gt;Adaptor&lt;/code&gt;即可。&lt;/p&gt;&#xA;&lt;!-- raw HTML omitted --&gt;</description>
    </item>
    <item>
      <title>zen 客户端框架概述</title>
      <link>https://domyson.github.io/post/zen/0/</link>
      <pubDate>Sat, 01 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/zen/0/</guid>
      <description>&lt;h1 id=&#34;序&#34;&gt;序&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;Zen&lt;/code&gt; 是一个基于 Unity 引擎的&lt;code&gt;GamePlay&lt;/code&gt;框架，脱离 &lt;code&gt;Monobehaviour&lt;/code&gt; 开发，致力简化开发流程。内部提供了一个&lt;code&gt;伪ECS&lt;/code&gt;的上层抽象来开发它，但事实上你并不一定需要使用这个&lt;code&gt;ECS&lt;/code&gt;，你也可以使用自定义的上层，比如自己实现像&lt;code&gt;MVCC&lt;/code&gt;，或者是&lt;code&gt;MVC&lt;/code&gt;的上层封装。让开发聚焦在游戏玩法而非一些底层架构上。Zen有两重含义，一可以实现任意类型的游戏，二可以在任意地方调动，而非需要定义一个字段保存访问索引。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Zen的一些设计思想不算是纯粹的&lt;code&gt;OOP&lt;/code&gt;，它有ECS的概念，也有&lt;code&gt;type embedding&lt;/code&gt;的概念，而且设计概念大部分是参考面过过程和内嵌的设计思想，所以理解曲线会比较困难&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;设计目标&#34;&gt;设计目标&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;无框架化，它之所有不提供是为了更好的设计出不同品类的游戏，而我在近10年的游戏开发生涯中，我始终觉得框架的约束即使最大的约束，因为业务的多样性和非明确性的特点，一般游戏后期的一些奇奇怪怪的需求总是会迫使你绕过框架的约束从而形成屎山code，所以我希望&lt;code&gt;Zen&lt;/code&gt;框架本身可以尽可能的简单，让开发者可以自由的去选择框架的约束。你可使用&lt;code&gt;Zen&lt;/code&gt;的一部分，或者全部，甚至是都不需要。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;无&lt;code&gt;MonoBehaviour&lt;/code&gt;编程设计，解除引擎原始的约束，更自由的编程方式，像之前开发游戏，一个角色身上可能挂在各式各样的组件，一旦后期业务变动很容易出现引用丢失或者维护起来更为困难，而且一些特殊的时候可能还需要设置一下脚本的执行顺序，给维护带来巨大的不便（如我之前所呆的项目各种口口相传的细节规范，让开发痛不欲生）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;模块化，&lt;code&gt;Zen&lt;/code&gt;的一大特色，以像&lt;code&gt;C library&lt;/code&gt;的方式来组织模块，让模块之间可以互相调用，并且可以互相替换，让开发者可以自由的去选择模块的约束。选择何种内置模块，或者是自定义模块由开发者决定，这也是使用 &lt;code&gt;Zen&lt;/code&gt; 唯一的约束，你的模块可以是框架，也可以是&lt;code&gt;Module&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;简单化，&lt;code&gt;Zen&lt;/code&gt; 本身只提最必要的一些基础组件，你可以重新实现，而并非是必要的，就是这么随意，就像它的名字一样。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;自由化，游戏开发是自由的，是创造性的，&lt;code&gt;Zen&lt;/code&gt; 不会约束你干什么，你只需要关注你的想法，怎么做取决于你的点子。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;去屎山，一旦使用&lt;code&gt;Zen&lt;/code&gt;的&lt;code&gt;Module&lt;/code&gt;约束，那么它一定是强类型约束，这么做的目的是让业务不容易形成屎山，避免屎上添粪的情况出现（我所在的一些项目就是这样，后期持续性优化，由于业务量巨大，实难以支撑）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;非文档约束性组件控制器绑定，面向对象的模式必然导致代码变得复杂，因使用内嵌代替&lt;code&gt;OOP&lt;/code&gt;，但显然C#做不到，需要额外的封装，但过于麻烦不符合&lt;code&gt;Zen&lt;/code&gt;的设计哲学，故通过静态泛型约束实现。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;无任何反射调度，提高代码的运行速度。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;Hybrid&lt;/code&gt;集成（todo）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>redis</title>
      <link>https://domyson.github.io/post/redis/</link>
      <pubDate>Thu, 24 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/redis/</guid>
      <description>&lt;h1 id=&#34;redis&#34;&gt;Redis&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Remote Dictionary Server,采用 ANSI C 编写的 K-V数据库&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://doc.redisfans.com/index.html&#34;&gt;Redis命令&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://redis.io/download&#34;&gt;Redis下载&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;类型&#34;&gt;类型&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;string&#xA;最大存储值为256mb，底层由SDS(simple dynamic string)实现，优势是访问长度仅需O(1)&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;hash&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;list&#xA;存储有序字符串，最大2^32-1个元素&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;set&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;同list，但不允许重复&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;sorted set&#xA;已排序的都字符串集合，但不允许重复&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&amp;ndash; 其它&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;GEO 地理位置&lt;/li&gt;&#xA;&lt;li&gt;HyperLogLog 基数统计&lt;/li&gt;&#xA;&lt;li&gt;Bitsmap bit数组，类似boolean filter&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;redis设计架构&#34;&gt;redis设计架构&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;单线程业务，多线程存储，redis6.0引入多线程也仅仅是为了提高解析命令的速度&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;虚拟内存&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;虚拟内存机制就是暂时把不经常访问的数据(冷数据)从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据(热数据)。通过VM功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘。这样就可以避免因为内存不足而造成访问速度下降的问题。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;击穿穿透雪崩&#34;&gt;击穿，穿透，雪崩&lt;/h1&gt;&#xA;&lt;h2 id=&#34;击穿&#34;&gt;击穿&lt;/h2&gt;&#xA;&lt;p&gt;某个key在过期点的时候，突然出现大量请求查找这个key&lt;/p&gt;&#xA;&lt;h2 id=&#34;穿透&#34;&gt;穿透&lt;/h2&gt;&#xA;&lt;p&gt;访问一个不存在的key的时候&lt;/p&gt;&#xA;&lt;h2 id=&#34;雪崩&#34;&gt;雪崩&lt;/h2&gt;&#xA;&lt;p&gt;指缓存中数据大批量到过期时间，访问落到db上，造成db压力过大&lt;/p&gt;&#xA;&lt;h1 id=&#34;持久化机制&#34;&gt;持久化机制&lt;/h1&gt;&#xA;&lt;h2 id=&#34;rdb&#34;&gt;RDB&lt;/h2&gt;&#xA;&lt;p&gt;RDB持久化，是指在指定的时间间隔内，执行指定次数的写操作，将内存中的数据集快照写入磁盘中，它是Redis默认的持久化方式。执行完操作后，在指定目录下会生成一个dump.rdb文件，Redis 重启的时候，通过加载dump.rdb文件来恢复数据&lt;/p&gt;&#xA;&lt;p&gt;分为手动触发和自动触发&lt;/p&gt;&#xA;&lt;p&gt;优点 适合大规模的数据恢复场景，如备份，全量复制等&lt;/p&gt;&#xA;&lt;p&gt;缺点 没办法做到实时持久化/秒级持久化。&lt;/p&gt;&#xA;&lt;h2 id=&#34;aof&#34;&gt;AOF&lt;/h2&gt;&#xA;&lt;p&gt;采用日志的形式来记录每个写操作，追加到文件中，重启时再重新执行AOF文件中的命令来恢复数据。它主要解决数据持久化的实时性问题&lt;/p&gt;&#xA;&lt;p&gt;优点 数据一致性和完整性更高&#xA;缺点 内容越多，文件越大，恢复变慢，它需要将所有命令执行一遍&lt;/p&gt;&#xA;&lt;h1 id=&#34;高可用&#34;&gt;高可用&lt;/h1&gt;&#xA;&lt;h2 id=&#34;主从&#34;&gt;主从&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;类似mysql主从，master负责写，slave负责读&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;哨兵&#34;&gt;哨兵&lt;/h2&gt;&#xA;&lt;p&gt;监视其他节点的状态&lt;/p&gt;&#xA;&lt;h2 id=&#34;集群&#34;&gt;集群&lt;/h2&gt;&#xA;&lt;p&gt;Gossip，HashSlot 16384&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/427496556&#34;&gt;View&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;分布式锁&#34;&gt;分布式锁&lt;/h1&gt;&#xA;&lt;h2 id=&#34;setnx&#34;&gt;setnx&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;setnx nx [expired]&lt;/p&gt;</description>
    </item>
    <item>
      <title>iptables and ipvs</title>
      <link>https://domyson.github.io/post/linux/iptables/</link>
      <pubDate>Sat, 19 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/linux/iptables/</guid>
      <description>&lt;h1 id=&#34;iptables&#34;&gt;iptables&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;iptables&lt;/code&gt; 基于 &lt;code&gt;netfilter&lt;/code&gt; 采用一条条规则链表，时间复杂度为O(n)，最主要的是 &lt;code&gt;iptables&lt;/code&gt; 专为防火墙设计&lt;/p&gt;&#xA;&lt;h1 id=&#34;ipvs&#34;&gt;ipvs&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;ipvs&lt;/code&gt; 同样基于 &lt;code&gt;netfilter&lt;/code&gt;，但底层采用的是hash表，索引复杂度为O(1)&lt;/p&gt;</description>
    </item>
    <item>
      <title>kproto 编码协议</title>
      <link>https://domyson.github.io/post/kproto/</link>
      <pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/kproto/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;&#xA;&lt;p&gt;其实在&lt;code&gt;cobweb&lt;/code&gt;之初就设计了一种编码协议(kproto)，用于内部消息的编码,但因为公司项目长期需要维护以及开发（两款线上，一款开发中），所以一直未对此库进行维护，&#xA;而后期在研发的时候，发现需要与多种语言交互，显然 &lt;code&gt;json&lt;/code&gt;,&lt;code&gt;xml&lt;/code&gt; 不是一个很好的选择，而 &lt;code&gt;protobuf&lt;/code&gt; 对弱类型语言支持不友好。&lt;/p&gt;&#xA;&lt;h1 id=&#34;benchmark&#34;&gt;Benchmark&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;cpu: Intel(R) Core(TM) i9-9900K CPU @ 3.60GHz&lt;/li&gt;&#xA;&lt;li&gt;os: windows11&lt;/li&gt;&#xA;&lt;li&gt;arch: amd64&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;format&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;compress rate&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;encode rate&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;decode rate&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;json std&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;0%&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;0%( 213.8 ns/op)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;0%(1204ns/op)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;proto v3&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;-40%&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;-51%(98.36 ns/op)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;-84%(190.1ns/op)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;kproto&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;-40%&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;-76% (65.21 ns/op)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;-95%(62.18ns/op)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>message</title>
      <link>https://domyson.github.io/post/skynet/1/</link>
      <pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/skynet/1/</guid>
      <description>&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;skynet-x&lt;/code&gt;是基于&lt;code&gt;actor&lt;/code&gt; 消息的服务框架，那么我们需要定义一套标准且高效的消息结构&lt;/p&gt;&#xA;&lt;h2 id=&#34;processor&#34;&gt;Processor&lt;/h2&gt;&#xA;&lt;p&gt;一个伪线程的逻辑处理器概念，它分为独占和负载两种模式。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;独占&lt;code&gt;Processor&lt;/code&gt;是为了更好的处理实时性更高的业务，它不会被其他任务抢占&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;负载&lt;code&gt;Processor&lt;/code&gt;又可分为两种运行态，均匀的处理业务以及从其他&lt;code&gt;Processor&lt;/code&gt;上偷窃任务，尽量保证&lt;code&gt;Processor&lt;/code&gt;不会过于闲置，除此之外，负载&lt;code&gt;Processor&lt;/code&gt;可随着任务的变动而增加（不会超过最大设定值），特别的当某个任务陷入”死循环”或者是超出设定运行阈值的时候会重新创建一个&lt;code&gt;Processor&lt;/code&gt;，并让之前的挂起（在C版本中将会被强制关闭）。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;C版本和Go版本调度和设计上差异不大，但一些细节上的处理可能不同，因为C可以提供更多的底层控制&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;pid&#34;&gt;PID&lt;/h2&gt;&#xA;&lt;p&gt;一个 &lt;code&gt;message&lt;/code&gt; 最重要的是消息地址，如果一个消息没有地址的话我们称为 &lt;code&gt;dead-letter&lt;/code&gt;。 那么我们通过&lt;code&gt;Pid&lt;/code&gt; 标定一个地址类型，&lt;/p&gt;&#xA;&lt;p&gt;它表示该服务的唯一id (本质上是一个&lt;code&gt;uint64&lt;/code&gt;)的类习惯，它一定能确保在当前节点以及集群中唯一的。&lt;/p&gt;&#xA;&lt;p&gt;在服务本身未被关闭的时候，&lt;code&gt;pid&lt;/code&gt;一定不会产生变动，但重新启动节点之后，它的值可能会发生改变，因为所有服务默认都是并发启动，除非手动指定了关系(这也是它与&lt;code&gt;skynet-x&lt;/code&gt;的区别)，所以不要尝试保存这个&lt;code&gt;pid&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;一旦能确定了一个&lt;code&gt;pid&lt;/code&gt;的话，就可以通过 &lt;code&gt;skynet.send(pid,cmd,...) or skynet.call(ti,pid,cmd,...)&lt;/code&gt; 将其发送出去了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;服务的消息队列&#34;&gt;服务的消息队列&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;Actor&lt;/code&gt; 模型最重要的的概念是 &lt;code&gt;mailbox&lt;/code&gt;,它代表了一个实体需要处理的队列容器，&lt;/p&gt;&#xA;&lt;p&gt;得益于&lt;code&gt;go&lt;/code&gt;的简单性，可以使用 &lt;code&gt;channel&lt;/code&gt; 来实现，但这种方式的实现性能不高，因为 &lt;code&gt;channel&lt;/code&gt; 底层的结构使用的是互斥锁，&lt;/p&gt;&#xA;&lt;p&gt;所以我采用了&lt;code&gt;mpsc&lt;/code&gt; 实现了无锁队列，性能更优于 &lt;code&gt;channel&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;TODO: 吞吐量对比&lt;/p&gt;&#xA;&lt;h1 id=&#34;消息的接受和发送&#34;&gt;消息的接受和发送&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;发送&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;用户不需要构建这个结构体，仅仅需要指定 &lt;code&gt;destination&lt;/code&gt; 以及需要发送的数据，而且 &lt;code&gt;skynet-x&lt;/code&gt; 消息投递被设计成不允许发送 &lt;code&gt;nil&lt;/code&gt; 因为这是无任何意义的，相反它还会消耗服务投递的性能，如果确实有这种需求，可以发送 &lt;code&gt;struct{}{}&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;而且消息发送成功只能代表被 &lt;code&gt;mailbox&lt;/code&gt; 接受了，不代表会被立即处理，而不会一定处理成功，所以需要正确理解这种方式。&lt;/p&gt;&#xA;&lt;p&gt;如果发送失败，那么一定失败，并返回一个错误&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接收&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;接受回调只包含&lt;code&gt;5&lt;/code&gt;个关键参数 &lt;code&gt;context&lt;/code&gt;,&lt;code&gt;addr&lt;/code&gt;,&lt;code&gt;session&lt;/code&gt;,&lt;code&gt;mtype&lt;/code&gt;,&lt;code&gt;argument&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;context&lt;/code&gt; 其实就是创建服务用户指定的结构指针，用于数据传递和状态修改&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;session&lt;/code&gt; 主要的作用是用以区分这条消息是否是同步请求， 如若大于0，则其值就是请求序列号,只需要通过 &lt;code&gt;skynet.ret(msg)&lt;/code&gt; 返回即可&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;mtype&lt;/code&gt; 仅仅是一个消息类别的区分，类似于消息号，用户可自行定义，可作为&lt;code&gt;rpc&lt;/code&gt;消息类型&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;argument&lt;/code&gt; 才是真实的数据，它可以是任意值，特别的，在&lt;code&gt;lua&lt;/code&gt;中这个值是会被解构，在跨节点通讯这个值恒为 &lt;code&gt;[]byte&lt;/code&gt;，&lt;del&gt;当不需要时记得 skynet.free&lt;/del&gt;  1.4.0 这个由底层回收，用户不用关心&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;异步消息&#34;&gt;异步消息&lt;/h1&gt;&#xA;&lt;p&gt;异步消息通过 &lt;code&gt;skynet.send&lt;/code&gt;的方式进行投递，它只在乎这个消息有没有正确到达到对点服务，而不关心是否能被对点服务正确处理，并返回一个 &lt;code&gt;error&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>skynet-x 服务器框架简介</title>
      <link>https://domyson.github.io/post/skynet/0/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/skynet/0/</guid>
      <description>&lt;p&gt;工作中曾经开发了一个&lt;code&gt;cobweb&lt;/code&gt;的分布式服务器框架（基于&lt;code&gt;golang&lt;/code&gt;,&lt;code&gt;c&lt;/code&gt;）,但是在实际开发过程中代码难以维护以及更新，主要是每次都需要跨平台进行编译，特别是&lt;code&gt;cgo&lt;/code&gt; 往往需要指定平台的系统库,而且一些不规范的使用方式造成无法充分发挥多核的优势，可以参见 &lt;code&gt;关于Go协程的思考&lt;/code&gt; 虽然1.16 支持抢占式，但错误的使用方式依然造成了cpu过高的问题。，后续重新设计了&lt;code&gt;skynet-x&lt;/code&gt; 是一个&lt;code&gt;actor&lt;/code&gt;模型分布式服务框架，使用&lt;code&gt;go&lt;/code&gt;编写。&lt;/p&gt;&#xA;&lt;p&gt;尽管&lt;code&gt;Actor&lt;/code&gt;模型和&lt;code&gt;CSP&lt;/code&gt;模型各有所有长，为什么不采用&lt;code&gt;CSP&lt;/code&gt;主要有两方面考虑。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;CSP&lt;/code&gt;模式使用尽管很简单，但是一个致命的问题是无法控制消息的优先级，当然若只处理一个&lt;code&gt;Channel&lt;/code&gt;那可以规避，那么为啥还需要使用&lt;code&gt;CSP&lt;/code&gt;,而且像go channel 本身是基于互斥锁（1.16）实现，且无法进行优化和更加精细的控制，只能依赖于&lt;code&gt;runtime&lt;/code&gt;的调度。（网上所说什么时候触发调度，我认为channel不能包含其中，它本质也是加锁导致切换）&lt;/li&gt;&#xA;&lt;li&gt;隔离性太弱，后续一些新的&lt;code&gt;channel&lt;/code&gt;引入也会造成破坏性修改，而且 &lt;code&gt;select-case&lt;/code&gt;模式等待的&lt;code&gt;channel&lt;/code&gt;会随着数量的增加性能会慢慢减弱。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;它是一个年轻的框架，仅仅经历了两款项目的迭代 现在版本为 &lt;code&gt;v1.6.0 2023-05-28&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.taptap.cn/app/229839&#34;&gt;羽翼军团&lt;/a&gt; v1.3.0&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.taptap.cn/app/215934&#34;&gt;我在民国淘古玩&lt;/a&gt; v.1.3.5&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;与skynet的差异&#34;&gt;与skynet的差异&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;增加了独占进程的概念，对于一些性能敏感的服务可以绕过公平调度的原则。（公平调度是一个很普遍但并非最优解的调度策略，但对于需要占用资源较多的进程就显得无力）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;使用协程而非线程，一个好处是对于一些假死服务我们可以重新启动它，其它代价远小于线程（尽管协程的开销很低，但我们尽量保证不会被滥用）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一个简单的二进制文件，&lt;code&gt;skynet&lt;/code&gt;修改了lua部分虚拟机源码，而且大部分实现都是基于&lt;code&gt;lua&lt;/code&gt;实现，而我设计的是一个将脚本语言作为可选项的插件。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;所有库都是底层语言的实现方式，可控制力和性能更好，完全将业务和底层区分方便同时进行维护&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;无感的集群交互方式，调用其他服务（无论在不在本地）就像普通消息那样简单，不需要像&lt;code&gt;skynet&lt;/code&gt;需要显示调用&lt;code&gt;cluster&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;进程支持错误重启且消息不会丢失（beta)&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;支持后续的&lt;a href=&#34;https://domyson.github.io/post/typelang/0&#34;&gt;DSL&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;在2024/03我正计划重新用C实现了一版以提供更好的性能和更底层的控制&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>sktpmd</title>
      <link>https://domyson.github.io/post/skynet/3/</link>
      <pubDate>Mon, 30 May 2022 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/skynet/3/</guid>
      <description>&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;sktpmd&lt;/code&gt;模块是&lt;code&gt;skynet-x&lt;/code&gt;底层集群模块，它承担了&lt;code&gt;skynet-x&lt;/code&gt;网络节点之间的通讯职能。全名为(&lt;code&gt;skynet port managment daemon&lt;/code&gt;)&lt;/p&gt;&#xA;&lt;h1 id=&#34;架构&#34;&gt;架构&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;sktpmd&lt;/code&gt; 为了满足对等网络的性质，所以每次和其他节点建立连接是有两条连接，&#xA;当A节点于B节点建立连接，首先A节点发送握手等待B确认，B确认完成之后重复走A的流程，这样一个双向连接就被建立了起来，&lt;strong&gt;&lt;a href=&#34;#v1.6.0%E9%9B%86%E7%BE%A4%E5%BB%BA%E7%AB%8B&#34;&gt;1.6.0&lt;/a&gt;改变了个行为&lt;/strong&gt;，对于像存在类似缓存，或者数据中心的业务而言的单向节点而言，只需要一条连接即可，节省资源。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;sktpmd&lt;/code&gt;现在支持原始的&lt;code&gt;tcp,udp,unix&lt;/code&gt;协议，后续规划可能由&lt;code&gt;reliable udp&lt;/code&gt;实现，降低集群通讯延时并提供更好的性能和时延性。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;远程命名服务，通过内置命令生成唯一的Name，通过Name来与其他节点通讯是友好的。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;使用&#34;&gt;使用&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;启动也非常简单，无须任何代码，仅仅只需要在 &lt;code&gt;conf.conf&lt;/code&gt; 中配置一下即可，使用的时候跟节点内通讯无任何区别。因为我已经作平了本地和节点之间的差异。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;内部均由&lt;a href=&#34;https://domyson.github.io/post/kproto&#34;&gt;kproto&lt;/a&gt;进行编码,提供更快的序列化方式。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;example call&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;skynet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x.send&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;host:port@name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;rpc&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;-- 通过域名或者地址+端口的形式和其他节点进行通讯&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;skynet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x.send&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;alias&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;rpc&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,...)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;-- 通过别名&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;skynet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x.send&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;rpc&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,...)&lt;/span&gt;              &lt;span class=&#34;c1&#34;&gt;-- 通过pid亦可&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;tunnel&#34;&gt;&lt;del&gt;tunnel&lt;/del&gt;&lt;/h1&gt;&#xA;&lt;p&gt;既然节点之间是双向连接，所以连接数量为 &lt;code&gt;f(n) =  n²-n&lt;/code&gt;，如果节点过的时候，势必造成 &lt;code&gt;socket fd&lt;/code&gt; 消耗殆尽，&lt;/p&gt;&#xA;&lt;p&gt;基于这个问题，可以通过内置的&lt;code&gt;tun&lt;/code&gt;，来设置代理，这么一来，&lt;code&gt;tun&lt;/code&gt;的作用相当于这个集群节点的网关。因为其内部的节点相对于其他 &lt;code&gt;tun&lt;/code&gt; 代理是不可见的，&lt;/p&gt;&#xA;&lt;p&gt;通过配置&lt;code&gt;tun&lt;/code&gt;的规则开启多个，则可以实现业务拆分。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;2022-10-07 此模块被弃用，可以用多节点转接的方式或代理的方式做到，如 &lt;code&gt;send(&amp;quot;n1.n2.n3@name&amp;quot;)&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;服务发现&#34;&gt;&lt;del&gt;服务发现&lt;/del&gt;&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;sktpmd&lt;/code&gt; 提供了一套服务发现机制，但其运作原理是不同于 &lt;code&gt;etcd&lt;/code&gt; 或者 &lt;code&gt;consul&lt;/code&gt;,它本身是一个惰性发现，它不需要一个中心服维持它们的关系。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;sktpmd整个发现流程是基于 &lt;code&gt;gossip&lt;/code&gt; 算法来发现的,但一些api依然可以主动触发，&lt;code&gt;v1.6.0&lt;/code&gt; 这个模块将保留，因为集群模式的逻辑改变了&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;v160集群建立&#34;&gt;v1.6.0集群建立&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;v1.5.0&lt;/code&gt; 之前节点之间都是双向链接，但考虑到一个单向服务器，如 &lt;code&gt;dns server&lt;/code&gt;,&lt;code&gt;conf server&lt;/code&gt; 等，大部分是 &lt;code&gt;request/response&lt;/code&gt; 模式，惰性连接的收益很大，所以去除之前的一些设计。&lt;/p&gt;&#xA;&lt;h1 id=&#34;网络底层&#34;&gt;网络底层&lt;/h1&gt;&#xA;&lt;p&gt;参考 &lt;a href=&#34;https://domyson.github.io/post/language/go/goroutine&#34;&gt;Go协程的思考&lt;/a&gt;,在&lt;code&gt;linux&lt;/code&gt;下，使用了 &lt;code&gt;epoll&lt;/code&gt;。所以尽量部署到 &lt;code&gt;linux&lt;/code&gt; 下以发挥更好的性能&lt;/p&gt;</description>
    </item>
    <item>
      <title>zmalloc</title>
      <link>https://domyson.github.io/post/skynet/5/</link>
      <pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/skynet/5/</guid>
      <description>&lt;p&gt;无论是对于C版本还是Go版本的&lt;code&gt;skynet-x&lt;/code&gt;而言，一个高效的内存分配器可以提高内存的使用效率，这里效率无论是对于内存碎片亦或是GC而言，都是一种更高效的手段&lt;/p&gt;&#xA;&lt;h1 id=&#34;基于-slab-算法的分段内存分配器&#34;&gt;基于 &lt;code&gt;SLAB&lt;/code&gt; 算法的分段内存分配器&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;SLAB&lt;/code&gt; 最开始是阅读 &lt;code&gt;linux&lt;/code&gt; 源码学习的算法，在&lt;code&gt;skynet-x&lt;/code&gt;中它确实有更优秀的性能，因为它直接分配了一块大共用内存，所以不会产生任何GC和真实分配,但在业务开发过程中，一旦忘记释放 那么这段内存将不能再被使用和获取了（也就是野指针），直到程序结束。最后的保守策略依然会向&lt;code&gt;runtime&lt;/code&gt;申请内存，将会导致内存占用过高。&lt;/p&gt;&#xA;&lt;p&gt;而且内置的&lt;code&gt;Debug&lt;/code&gt;模式也无法定位到这个指针，原因在于 golang 堆栈伸缩会导致指针地址变动，所以 &lt;code&gt;Debug&lt;/code&gt; 只能定位到存在 &lt;code&gt;memory-leak&lt;/code&gt;，而无法知道具体位置。若需要具体位置则需要hook这个调用栈，性能方面得不偿失&lt;/p&gt;&#xA;&lt;h1 id=&#34;基于-syncpool-的分段内存分配器&#34;&gt;基于 &lt;code&gt;sync.Pool&lt;/code&gt; 的分段内存分配器&lt;/h1&gt;&#xA;&lt;p&gt;将不同size的buffer放入不同的池中，按需进行分配，减少race的开销，这个方法虽然简单，但是性能是低于 &lt;code&gt;slab-allocator&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;但它确实能减轻心智负担，代价就是牺牲了部分性能以及gc压力，但这也是&lt;code&gt;skynet-x&lt;/code&gt;默认使用的策略。如果需要使用可以在编译指令中指明&lt;code&gt;slab&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;zmalloc&#34;&gt;Zmalloc&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;zmlloc&lt;/code&gt; 本身也是 &lt;code&gt;slab&lt;/code&gt;的升级版本，增加可伸缩链表实现对于预分配内存额外部分的缓冲池。&lt;/p&gt;&#xA;&lt;p&gt;在24个线程的cpu条件测试结果如下,&lt;code&gt;zmalloc&lt;/code&gt;保持了一种稳定的时间复杂度，额外产生的内存分配也很少&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;-&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;time(ns)&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;alloc/op(B)&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;slab-128&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;23.5&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;sync.Pool-128&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;2490&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;65562&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;zmalloc-128&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;43.31&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;16&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;slab-256&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;24&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;256&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;sync.Pool-256&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;2204&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;65562&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;zmalloc-256&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;44&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;16&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;slab-1024&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;92&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;1024&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;sync.Pool-1024&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;2490&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;65562&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;zmalloc-1024&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;49&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;17&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;slab-4096&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;365&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;4096&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;sync.Pool-4096&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;2210&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;65562&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;zmalloc-4096&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;45&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;23&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h1 id=&#34;api&#34;&gt;API&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;skynet.zalloc(n)&lt;/code&gt; 用以分配指定大小的内存块，考虑到 64在go中为tiny-size，直接会从P上分配，所以zmalloc分配块从128开始&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;skynet.zrealloc(buf,n)&lt;/code&gt; realloc函数会先检查buf，确保是否需要重新分配内存&lt;/p&gt;</description>
    </item>
    <item>
      <title>sync.pool</title>
      <link>https://domyson.github.io/post/lang/sync.pool/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/lang/sync.pool/</guid>
      <description>&lt;h1 id=&#34;结构分析&#34;&gt;结构分析&lt;/h1&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Pool&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;nx&#34;&gt;noCopy&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;noCopy&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;nx&#34;&gt;local&lt;/span&gt;     &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// P 本地池，固定尺寸，实际结构 [P]poolLocal，类似 void* 并附加长度构成了一个数组&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&lt;span class=&#34;nx&#34;&gt;localSize&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// size of the local array&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;nx&#34;&gt;victim&lt;/span&gt;     &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// local from previous cycle&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&lt;span class=&#34;nx&#34;&gt;victimSize&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// size of victims array&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;nx&#34;&gt;New&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;any&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;poolChain&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;head&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;poolChainElt&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;poolChainElt&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;poolChainElt&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 一个双向链表&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;poolDequeue&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;prev&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;poolChainElt&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;poolDequeue&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;headtail&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint64&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;vals&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;eface&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;eface&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 数据的真实内存分配，包括一个类型描述和实际数据&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;typ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;poolLocalInternal&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;any&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// p的私有缓冲区&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;shared&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;poolChain&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 公共缓冲区&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;poolLocal&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;poolLocalInternal&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;pad&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;128&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;poolLocalInternal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;128&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 应该是补位，可以确保刚好占满一个 cache line 加速访问&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;申请释放&#34;&gt;申请释放&lt;/h1&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;poolLocal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;nx&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;runtime_procPin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 将当前G和P绑定，并返回P的id&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;runtime_LoadAcquintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;localSize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// load-acquire&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;local&lt;/span&gt;                              &lt;span class=&#34;c1&#34;&gt;// load-consume&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 主要是P的数量可能会变动 重新找一个&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&#x9;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;indexLocal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pid&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;pinSlow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;pinSlow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;poolLocal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;nf&#34;&gt;runtime_procUnpin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 禁止 P 抢占，否则当前G会被放回本地或者全局队列，当时之后G不一定在现在这个P上&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&lt;span class=&#34;nx&#34;&gt;allPoolsMu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;allPoolsMu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;nx&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;runtime_procPin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;localSize&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;local&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// double check&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&#x9;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;indexLocal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pid&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;local&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 如果本地队列为空，那么此时Pool没被初始化，加入全局池引用&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&#x9;&lt;span class=&#34;nx&#34;&gt;allPools&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;allPools&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;runtime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;GOMAXPROCS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 查看现在P的个数&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&lt;span class=&#34;nx&#34;&gt;local&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;poolLocal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 为这个Pool分配跟P数量相同的本地池&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;StorePointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;local&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;local&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]))&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// store-release&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&lt;span class=&#34;nf&#34;&gt;runtime_StoreReluintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;localSize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;     &lt;span class=&#34;c1&#34;&gt;// store-release&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;local&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 返回当前和P绑定的本地池&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;any&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;race&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Enabled&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&#x9;&lt;span class=&#34;nx&#34;&gt;race&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Disable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 先找本地池&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;private&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 如果没有，那么从全局池找&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&#x9;&lt;span class=&#34;c1&#34;&gt;// Try to pop the head of the local shard. We prefer&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&#x9;&lt;span class=&#34;c1&#34;&gt;// the head over the tail for temporal locality of&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&#x9;&lt;span class=&#34;c1&#34;&gt;// reuse.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&#x9;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;shared&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;popHead&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&#x9;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&#x9;&#x9;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;getSlow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&#x9;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;nf&#34;&gt;runtime_procUnpin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//释放P，让其可以被抢占&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;race&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Enabled&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&#x9;&lt;span class=&#34;nx&#34;&gt;race&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Enable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&#x9;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&#x9;&#x9;&lt;span class=&#34;nx&#34;&gt;race&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Acquire&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;poolRaceAddr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&#x9;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;New&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&#x9;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;New&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Put adds x to the pool.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Put&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;any&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&#x9;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;race&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Enabled&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&#x9;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fastrandn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&#x9;&#x9;&lt;span class=&#34;c1&#34;&gt;// Randomly drop x on floor.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&#x9;&#x9;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&#x9;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&#x9;&lt;span class=&#34;nx&#34;&gt;race&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ReleaseMerge&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;poolRaceAddr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&#x9;&lt;span class=&#34;nx&#34;&gt;race&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Disable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 老规矩，先禁止P被抢占&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 本地没有 则先放入本地&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&#x9;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&#x9;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;shared&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;pushHead&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 否则放入全局&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#x9;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;nf&#34;&gt;runtime_procUnpin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;race&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Enabled&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&#x9;&lt;span class=&#34;nx&#34;&gt;race&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Enable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;gc&#34;&gt;GC&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;其实很好理解，正好是一次二级缓冲模型，第一次gc会将local放入 victim，第二gc victim不为空才会真正清理，local不会参与gc&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cgo</title>
      <link>https://domyson.github.io/post/lang/cgo/</link>
      <pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/lang/cgo/</guid>
      <description>&lt;h1 id=&#34;cgo-一种go与c交互的技术&#34;&gt;cgo 一种go与c交互的技术&lt;/h1&gt;&#xA;&lt;h2 id=&#34;开启cgo&#34;&gt;开启cgo&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;要求系统安装C/C++工具链，macos和linux(gcc 自带)，windows(mingw),并确保环境变量&lt;code&gt;CGO_ENAVBLE=on&lt;/code&gt;,最后单个源码需要导入 &lt;code&gt;import &amp;quot;C&amp;quot;&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;cgo类型映射&#34;&gt;cgo类型映射&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;C type&lt;/th&gt;&#xA;          &lt;th&gt;Cgo type&lt;/th&gt;&#xA;          &lt;th&gt;Go type&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;char&lt;/td&gt;&#xA;          &lt;td&gt;C.char&lt;/td&gt;&#xA;          &lt;td&gt;byte&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;signed char&lt;/td&gt;&#xA;          &lt;td&gt;C.schar&lt;/td&gt;&#xA;          &lt;td&gt;int8&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;unsigned char&lt;/td&gt;&#xA;          &lt;td&gt;C.uchar&lt;/td&gt;&#xA;          &lt;td&gt;uint8&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;short&lt;/td&gt;&#xA;          &lt;td&gt;C.short&lt;/td&gt;&#xA;          &lt;td&gt;int16&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;unsigned short&lt;/td&gt;&#xA;          &lt;td&gt;C.ushort&lt;/td&gt;&#xA;          &lt;td&gt;uint16&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;int&lt;/td&gt;&#xA;          &lt;td&gt;C.int&lt;/td&gt;&#xA;          &lt;td&gt;int32&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;unsigned int&lt;/td&gt;&#xA;          &lt;td&gt;C.uint&lt;/td&gt;&#xA;          &lt;td&gt;uint32&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;long&lt;/td&gt;&#xA;          &lt;td&gt;C.long&lt;/td&gt;&#xA;          &lt;td&gt;int32&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;unsigned long&lt;/td&gt;&#xA;          &lt;td&gt;C.ulong&lt;/td&gt;&#xA;          &lt;td&gt;uint32&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;long long int&lt;/td&gt;&#xA;          &lt;td&gt;C.longlong&lt;/td&gt;&#xA;          &lt;td&gt;int64&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;unsigned long long int&lt;/td&gt;&#xA;          &lt;td&gt;C.ulonglong&lt;/td&gt;&#xA;          &lt;td&gt;uint64&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;float&lt;/td&gt;&#xA;          &lt;td&gt;C.float&lt;/td&gt;&#xA;          &lt;td&gt;float32&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;double&lt;/td&gt;&#xA;          &lt;td&gt;C.double&lt;/td&gt;&#xA;          &lt;td&gt;double&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;size_t&lt;/td&gt;&#xA;          &lt;td&gt;C.size_t&lt;/td&gt;&#xA;          &lt;td&gt;uint&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;函数指针&#34;&gt;函数指针&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;go引用c的函数指针比较特别&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;官方给出的&lt;a href=&#34;https://github.com/golang/go/wiki/cgo#function-pointer-callbacks&#34;&gt;Example&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;我这里给出另外一种,通过c wrap 这个函数指针成一个普通函数，然后go调用它&lt;/p&gt;</description>
    </item>
    <item>
      <title>Mysql QA</title>
      <link>https://domyson.github.io/post/mysql100%E9%97%AE/</link>
      <pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/mysql100%E9%97%AE/</guid>
      <description>&lt;h1 id=&#34;聚集非聚集联合索引&#34;&gt;聚集、非聚集、联合索引&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;A1: 聚集索引（主键索引）所有ROW都会按照主键索引进行排序&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;A2: 非聚集索引即普通索引加上字段&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;A3: 几个字段组成的索引&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;A4: 聚集索引在物理上连续，非聚集索引在物理上不连续，但在逻辑上连续&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;A5: 聚集索引影响物理存储顺序，而非聚集索引不影响&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;A6: 聚集索引插入慢，查询快，非聚集索引反之&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;A7: 索引是通过二叉树来描述的，聚集索引的子叶节点也是数据节点，而非聚集索引子叶节点仍是索引节点&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;自增主键有哪些问题&#34;&gt;自增主键有哪些问题&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;A1: 分表分库的时候可能会出现重复情况（可使用uuid替代）&lt;/li&gt;&#xA;&lt;li&gt;A2: 产生表锁&lt;/li&gt;&#xA;&lt;li&gt;A3: id耗尽&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;索引无效的情况&#34;&gt;索引无效的情况&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;A1: 以&lt;code&gt;%&lt;/code&gt;开头的&lt;code&gt;LIKE&lt;/code&gt;语句，模糊匹配&lt;/li&gt;&#xA;&lt;li&gt;A2: &lt;code&gt;OR&lt;/code&gt; 前后字段未同时使用索引&lt;/li&gt;&#xA;&lt;li&gt;A3: 数据类型隐式转换（varchar-&amp;gt;int)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;查询优化&#34;&gt;查询优化&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;A1: 在&lt;code&gt;WHERE&lt;/code&gt;和&lt;code&gt;ORDER BY&lt;/code&gt;所涉及的列上加上索引&lt;/li&gt;&#xA;&lt;li&gt;A2: &lt;code&gt;SELECT&lt;/code&gt;避免使用&lt;code&gt;*&lt;/code&gt;,SQL语句全部大写&lt;/li&gt;&#xA;&lt;li&gt;A3: 避免&lt;code&gt;WHERE&lt;/code&gt;对索引列上进行&lt;code&gt;IS NULL&lt;/code&gt;判断，替换成&lt;code&gt;IS NOT NULL&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;A4: &lt;code&gt;IN&lt;/code&gt;和&lt;code&gt;NOT IN&lt;/code&gt;会导致全表扫描,替换为&lt;code&gt;EXISTS&lt;/code&gt;或&lt;code&gt;NOT EXISTS&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;A5: 避免在索引上进行计算&lt;/li&gt;&#xA;&lt;li&gt;A6: &lt;code&gt;WHRER&lt;/code&gt;使用&lt;code&gt;OR&lt;/code&gt;会放弃索引进而全表扫描&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;char和varchar的区别&#34;&gt;CHAR和VARCHAR的区别&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;A1: 存储和检索方式不同&lt;/li&gt;&#xA;&lt;li&gt;A2: &lt;code&gt;CHAR&lt;/code&gt;长度在创建时候指定(1~255),在存储时尾部全部填充空格&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;主键索引和唯一索引的区别&#34;&gt;主键索引和唯一索引的区别&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;A1: 主键是一种约束&lt;/li&gt;&#xA;&lt;li&gt;A2: 主键一定包含一个唯一索引，反之不成立&lt;/li&gt;&#xA;&lt;li&gt;A3: 主键索引不允许包含空值，而唯一索引可以&lt;/li&gt;&#xA;&lt;li&gt;A4: 一张表只能有一个主键索引，而唯一索引可以有多个&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;cpu飙升问题排查&#34;&gt;CPU飙升问题排查&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;A1: top命令观察&lt;code&gt;mysqld&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;A2: 若是，则&lt;code&gt;show processlist&lt;/code&gt;查看是否是 SQL 的问题，&lt;/li&gt;&#xA;&lt;li&gt;A3: 若是，则检查执行计划是否准确，是否索引确实，数据是否太大&lt;/li&gt;&#xA;&lt;li&gt;A4: kill上述线程，加索引，改内存，改SQL并重跑&lt;/li&gt;&#xA;&lt;li&gt;A5: 若不是，可能是短时间有大量连接，可以限制最大连接数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;如何创建索引&#34;&gt;如何创建索引&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;A1:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go GC分析</title>
      <link>https://domyson.github.io/post/lang/gc/</link>
      <pubDate>Sat, 26 Feb 2022 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/lang/gc/</guid>
      <description>&lt;h1 id=&#34;如何启用gc跟踪&#34;&gt;如何启用GC跟踪&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;GODEBUG=gctrace=1 go run *.go&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;其中 &lt;code&gt;gctrace=1&lt;/code&gt; 表示只针对这个进程进行GC追踪&lt;/p&gt;&#xA;&lt;h1 id=&#34;标记流程&#34;&gt;标记流程&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;go采用三色标记法，主要是为了提高并发度，这样扫描过程可以拆分为多个阶段，而不用一次扫描全部&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;黑 根节点扫描完毕，子节点也扫描完毕&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;灰 根节点扫描完毕，子节点未扫描&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;白 未扫描&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;扫描是从 .bss .data goroutine栈开始扫描，最终遍历整个堆上的对象树&lt;/p&gt;&#xA;&lt;h2 id=&#34;标记-mark&#34;&gt;标记 mark&lt;/h2&gt;&#xA;&lt;p&gt;标记过程是一个广度优先的遍历过程，扫描节点，将节点的子节点推送到任务队列中，然后递归扫描子叶节点，直到所有工作队列被排空&lt;/p&gt;&#xA;&lt;p&gt;mark阶段会将白色对象标记，并推入队列中变为灰色&lt;/p&gt;&#xA;&lt;h1 id=&#34;memory-barrier&#34;&gt;memory barrier&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;保障了代码描述中对内存的操作顺序，&lt;code&gt;即不会在编译期被编译器进行调整，也不会在运行时被CPU的乱序执行所打乱&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;write-barrier&#34;&gt;write barrier&lt;/h2&gt;&#xA;&lt;p&gt;在应用进入 GC 标记阶段前的 stw 阶段，会将全局变量 runtime.writeBarrier.enabled 修改为 true，这时所有的堆上指针修改操作在修改之前便会额外调用 runtime.gcWriteBarrier&lt;/p&gt;&#xA;&lt;p&gt;由于GC和Go主程序并发执行，所以必须要在扫描时监控内存可能出现的状态改变，所以需要写屏障，所以需要暂停GO主程序（STW）&lt;/p&gt;&#xA;&lt;h2 id=&#34;hybrid-wirte-barrier-after-go18&#34;&gt;hybrid wirte barrier (after go1.8)&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;改方式的基本思想是：对正在被覆盖的对象进行着色，且如果当时栈未扫描完成，则同样对指针进行着色&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;gc流程&#34;&gt;GC流程&lt;/h1&gt;&#xA;&lt;p&gt;程序启动会为每个P分配一个 mark worker 来标记内存，负责为进入STW做前期工作&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;起初认为所有 object 都被认定为白色&lt;/li&gt;&#xA;&lt;li&gt;但栈，堆和全局变量的object被标记为灰色&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;GC会将灰色object标记为黑色，将灰色object所包含的所有指针所指向的地址都标记为灰色，递归这两个步骤，最终对象非黑即白，其中白色object即未被引用且可以被回收，如果object标记为no scan，则递归结束，标记为黑色&lt;/p&gt;&#xA;&lt;p&gt;todo &lt;a href=&#34;https://blog.csdn.net/asd1126163471/article/details/124113816&#34;&gt;https://blog.csdn.net/asd1126163471/article/details/124113816&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>tcp协议</title>
      <link>https://domyson.github.io/post/linux/tcp/</link>
      <pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/linux/tcp/</guid>
      <description>&lt;h1 id=&#34;什么是-tcp&#34;&gt;什么是 Tcp&lt;/h1&gt;&#xA;&lt;h1 id=&#34;三次握手&#34;&gt;三次握手&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;tcp client发送连接请求报文，报文首部同步标记位 SYN=1 同时随机序列号 seq=x，此时 tcp client 进入 &lt;code&gt;SYNC-SENT&lt;/code&gt; 状态的&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;tcp server 若同意连接则确认报文为 &lt;code&gt;ACK=1,SYN=1,ASK=x+1,seq=y&lt;/code&gt; 返回给客户端，并进入 &lt;code&gt;SYNC_RCVD&lt;/code&gt; 状态&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;tcp client 收到回复并确认 ACK 是否为1，seq 是否为 x+1,并返回报文 &lt;code&gt;ACK=1,ASK=y+1&lt;/code&gt;,此时双方进入 &lt;code&gt;ESTABLISHED&lt;/code&gt; 状态&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;四次挥手&#34;&gt;四次挥手&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主动方发送报文&lt;code&gt;FIN=1,seq=last+1&lt;/code&gt;并进入&lt;code&gt;FIN_WAIT_1&lt;/code&gt;,此时报文不能携带任何数据&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;被动方收到连接释放报文，并发送确认报文 &lt;code&gt;ACK=1,ack=u+1,seq=v&lt;/code&gt; ，并进入 &lt;code&gt;CLOSE_WAIT&lt;/code&gt;状态，但此时如果缓冲区存在未发送数据，那么需要继续发送（这也是 CLOSE_WAIT 持续的时长），主动方收到此条报文后进入 &lt;code&gt;FIN_WAIT_2&lt;/code&gt;,因为还需要处理未发送数据&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;上一步执行完毕，被动方发送 &lt;code&gt;FIN=1,ack=w+1,seq=u+1&lt;/code&gt; 并进入 &lt;code&gt;LAST-ACK&lt;/code&gt; 状态，而主动方收到此条报文后进入 &lt;code&gt;TIME_WAIT&lt;/code&gt; （2msl maximum segment life），之后才会进入 &lt;code&gt;CLOSED&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;在主动方进入 &lt;code&gt;CLOSED&lt;/code&gt; 之前，需要发送报文确认退出&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;2msl&#34;&gt;2MSL&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;1MSL保证主动方最后的 ACK 能到达对端，1MSL 确保 ACK 重传&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;如何确保可靠性&#34;&gt;如何确保可靠性&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;三次握手，四次挥手确保连接和断开的可靠&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;记录了哪些数据被接受，哪些未接收，序列号保证了消息的顺序性&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;ACK应答，超时重传，失序重传，丢弃重复数据，流量控制，拥塞控制&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;重传机制&#34;&gt;重传机制&lt;/h1&gt;&#xA;&lt;h2 id=&#34;rttrto&#34;&gt;RTT，RTO&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Round-Trip Time 消息往返时间  Retransmission Timeout 超时重传&lt;/p&gt;</description>
    </item>
    <item>
      <title>unsafe包</title>
      <link>https://domyson.github.io/post/lang/unsafe/</link>
      <pubDate>Wed, 25 Aug 2021 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/lang/unsafe/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;Golang 默认指针是类型安全的，但它有很多限制。Golang 还有非类型安全的指针，这就是 unsafe 包提供的 unsafe.Pointer。在某些情况下，它会使代码更高效，当然，也更危险。unsafe 包用于 Go 编译器，在编译阶段使用。从名字就可以看出来，它是不安全的，官方并不建议使用。Go 语言类型系统是为了安全和效率设计的，有时，安全会导致效率低下。unsafe 包绕过了 Go 的类型系统，达到直接操作内存的目的，使用它有一定的风险性。但是在某些场景下，使用 unsafe 包提供的函数会提升代码的效率，Go 源码中也是大量使用 unsafe 包。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;unsafe-包&#34;&gt;&lt;code&gt;unsafe&lt;/code&gt; 包&lt;/h1&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//定义&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ArbitraryType&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ArbitraryType&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//函数&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;AribitraryType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Offsetof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;AribitraryType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Alignof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;AribitraryType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;分析&#34;&gt;分析&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;Pointer&lt;/code&gt; : 指向任意类型，类似于 C 中的 &lt;code&gt;void*&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;Sizeof&lt;/code&gt; : 返回所传类型的大小，指针只返回指针的本身（&lt;code&gt;x64 8byte x86 4byte&lt;/code&gt;），而不会返回所指向的内存大小。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;Offsetof&lt;/code&gt; : 返回 &lt;code&gt;struct&lt;/code&gt; 成员在内存中的位置，相对于此结构体的头位置，所传参数必须是结构体成员。传入指针，或者结构体本身，会 &lt;code&gt;error&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;Alignof&lt;/code&gt; : 返回 M，M 是内存对齐时的倍数。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;任意指针都可以和 &lt;code&gt;unsafe.Pointer&lt;/code&gt; 相互转换。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;uintptr&lt;/code&gt; 可以和 &lt;code&gt;unsafe.Pointer&lt;/code&gt; 相互转换。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;综上，&lt;code&gt;unsafe.Pointer&lt;/code&gt; 是不能进行指针运算的，只能先转为 &lt;code&gt;uintptr&lt;/code&gt; 计算完再转回 &lt;code&gt;unsafe.Pointer&lt;/code&gt; ,还有一点要注意的是，&#xA;&lt;code&gt;uintptr&lt;/code&gt; 并没有指针的语义，意思就是 &lt;code&gt;uintptr&lt;/code&gt; 所指向的对象会被 gc。而 &lt;code&gt;unsafe.Pointer&lt;/code&gt; 有指针语义，可以保护它所指向的对象在“有用”的时候不会被垃圾回收。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Unity性能优化方案</title>
      <link>https://domyson.github.io/post/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <description>&lt;h1 id=&#34;音频&#34;&gt;音频&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;短音频使用Wav，长音频使用mp3&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;纹理&#34;&gt;纹理&lt;/h1&gt;&#xA;&lt;h2 id=&#34;mipmap&#34;&gt;Mipmap&lt;/h2&gt;&#xA;&lt;p&gt;mipmap用于减少渲染的带宽压力，但会有额外的内存开销，一般而言UI是建议关闭的，3D模型看情况开启&lt;/p&gt;&#xA;&lt;h2 id=&#34;readwrite&#34;&gt;Read/Write&lt;/h2&gt;&#xA;&lt;h2 id=&#34;纹理尺寸&#34;&gt;纹理尺寸&lt;/h2&gt;&#xA;&lt;p&gt;不同大小的纹理尺寸对内存的占用也是不同，依照项目的实际情况来决定Size&lt;/p&gt;&#xA;&lt;h2 id=&#34;格式&#34;&gt;格式&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;由于ETC、PVRTC等格式均为有损压缩，因此，当纹理色差范围跨度较大时，均不可避免地造成不同程度的“阶梯”状的色阶问题。因此，很多研发团队使用RGBA32/ARGB32格式来实现更好的效果。但是，这种做法将造成很大的内存占用&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;ETC1 不支持透明通道问题&#xA;可以通过 RGB24 + Alpha8 + Shader 的方式达到比较好的效果&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;ECT2，ASTC&#xA;但需要设备支持 OpenGL ES3.0&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;lod&#34;&gt;LOD&lt;/h1&gt;&#xA;&lt;p&gt;unity内置的一项技术，主要是根据目标离相机的距离来断定使用何种精度的模型，减少顶点数的绘制，但代价就是要牺牲部分内存&lt;/p&gt;&#xA;&lt;h1 id=&#34;occlusion-culling-遮挡剔除&#34;&gt;Occlusion culling 遮挡剔除&lt;/h1&gt;&#xA;&lt;p&gt;遮挡剔除是用来消除躲在其他物件后面看不到的物件，这代表资源不会浪费在计算那些看不到的顶点上，进而提升性能&lt;/p&gt;&#xA;&lt;h1 id=&#34;batching&#34;&gt;batching&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;dynamic batching&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;将一些足够小的网格，在CPU上转换它们的顶点，将许多相似的顶点组合在一起，并一次性绘制它们。&#xA;无论静态还是动态合批都要求使用相同的材质，动态合批有以下限制：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;+ 如果GameObjects在Transform上包含镜像，则不会对其进行动态合批处理&#xA;&#xA;+ 使用多个pass的shader不会被动态合批处理&#xA;&#xA;+ 使用不同的Material实例会导致GameObjects不能一起批处理，即使它们基本相同。&#xA;&#xA;+ [官方25个不能动批的情况](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FUnity-Technologies%2FBatchBreakingCause)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;static batching&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;静态合批是将静态（不移动）GameObjects组合成大网格，然后进行绘制。静态合批使用比较简单，PlayerSettings中开启static batching，然后对需要静态合批物体的Static打钩即可，unity会自动合并被标记为static的对象，前提它们共享相同的材质，并且不移动，被标记为static的物体不能在游戏中移动，旋转或缩放。但是静态批处理需要额外的内存来存储合并的几何体。注意如果多个GameObject在静态批处理之前共享相同的几何体，则会在编辑器或运行时为每个GameObject创建几何体的副本，这会增大内存的开销&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/70123645&#34;&gt;GPU Instancing&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;使用GPU Instancing可以一次渲染(render)相同网格的多个副本，仅使用少量DrawCalls。在渲染诸如建筑、树木、草等在场景中重复出现的事物时，GPU Instancing很有用。&lt;/p&gt;&#xA;&lt;p&gt;每次draw call，GPU Instancing只渲染相同(identical )的网格，但是每个实例(instance)可以有不同的参数(例如，color或scale)，以增加变化(variation)，减少重复的出现。&lt;/p&gt;&#xA;&lt;p&gt;GPU Instancing可以减少每个场景draw calls次数。这显著提升了渲染性能。&lt;/p&gt;&#xA;&lt;h1 id=&#34;physics&#34;&gt;Physics&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Auto Simulation&#xA;根据项目实际需要是否开启物理模拟，默认是是开启的&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Fixed Timestep&#xA;过小的值会操成计算量过大，过大的值可能造成部分机制异常(如卡墙，穿透等)，根据项目实际来确定&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Maximum Allowed Timestep&#xA;这里我们需要先知道物理系统本身的特性，即当游戏上一帧卡顿时，Unity会在当前帧非常靠前的阶段连续调用N次FixedUpdate.PhysicsFixedUpdate，Maximum Allowed Timestep的意义就在于单帧限制物理更新的次数，&lt;/p&gt;</description>
    </item>
    <item>
      <title>TLS</title>
      <link>https://domyson.github.io/post/linux/tls/</link>
      <pubDate>Sun, 09 Feb 2020 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/linux/tls/</guid>
      <description>&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;&#xA;&lt;p&gt;传输层安全性协议（Transport Layer Security），及其前身 &lt;code&gt;SSL3.0&lt;/code&gt; 之后安全套接层（Secure Sockets Layer，缩写作SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。SSL包含记录层（Record Layer）和传输层，记录层协议确定传输层数据的封装格式。传输层安全协议使用X.509认证，之后利用&lt;code&gt;RSA&lt;/code&gt; 加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）。这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。&lt;/p&gt;&#xA;&lt;h1 id=&#34;作用&#34;&gt;作用&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;TLS协议的优势是与高层的应用层协议（如HTTP、FTP、Telnet等）无耦合。应用层协议能透明地运行在TLS协议之上，由TLS协议进行创建加密通道需要的协商和认证。应用层协议传送的数据在通过TLS协议时都会被加密，从而保证通信的私密性。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;连接过程&#34;&gt;连接过程&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;当客户端连接到支持TLS协议的服务器要求创建安全连接并列出了受支持的密码组合（加密密码算法和加密哈希函数），握手开始。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;服务器从该列表中决定加密和散列函数，并通知客户端。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;服务器发回其数字证书，此证书通常包含服务器的名称、受信任的证书颁发机构（CA）和服务器的公钥。&#xA;客户端确认其颁发的证书的有效性。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;为了生成会话密钥用于安全连接，客户端使用服务器的公钥加密随机生成的密钥，并将其发送到服务器，只有服务器才能使用自己的私钥解密。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;利用随机数，双方生成用于加密和解密的对称密钥。这就是TLS协议的握手，握手完毕后的连接是安全的，直到连接（被）关闭。如果上述任何一个步骤失败，TLS握手过程就会失败，并且断开所有的连接。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;tls协议&#34;&gt;TLS协议&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;https&lt;/code&gt; 本身基于 &lt;code&gt;http&lt;/code&gt; 传输，但是信息通过了 &lt;code&gt;tls&lt;/code&gt; 协议加密。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;tls&lt;/code&gt; 协议位于传输层之上，应用层之下。首次进行 &lt;code&gt;tls 1.3&lt;/code&gt; 协议传输需要一个 RTT&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;tls&lt;/code&gt; 可以使用对称加密和非对称加密。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;握手过程&#34;&gt;握手过程&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;客户端发送一个随机值以及需要的协议和加密方式。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，并且发送自己的证书（如果需要验证客户端证书需要说明）。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;之后通过此非对称加密传输的对称加密的密钥来进行正式通讯。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>process</title>
      <link>https://domyson.github.io/post/linux/process/</link>
      <pubDate>Wed, 25 Dec 2019 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/linux/process/</guid>
      <description>&lt;h1 id=&#34;进程状态&#34;&gt;进程状态&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;TASK_RUNNING&lt;/li&gt;&#xA;&lt;li&gt;TASK_INTERRUPTIBLE&lt;/li&gt;&#xA;&lt;li&gt;TASK_UNINTERRUPTIBLE&lt;/li&gt;&#xA;&lt;li&gt;TASK_TRACED&lt;/li&gt;&#xA;&lt;li&gt;TASK_STOPPED&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Protobuf3</title>
      <link>https://domyson.github.io/post/protobuf/</link>
      <pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/protobuf/</guid>
      <description>&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;Protocol Buffers&lt;/code&gt;，是Google公司开发的一种数据描述语言，类似于XML能够将结构化数据序列化，可用于数据存储、通信协议等方面。本文只介绍 &lt;code&gt;syntax = proto3&lt;/code&gt; 的协议语法。&lt;/p&gt;&#xA;&lt;h1 id=&#34;标准类型对照&#34;&gt;标准类型对照&lt;/h1&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;.proto&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;注释&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;C++&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;Python&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;Go&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;C#&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;double&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;定长编码&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;double&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;float&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;float64&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;double&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;float&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;定长编码&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;float&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;float&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;float32&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;float&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;int32&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;变长编码,负数编码效率低，可使用&lt;code&gt;sint32&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;int32&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;int&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;int32&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;int&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;int64&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;变长编码,负数编码效率低，可使用&lt;code&gt;sint64&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;int64&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;int/long&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;int64&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;long&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;uint32&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;变长编码&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;uint32&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;int/long&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;uint32&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;uint&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;uint64&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;变长编码&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;uint64&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;int/long&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;unit64&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;ulong&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;sint32&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;变长编码，对负数编码比&lt;code&gt;int32&lt;/code&gt;更有效率&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;int32&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;int&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;int32&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;int&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;sint64&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;变长编码，对负数编码比&lt;code&gt;int64&lt;/code&gt;更有效率&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;int64&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;int/long&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;int64&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;long&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;fixed32&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;总是&lt;code&gt;4&lt;/code&gt;字节，如果值大于&lt;code&gt;2^28&lt;/code&gt;比&lt;code&gt;uint32&lt;/code&gt;更有效率&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;uint32&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;int/long&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;uint64&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;ulong&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;fixed64&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;总是&lt;code&gt;8&lt;/code&gt;字节，如果值大于&lt;code&gt;2^56&lt;/code&gt;比&lt;code&gt;uint64&lt;/code&gt;更有效率&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;uint64&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;int/long&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;uint64&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;ulong&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;bool&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;1或0的变长编码&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;bool&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;boolean&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;bool&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;bool&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;string&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;必须是&lt;code&gt;UTF-8&lt;/code&gt;编码&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;string&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;str/unicode&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;string&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;string&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;bytes&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;可包含任意的字节顺序&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;string&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;str&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;[]byte&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;ByteString&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>Go协程的思考</title>
      <link>https://domyson.github.io/post/lang/goroutine/</link>
      <pubDate>Sun, 12 May 2019 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/lang/goroutine/</guid>
      <description>&lt;h1 id=&#34;栈&#34;&gt;栈&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;一个 os 线程会有一个给固定大小的内存块（一般是 2MB），用来存储当前线程中调用或挂起函数的内部变量，固定大小的栈对于复杂和深层次递归是不够的，而 Goroutine 会以一个很小的栈（2KB）开始其生命周期，这个栈会动态伸缩，最大能到达 1GB（32位系统是 250M）&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;调度方式&#34;&gt;调度方式&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;os 线程由操作系统内核调用，每过一定时间（毫秒），硬件计时器会中断处理器，并调用一个名为 scheduler 的内建函数，这个函数会挂起当前执行的线程并保存内存中它的寄存器内存，然后检查线程列表并决定下一次执行哪个线程，并从内存中恢复该线程的寄存器信息，恢复该线程的线程并执行，这就是上下文切换，增加了 CPU 的运行周期。而 Go 的 runtime 包含了自身的调度器，和 os 线程不同是，&lt;code&gt;Goroutine&lt;/code&gt; 属于用户级线程由语言支持，调度由语言支持，所有开销会减少很多（相比于内核上下文切换）。&lt;/p&gt;&#xA;&lt;/blockquote&gt;</description>
    </item>
    <item>
      <title>Docker</title>
      <link>https://domyson.github.io/post/docker/</link>
      <pubDate>Tue, 12 Mar 2019 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/docker/</guid>
      <description>&lt;h1 id=&#34;什么是docker&#34;&gt;什么是docker&lt;/h1&gt;&#xA;&lt;p&gt;Docker 是一个开源的容器引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者和系统管理员在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括 VMs（虚拟机）、bare metal、OpenStack 集群、云端、数据中心和其他的基础应用平台。容器是完全使用沙箱机制，相互之间不会有任何接口。&lt;/p&gt;&#xA;&lt;h1 id=&#34;有什么优势&#34;&gt;有什么优势&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;轻量，在一台机器上运行的多个Docker容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;标准，Docker 容器基于开放式标准，能够在所有主流Linux版本、Microsoft Windows以及包括VM、裸机服务器和云在内的任何基础设施上运行。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;安全，Docker 赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一次发布，到处使用&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;docker和虚拟机&#34;&gt;Docker和虚拟机&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;特性&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;容器&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;虚拟机&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;启动&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;秒级&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;分钟级&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;硬盘&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;MB&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;GB&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;性能&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;接近原生&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;弱于原生&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;支持量&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;单机上千&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;单机几十左右&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;容器是一个应用层抽象，用于将代码和依赖资源打包在一起。 多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行 。与虚拟机相比， 容器占用的空间较少（容器镜像大小通常只有几十兆），瞬间就能完成启动。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;虚拟机（VM）是一个物理硬件层抽象，用于将一台服务器变成多台服务器。 管理程序允许多个VM在一台机器上运行。每个VM都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此占用大量空间。而且VM启动也十分缓慢 。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;虚拟机更擅长于彻底隔离整个运行环境。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而 Docker 通常用于隔离不同的应用 ，例如前端，后端以及数据库。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;docker基本组成&#34;&gt;Docker基本组成&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;镜像 （Image）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;容器（Container）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;仓库（Repository）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;镜像image-一个特殊的文件系统&#34;&gt;镜像（Image）—— 一个特殊的文件系统&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像（Image），就相当于是一个root文件系统。Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 镜像不包含任何动态数据，其内容在构建之后也不会被改变。Docker设计时，就充分利用Union FS的技术，将其设计为分层存储的架构。 镜像实际是由多层文件系统联合组成。镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;容器container-镜像运行时的实体&#34;&gt;容器（Container）—— 镜像运行时的实体&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。前面讲过镜像使用的是分层存储，容器也是如此。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。按照Docker最佳实践的要求，容器不应该向其存储层内写入任何数据 ，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， 使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;仓库repository-集中存放镜像文件的地方&#34;&gt;仓库（Repository）—— 集中存放镜像文件的地方&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。一个Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。所以说：镜像仓库是Docker用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过&amp;lt;仓库名&amp;gt;:&amp;lt;标签&amp;gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以latest作为默认标签。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;docker-registry公开服务和私有docker-registry&#34;&gt;Docker Registry公开服务和私有Docker Registry&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Docker Registry公开服务是开放给用户使用、允许用户管理镜像的Registry服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。最常使用的Registry公开服务是官方的Docker Hub ，这也是默认的Registry，并拥有大量的高质量的官方镜像，网址为：hub.docker.com/ 。在国内访问Docker Hub可能会比较慢国内也有一些云服务商提供类似于Docker Hub的公开服务。除了使用公开服务外，用户还可以在本地搭建私有Docker Registry 。Docker官方提供了Docker Registry镜像，可以直接使用做为私有Registry服务。开源的Docker Registry镜像只提供了Docker Registry API的服务端实现，足以支持Docker命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;image&#34;&gt;Image&lt;/h1&gt;&#xA;&lt;h2 id=&#34;查看拉取删除&#34;&gt;查看、拉取、删除&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;搜索镜像&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;docker search name[:tag]&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;拉取镜像,若不指定tag则默认拉取&lt;code&gt;latest&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;docker pull name[:tag]&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;查看本地所有镜像&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;docker images&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;删除镜像，可以多个删除&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;docker rmi [option] image ... &lt;/code&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;-f&lt;/code&gt; 强制删除&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;制作推送&#34;&gt;制作、推送&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;在指定路径中找到 &lt;a href=&#34;https://domyson.github.io/post/Dockerfile&#34;&gt;Dockerfile&lt;/a&gt; 并构建Image, 后面是路径，但路径中必须存在 &lt;code&gt;Dockerfile&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;docker build -t [:namespace]/name:tag Path&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;给镜像赋予新的标签, &lt;code&gt;namespace&lt;/code&gt; 必须为 &lt;code&gt;dockerid&lt;/code&gt;，除非另外购买。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;docker tag oldname:oldtag  namespace/newname:newtag&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;将镜像上传至 docker 仓库 DockerHub 上,&lt;code&gt;namespace&lt;/code&gt; 必须是用户名,也可以上传至 &lt;code&gt;Gitlab&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;docker push namespace/name:tag&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;docker&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;提交修改的镜像&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;docker commit [-a] [-m] CONTAINER [REPOSITORY[:TAG]]&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;-a&lt;/code&gt; 指明提交者&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;-m&lt;/code&gt; 提交信息&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。&#xA;此方式更新的镜像有依赖通过 &lt;code&gt;docker save -o dst [REPOSITORY[:TAG]]&lt;/code&gt;存盘,删除所有镜像,再通过 &lt;code&gt;docker load -i path&lt;/code&gt; 加载新镜像。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;container&#34;&gt;Container&lt;/h1&gt;&#xA;&lt;h2 id=&#34;查看容器&#34;&gt;查看容器&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;docker ps [-a|-s]&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;-a&lt;/code&gt; 查看所有容器。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;-s&lt;/code&gt; 查看已启动的容器。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;产看容器进程&#34;&gt;产看容器进程&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;docker top containerID&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;移除容器&#34;&gt;移除容器&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;可以多个同时删除&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;code&gt;docker rm container ...  [option]&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;-f&lt;/code&gt; : 强制删除容器。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;-v&lt;/code&gt; : 若删除容器则数据卷也删除。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;停止容器&#34;&gt;停止容器&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;可以同时停止多个&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;code&gt;docker stop container ...&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;启动容器&#34;&gt;启动容器&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;docker run [:--name] [:-e] [:-v] [:-h] [:--net] [:-p prot0:prot1] [:-d|-i] [:-t] [:--rm] [:--restart] [:--privileged=false] [:--ip] [:--network=] name:tag [:shell]&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;run&lt;/code&gt; 命令将会启动 &lt;code&gt;dockerfile&lt;/code&gt; 中定义的 &lt;code&gt;CMD&lt;/code&gt; 或 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 指令。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;--name=xxx&lt;/code&gt; 指定容器运行时的名称，可不选，默认为随机字符。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;-p Host0:Host1&lt;/code&gt; 表示本地 Host0 映射容器 Host1 端口,若为 &lt;code&gt;-P&lt;/code&gt; 则随机映射49000 ~ 49900 端口。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;-d&lt;/code&gt;：分离模式: 在后台运行。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;-h&lt;/code&gt;：指定主机域名。如 &lt;code&gt;-h domyson.cn&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;-e&lt;/code&gt;：为 &lt;code&gt;dockerfile&lt;/code&gt; 中的 &lt;code&gt;ENV&lt;/code&gt; 的参数变量,设置环境变量，或者覆盖已存在的环境变量 &lt;code&gt;-e TZ=&amp;quot;Asia/Shanghai&amp;quot;&lt;/code&gt; 设置时区为上海。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;-u&lt;/code&gt;：&lt;del&gt;指定执行用户，一般为 &lt;code&gt;root&lt;/code&gt;。&lt;/del&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;--rm&lt;/code&gt;：停止容器就移除。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;-it&lt;/code&gt;: 以交互模式运行容器 (不同于 &lt;code&gt;-d&lt;/code&gt; : 以分离模式运行容器),这意味着交互回话 session 结束时,容器就会停止运行，与 &lt;code&gt;-d&lt;/code&gt; 互斥。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;-v&lt;/code&gt; : 容器内创建一个数据卷。多次重复使用 -v 标记可以创建多个数据卷，也可以挂载一个主机目录作为数据卷 path0:path1(其中path0是主机目录，path1是容器目录)。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;--link container&lt;/code&gt; : &lt;del&gt;连接到其他容器。&lt;/del&gt; 这个方法以后将被弃用，推荐使用 &lt;code&gt;--network&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;--network NETWORK&lt;/code&gt;：指定连接到的网络。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;--ip&lt;/code&gt;：指定容器的ip。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;--restart&lt;/code&gt;：&lt;code&gt;no、on-failure:n、always&lt;/code&gt; 设置容器自动重启模式，若容器已经启动，可以通过 &lt;code&gt;docker update --restart args&lt;/code&gt; 来设置参数。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;--privileged&lt;/code&gt;：真正给予 &lt;code&gt;Container 中 root 用户&lt;/code&gt; root权限，否则 &lt;code&gt;root&lt;/code&gt; 只是一个普通用户。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;shell&lt;/code&gt;：指定交互的方式，一般为bash &lt;code&gt;bash -c &amp;quot;cmd string&amp;quot;&lt;/code&gt;，这条命令将由启动容器执行。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;查看容器日志&#34;&gt;查看容器日志&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;docker logs [opt] CONTAINER&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;-f&lt;/code&gt; : 跟踪日志输出&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;--since&lt;/code&gt; :显示某个开始时间的所有日志&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;-t&lt;/code&gt; : 显示时间戳&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;--tail N&lt;/code&gt; :仅列出最新N条容器日志&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;进入指定容器&#34;&gt;进入指定容器&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;docker exec [opt] CONTAINER shell [:args]&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;-d&lt;/code&gt; ：分离模式: 在后台运行&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;-it&lt;/code&gt;：以交互模式运行容器 (不同于 -d : 以分离模式运行容器),这意味着交互回话 session 结束时,容器就会停止运行。与 &lt;code&gt;-d&lt;/code&gt; 互斥&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;-u&lt;/code&gt;：指定运行用户,一般设置为 root&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;进入容器内部之后，通过 &lt;code&gt;exit&lt;/code&gt; 退出&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;容器通讯方式&#34;&gt;容器通讯方式&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://domyson.github.io/2020/01/Docker-Network/&#34;&gt;See DockerNetwork&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;镜像体积优化&#34;&gt;镜像体积优化&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt; 由多个 &lt;code&gt;Layers&lt;/code&gt; 组成（上限是127层）。而 &lt;a href=&#34;https://domyson.github.io/2019/03/Dockerfile&#34;&gt;Dockerfile&lt;/a&gt; 每一条指令都会创建一层 &lt;code&gt;Layers&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;优化基础镜像&#34;&gt;优化基础镜像&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;使用 &lt;code&gt;Alpine&lt;/code&gt; 基础镜像&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Alpine是一个高度精简又包含了基本工具的轻量级Linux发行版，基础镜像仅 &lt;code&gt;4.41MB&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;使用 &lt;code&gt;scratch&lt;/code&gt; 基础镜像&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;scratch是一个空镜像，只能用于构建其他镜像&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;使用 &lt;code&gt;busybox&lt;/code&gt; 基础镜像&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;如果希望镜像里可以包含一些常用的Linux工具，busybox镜像是个不错选择，镜像本身只有1.16M，非常便于构建小镜像。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;串联-dockerfile-指令&#34;&gt;串联 &lt;code&gt;Dockerfile&lt;/code&gt; 指令&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;通过  &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;\&lt;/code&gt; 将多个 &lt;code&gt;Run&lt;/code&gt; 命令合并成一个&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;多段构建&#34;&gt;多段构建&lt;/h2&gt;&#xA;&lt;p&gt;待完善&lt;/p&gt;&#xA;&lt;h2 id=&#34;heading&#34;&gt;&lt;/h2&gt;&#xA;&lt;h1 id=&#34;docker数据卷&#34;&gt;Docker数据卷&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据卷可以在容器之间共享和重用&lt;/li&gt;&#xA;&lt;li&gt;对数据卷的修改会立马生效&lt;/li&gt;&#xA;&lt;li&gt;对数据卷的更新，不会影响镜像&lt;/li&gt;&#xA;&lt;li&gt;数据卷默认会一直存在，即使容器被删除&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;创建数据卷&#34;&gt;创建数据卷&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;在 run 命令中 -v /data 标记来创建一个数据卷并挂载到容器里。在一次 run 中多次使用可以挂载多个数据卷。(创建一个容器，并加载一个数据卷到容器的 /data 目录)&#xA;&#xA;也可以在 Dockerfile 中使用  VOLUME  来添加一个或者多个新的卷到由该镜像创建的任意容器。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;删除数据卷&#34;&gt;删除数据卷&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用  docker rm -v  这个命令。无主的数据卷可能会占据很多空间，要清理会很麻烦。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;挂载一个主机目录作为数据卷&#34;&gt;挂载一个主机目录作为数据卷&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker run -d -P --name web -v /src/webapp:/opt/webapp[:权限]&#xA;&#xA;上面的命令加载主机的  /src/webapp  目录到容器的  /opt/webapp  目录，默认权限是读写，也可以指定为只读(ro)&#xA;&#xA;--volumes-from 在run的时候指定数据卷容器&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;查看数据卷的信息&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;docker inspect contianerID&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;查看所有数据卷&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;docker volume ls&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;清除所有无主数据卷&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;docker volume prune&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;docker权限验证&#34;&gt;Docker权限验证&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;版本&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;docker version&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;登陆&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;docker login&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;登出&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;docker logout&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;docker远程访问&#34;&gt;Docker远程访问&lt;/h1&gt;&#xA;&lt;h1 id=&#34;docker-compose&#34;&gt;Docker-Compose&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;code&gt;Docker-Compose&lt;/code&gt; （docker编排）是 docker 提供的一个命令行工具，用来定义和运行由多个容器组成的应用。可以通过 docker-compose.yml 文件声明式的定义应用程序的各个服务，并由单个命令完成应用的创建和启动。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/compose/&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;code&gt;Docker-Compose&lt;/code&gt;将所管理的容器分为三层，分别是工程（project），服务（service）以及容器（container）。Docker-Compose运行目录下的所有文件（docker-compose.yml，extends文件或环境变量文件等）组成一个工程，若无特殊指定工程名即为当前目录名。一个工程当中可包含多个服务，每个服务中定义了容器运行的镜像，参数，依赖。一个服务当中可包括多个容器实例，Docker-Compose并没有解决负载均衡的问题，因此需要借助其它工具实现服务发现及负载均衡。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Nginx</title>
      <link>https://domyson.github.io/post/nginx/</link>
      <pubDate>Sat, 09 Mar 2019 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/nginx/</guid>
      <description>&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Nginx功能丰富，可作为HTTP服务器，也可作为反向代理服务器，邮件服务器。支持FastCGI、SSL、Virtual Host、URL Rewrite、Gzip等功能。并且支持很多第三方的模块扩展。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://nginx.org/en/download.html&#34;&gt;Nginx下载&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;常用功能&#34;&gt;常用功能&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;负载均衡&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;反向代理&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;正向代理&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;文件服务器&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Markdown</title>
      <link>https://domyson.github.io/post/markdown/</link>
      <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/markdown/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://xianbai.me/learn-md/article/syntax/emphasis.html&#34;&gt;Link&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;markdown语法&#34;&gt;Markdown语法&lt;/h1&gt;&#xA;&lt;h1 id=&#34;目录&#34;&gt;目录&lt;/h1&gt;&#xA;&lt;p&gt;只能跳转标题，如果有同名标题与标题等级无关，匹配最优先的标题&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E3%80%81%E6%A0%87%E9%A2%98&#34;&gt;标题&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E3%80%81%E5%AD%97%E4%BD%93&#34;&gt;字体&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E3%80%81%E5%BC%95%E7%94%A8&#34;&gt;引用&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B%E3%80%81%E5%88%86%E5%89%B2%E7%BA%BF&#34;&gt;分割线&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%85%AD%E3%80%81%E8%B6%85%E9%93%BE%E6%8E%A5&#34;&gt;超链接&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%85%AB%E3%80%81%E8%A1%A8%E6%A0%BC&#34;&gt;表格&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E4%B9%9D%E3%80%81%E4%BB%A3%E7%A0%81&#34;&gt;代码&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E3%80%81%E6%B5%81%E7%A8%8B%E5%9B%BE&#34;&gt;流程图&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E4%B8%80%E3%80%81%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE&#34;&gt;语法高亮&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E4%BA%8C%E3%80%81%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6&#34;&gt;转义字符&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>I/O</title>
      <link>https://domyson.github.io/post/linux/io/</link>
      <pubDate>Mon, 25 Feb 2019 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/linux/io/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;数据的读取分为:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;等待数据准备&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;等待内核拷贝至用户空间&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;基本模型矩阵&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;阻塞&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;非阻塞&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;同步&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;Read/Write&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;Read\Write(O_NONBLOCK)&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;异步&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;I/O multiplexing(select/poll)&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;AIO&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://domyson.github.io/post/linux/file/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/linux/file/</guid>
      <description>&lt;h1 id=&#34;liunx-文件系统&#34;&gt;Liunx 文件系统&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;对于 &lt;code&gt;drwxr-xr-x 4 root root 4096 Nov 28 00:00 hook&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;文件类型&#34;&gt;文件类型&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;符号&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;d&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;目录&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;l&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;符号链接&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;s&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;套接字文件&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;b&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;块设备文件&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;c&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;字符设备文件&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;p&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;命名管道文件&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;-&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;普通文件，不属于上述任意一种&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;权限更换&#34;&gt;权限更换&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;code&gt;chmod [who] operator [permission] filename&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;who&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;符号&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;u&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;文件属主权限&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;g&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;同组用户权限&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;o&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;其他用户权限&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;a&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;所有用户&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;operator&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;符号&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;+&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;增加权限&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;-&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;取消权限&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;=&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;设定权限&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;permission&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;符号&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;r&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;读权限&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;w&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;写权限&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;x&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;执行权限&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://domyson.github.io/post/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://domyson.github.io/post/readme/</guid>
      <description>&lt;h1 id=&#34;about-me-&#34;&gt;About me 👋&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;I love games, I love coding, and I&amp;rsquo;m interested in games, computer principles, and operating systems.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;I often use go,c, csharp,lua to develop some frameworks and tools, and now I am working on arm and rust.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;I developed the service framework skynet-go(based on cgo) and the game framework Zen(based on Unity3d).&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;I also developed an register base scripting language (scriptc).&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Also wrote a new coding protocol (kproto) which is faster than protobuf-v3.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
