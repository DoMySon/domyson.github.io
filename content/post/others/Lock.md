---
title: 线程锁
date: 2019-02-26
tags: [""]
categories: ["八股文"]
description: 解决并发场景下的数据竞争问题
toc: true
draft: true
---
# 简介

> 锁是传统并发程序对共享资源进行访问控制的主要手段。

<!--more-->

# 悲观锁

+ 假想最坏的情况，每次拿数据前都会上锁(可上锁的情况下,否则等待) 直到修改完数据。

+ 若锁住时间长，则会严重影响性能。

+ 优点:
    
    1. 在竞争激烈条件下更有优势

    2. 当锁住的不止有一个变量的情况下

+ 缺点:
    
    1. 即乐观锁的优点


# 乐观锁

+ 假想最好的情况，认为别人不会修改数据，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，如果有则放弃操作，无则执行操作

+ 乐观锁的核心算法`CAS`（`Compare And Swap`，比较并交换），它涉及到三个操作数：内存值、预期值、新值，当且仅当预期值和内存值相等时才将内存值修改为新值。这样处理的逻辑是，首先检查某块内存的值是否跟之前我读取时的一样，如不一样则表示期间此内存值已经被别的线程更改过，舍弃本次操作，否则说明期间没有其他线程对此内存值操作，可以把新值设置给此块内存。

+ 优点：

    1. 乐观锁避免了悲观锁独占对象的现象，同时也提高了并发性能。


+ 缺点：

    1. 乐观锁只能保证一个共享变量的原子操作。这时如果多一个或几个变量，乐观锁将变得力不从心，但互斥锁能轻易解决，不管对象数量多少及对象颗粒度大小。

    2. 在并发冲突概率大的高竞争环境下，如果CAS一直失败，会一直重试，CPU开销较大。针对这个问题的一个思路是引入退出机制，如重试次数超过一定阈值后失败退出。当然，更重要的是避免在 `高竞争` 环境下使用乐观锁。

    3. ABA问题。CAS的核心思想是通过比对内存值与预期值是否一样而判断内存值是否被改过，但这个判断逻辑不严谨，假如内存值原来是A，后来被一条线程改为B，最后又被改成了A，则 `CAS `认为此内存值并没有发生改变，但实际上是有被其他线程改过的，这种情况对依赖过程值的情景的运算结果影响很大。一个栈的栈顶经过两次(或多次)变化又恢复了原值，但是栈可能已发生了变化。解决的思路是引入版本号，每次变量更新都把版本号加一。

## 原理

1. 需要读写的内存位置 `V`
2. 进行比较的预期值 `A`
3. 拟写入的新值 `B`

## 没想好

1. 乐观锁本身不加锁，只在判断数据是否被其他线程更新了
2. 有时乐观锁可能与加锁操作合作，但不代表 **乐观锁加锁**
